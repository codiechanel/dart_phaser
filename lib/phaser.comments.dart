@JS()
library phaser.phaser.comments;

import "package:js/js.dart";
import "package:meta/meta.dart";
import "microsoft.dart";
import "pixi.comments.dart"
    show
        BaseTexture,
        Texture,
        DisplayObjectContainer,
        DisplayObject,
        AbstractFilter,
        Sprite,
        RenderTexture,
        Rope,
        Point,
        TilingSprite;
import "dart:html"
    show
        ImageElement,
        CanvasElement,
        CanvasRenderingContext2D,
        ImageData,
        HtmlElement,
        DivElement,
        KeyboardEvent,
        HttpRequest,
        XmlDocument,
        MouseEvent,
        VideoElement,
        Blob,
        Event;
import "dart:typed_data" show ByteBuffer, Uint8List, Uint32List, Float32List;
import "package:func/func.dart";
import "dart:web_gl" show Framebuffer;
import "p2.dart"
    show
        BodyOptions,
        ContactMaterialOptions,
        RotationalSpring,
        Constraint,
        Capsule,
        Shape,
        Plane,
        ContactMaterial,
        DistanceConstraint,
        GearConstraint,
        LockConstraint,
        Material,
        PrismaticConstraint,
        RevoluteConstraint,
        LinearSpring;

/// <reference path="pixi.comments.d.ts" />
/// <reference path="p2.d.ts" />

/// Type definitions for Phaser CE
/// Project: https://github.com/photonstorm/phaser-ce

// Module phaser-ce
/* WARNING: export assignment not yet supported. */

// End module phaser-ce
@JS()
class Phaser {
  // @Ignore
  Phaser.fakeConstructor$();
  external static String get VERSION;
  external static set VERSION(String v);
  external static String get DEV_VERSION;
  external static set DEV_VERSION(String v);
  external static List<Game> get GAMES;
  external static set GAMES(List<Game> v);
  external static num get AUTO;
  external static set AUTO(num v);
  external static num get CANVAS;
  external static set CANVAS(num v);
  external static num get WEBGL;
  external static set WEBGL(num v);
  external static num get HEADLESS;
  external static set HEADLESS(num v);
  external static num get WEBGL_MULTI;
  external static set WEBGL_MULTI(num v);
  external static num get BITMAPDATA;
  external static set BITMAPDATA(num v);
  external static num get BITMAPTEXT;
  external static set BITMAPTEXT(num v);
  external static num get BUTTON;
  external static set BUTTON(num v);
  external static num get CANVAS_FILTER;
  external static set CANVAS_FILTER(num v);
  external static num get CIRCLE;
  external static set CIRCLE(num v);
  external static num get ELLIPSE;
  external static set ELLIPSE(num v);
  external static num get EMITTER;
  external static set EMITTER(num v);
  external static num get GRAPHICS;
  external static set GRAPHICS(num v);
  external static num get GROUP;
  external static set GROUP(num v);
  external static num get IMAGE;
  external static set IMAGE(num v);
  external static num get LINE;
  external static set LINE(num v);
  external static num get MATRIX;
  external static set MATRIX(num v);
  external static num get POINT;
  external static set POINT(num v);
  external static num get POINTER;
  external static set POINTER(num v);
  external static num get POLYGON;
  external static set POLYGON(num v);
  external static num get RECTANGLE;
  external static set RECTANGLE(num v);
  external static num get ROUNDEDRECTANGLE;
  external static set ROUNDEDRECTANGLE(num v);
  external static num get RENDERTEXTURE;
  external static set RENDERTEXTURE(num v);
  external static num get RETROFONT;
  external static set RETROFONT(num v);
  external static num get SPRITE;
  external static set SPRITE(num v);
  external static num get SPRITEBATCH;
  external static set SPRITEBATCH(num v);
  external static num get TEXT;
  external static set TEXT(num v);
  external static num get TILEMAP;
  external static set TILEMAP(num v);
  external static num get TILEMAPLAYER;
  external static set TILEMAPLAYER(num v);
  external static num get TILESPRITE;
  external static set TILESPRITE(num v);
  external static num get WEBGL_FILTER;
  external static set WEBGL_FILTER(num v);
  external static num get ROPE;
  external static set ROPE(num v);
  external static num get CREATURE;
  external static set CREATURE(num v);
  external static num get VIDEO;
  external static set VIDEO(num v);
  external static num get NONE;
  external static set NONE(num v);
  external static num get LEFT;
  external static set LEFT(num v);
  external static num get RIGHT;
  external static set RIGHT(num v);
  external static num get UP;
  external static set UP(num v);
  external static num get DOWN;
  external static set DOWN(num v);
  external static num get HORIZONTAL;
  external static set HORIZONTAL(num v);
  external static num get VERTICAL;
  external static set VERTICAL(num v);
  external static num get LANDSCAPE;
  external static set LANDSCAPE(num v);
  external static num get PORTRAIT;
  external static set PORTRAIT(num v);
  external static num get ANGLE_UP;
  external static set ANGLE_UP(num v);
  external static num get ANGLE_DOWN;
  external static set ANGLE_DOWN(num v);
  external static num get ANGLE_LEFT;
  external static set ANGLE_LEFT(num v);
  external static num get ANGLE_RIGHT;
  external static set ANGLE_RIGHT(num v);
  external static num get ANGLE_NORTH_EAST;
  external static set ANGLE_NORTH_EAST(num v);
  external static num get ANGLE_NORTH_WEST;
  external static set ANGLE_NORTH_WEST(num v);
  external static num get ANGLE_SOUTH_EAST;
  external static set ANGLE_SOUTH_EAST(num v);
  external static num get ANGLE_SOUTH_WEST;
  external static set ANGLE_SOUTH_WEST(num v);
  external static num get TOP_LEFT;
  external static set TOP_LEFT(num v);
  external static num get TOP_CENTER;
  external static set TOP_CENTER(num v);
  external static num get TOP_RIGHT;
  external static set TOP_RIGHT(num v);
  external static num get LEFT_TOP;
  external static set LEFT_TOP(num v);
  external static num get LEFT_CENTER;
  external static set LEFT_CENTER(num v);
  external static num get LEFT_BOTTOM;
  external static set LEFT_BOTTOM(num v);
  external static num get CENTER;
  external static set CENTER(num v);
  external static num get RIGHT_TOP;
  external static set RIGHT_TOP(num v);
  external static num get RIGHT_CENTER;
  external static set RIGHT_CENTER(num v);
  external static num get RIGHT_BOTTOM;
  external static set RIGHT_BOTTOM(num v);
  external static num get BOTTOM_LEFT;
  external static set BOTTOM_LEFT(num v);
  external static num get BOTTOM_CENTER;
  external static set BOTTOM_CENTER(num v);
  external static num get BOTTOM_RIGHT;
  external static set BOTTOM_RIGHT(num v);
}

// Module Phaser
@JS("Phaser.blendModes")
class blendModes {
  external static num get NORMAL;
  external static num get ADD;
  external static num get MULTIPLY;
  external static num get SCREEN;
  external static num get OVERLAY;
  external static num get DARKEN;
  external static num get LIGHTEN;
  external static num get COLOR_DODGE;
  external static num get COLOR_BURN;
  external static num get HARD_LIGHT;
  external static num get SOFT_LIGHT;
  external static num get DIFFERENCE;
  external static num get EXCLUSION;
  external static num get HUE;
  external static num get SATURATION;
  external static num get COLOR;
  external static num get LUMINOSITY;
}

@JS("Phaser.scaleModes")
class scaleModes {
  external static num get DEFAULT;
  external static num get LINEAR;
  external static num get NEAREST;
}

/// An Animation instance contains a single animation and the controls to play it.
/// It is created by the AnimationManager, consists of Animation.Frame objects and belongs to a single Game Object such as a Sprite.
@JS("Phaser.Animation")
class Animation {
  // @Ignore
  Animation.fakeConstructor$();

  /// An Animation instance contains a single animation and the controls to play it.
  /// It is created by the AnimationManager, consists of Animation.Frame objects and belongs to a single Game Object such as a Sprite.
  external factory Animation(Game game, Sprite parent, String name,
      FrameData frameData, List<dynamic> /*List<num>|List<String>*/ frames,
      [num frameRate, bool loop]);

  /// The currently displayed frame of the Animation.
  external Frame get currentFrame;
  external set currentFrame(Frame v);

  /// The delay in ms between each frame of the Animation, based on the given frameRate.
  external num get delay;
  external set delay(num v);

  /// Gets or sets if this animation will dispatch the onUpdate events upon changing frame.
  external bool get enableUpdate;
  external set enableUpdate(bool v);

  /// Gets or sets the current frame index and updates the Texture Cache for display.
  external num get frame;
  external set frame(num v);

  /// The total number of frames in the currently loaded FrameData, or -1 if no FrameData is loaded.
  external num get frameTotal;
  external set frameTotal(num v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// The finished state of the Animation. Set to true once playback completes, false during playback.
  external bool get isFinished;
  external set isFinished(bool v);

  /// The paused state of the Animation.
  external bool get isPaused;
  external set isPaused(bool v);

  /// The playing state of the Animation. Set to false once playback completes, true during playback.
  external bool get isPlaying;
  external set isPlaying(bool v);

  /// Should the parent of this Animation be killed when the animation completes?
  external bool get killOnComplete;
  external set killOnComplete(bool v);

  /// The loop state of the Animation.
  external bool get loop;
  external set loop(bool v);

  /// The number of times the animation has looped since it was last started.
  external num get loopCount;
  external set loopCount(num v);

  /// The user defined name given to this Animation.
  external String get name;
  external set name(String v);

  /// This event is dispatched when this Animation completes playback. If the animation is set to loop this is never fired, listen for onLoop instead.
  external Signal get onComplete;
  external set onComplete(Signal v);

  /// This event is dispatched when this Animation loops.
  external Signal get onLoop;
  external set onLoop(Signal v);

  /// This event is dispatched when this Animation starts playback.
  external Signal get onStart;
  external set onStart(Signal v);

  /// This event is dispatched when the Animation changes frame.
  /// By default this event is disabled due to its intensive nature. Enable it with: `Animation.enableUpdate = true`.
  /// Note that the event is only dispatched with the current frame. In a low-FPS environment Animations
  /// will automatically frame-skip to try and claw back time, so do not base your code on expecting to
  /// receive a perfectly sequential set of frames from this event.
  external Signal get onUpdate;
  external set onUpdate(Signal v);

  /// Gets and sets the paused state of this Animation.
  external bool get paused;
  external set paused(bool v);

  /// Gets and sets the isReversed state of this Animation.
  external bool get reversed;
  external set reversed(bool v);

  /// Gets or sets the current speed of the animation in frames per second. Changing this in a playing animation will take effect from the next frame. Value must be greater than 0.
  external num get speed;
  external set speed(num v);

  /// Called internally when the animation finishes playback.
  /// Sets the isPlaying and isFinished states and dispatches the onAnimationComplete event if it exists on the parent and local onComplete event.
  external void complete();

  /// Cleans up this animation ready for deletion. Nulls all values and references.
  external void destroy();

  /// Really handy function for when you are creating arrays of animation data but it's using frame names and not numbers.
  /// For example imagine you've got 30 frames named: 'explosion_0001-large' to 'explosion_0030-large'
  /// You could use this function to generate those by doing: Phaser.Animation.generateFrameNames('explosion_', 1, 30, '-large', 4);
  external static List<String> generateFrameNames(
      String prefix, num start, num stop,
      [String suffix, num zeroPad]);

  /// Advances by the given number of frames in the Animation, taking the loop value into consideration.
  external void next([num quantity]);

  /// Called when the Game enters a paused state.
  external void onPause();

  /// Called when the Game resumes from a paused state.
  external void onResume();

  /// Plays this animation.
  /// If you need to jump to a specific frame of this animation, then call `play` and immediately after it,
  /// set the frame you require (i.e. `animation.play(); animation.frame = 4`).
  external Animation play([num frameRate, bool loop, bool killOnComplete]);

  /// Moves backwards the given number of frames in the Animation, taking the loop value into consideration.
  external void previous([num quantity]);

  /// Sets this animation back to the first frame and restarts the animation.
  external void restart();

  /// Reverses the animation direction.
  external Animation reverse();

  /// Reverses the animation direction for the current/next animation only
  /// Once the onComplete event is called this method will be called again and revert
  /// the reversed state.
  external Animation reverseOnce();

  /// Sets this animations playback to a given frame with the given ID.
  external void setFrame(
      [dynamic /*String|num*/ frameId, bool useLocalFrameIndex]);

  /// Stops playback of this animation and set it to a finished state. If a resetFrame is provided it will stop playback and set frame to the first in the animation.
  /// If `dispatchComplete` is true it will dispatch the complete events, otherwise they'll be ignored.
  external void stop([bool resetFrame, bool dispatchComplete]);

  /// Updates this animation. Called automatically by the AnimationManager.
  external bool update();

  /// Changes the currentFrame per the _frameIndex, updates the display state,
  /// and triggers the update signal.
  /// Returns true if the current frame update was 'successful', false otherwise.
  external bool updateCurrentFrame(bool signalUpdate, [bool fromPlay]);

  /// Changes the FrameData object this Animation is using.
  external void updateFrameData(FrameData frameData);
}

/// The Animation Manager is used to add, play and update Phaser Animations.
/// Any Game Object such as Phaser.Sprite that supports animation contains a single AnimationManager instance.
@JS("Phaser.AnimationManager")
class AnimationManager {
  // @Ignore
  AnimationManager.fakeConstructor$();

  /// The Animation Manager is used to add, play and update Phaser Animations.
  /// Any Game Object such as Phaser.Sprite that supports animation contains a single AnimationManager instance.
  external factory AnimationManager(Sprite sprite);

  /// The currently displayed animation, if any.
  external Animation get currentAnim;
  external set currentAnim(Animation v);

  /// The currently displayed Frame of animation, if any.
  /// This property is only set once an Animation starts playing. Until that point it remains set as `null`.
  external Frame get currentFrame;
  external set currentFrame(Frame v);

  /// Gets or sets the current frame index and updates the Texture Cache for display.
  external num get frame;
  external set frame(num v);

  /// The current animations FrameData.
  external FrameData get frameData;
  external set frameData(FrameData v);

  /// Gets or sets the current frame name and updates the Texture Cache for display.
  external String get frameName;
  external set frameName(String v);

  /// The total number of frames in the currently loaded FrameData, or -1 if no FrameData is loaded.
  external num get frameTotal;
  external set frameTotal(num v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// Set to true once animation data has been loaded.
  external bool get isLoaded;
  external set isLoaded(bool v);

  /// Gets the current animation name, if set.
  external String get name;
  external set name(String v);

  /// Gets and sets the paused state of the current animation.
  external bool get paused;
  external set paused(bool v);

  /// A reference to the parent Sprite that owns this AnimationManager.
  external Sprite get sprite;
  external set sprite(Sprite v);

  /// Update the animation data only while the the sprite is [Phaser.Sprite#visible]. Set to `false` to continue updating while the sprite is invisible.
  /// Default: true
  external bool get updateIfVisible;
  external set updateIfVisible(bool v);

  /// Adds a new animation under the given key. Optionally set the frames, frame rate and loop.
  /// Animations added in this way are played back with the play function.
  external Animation add(String name,
      [List<dynamic> /*List<num>|List<String>*/ frames,
      num frameRate,
      bool loop,
      bool useNumericIndex]);

  /// Loads FrameData into the internal temporary vars and resets the frame index to zero.
  /// This is called automatically when a new Sprite is created.
  external bool copyFrameData(
      FrameData frameData, dynamic /*String|num*/ frame);

  /// Destroys all references this AnimationManager contains.
  /// Iterates through the list of animations stored in this manager and calls destroy on each of them.
  external void destroy();

  /// Returns an animation that was previously added by name.
  external Animation getAnimation(String name);

  /// Advances by the given number of frames in the current animation, taking the loop value into consideration.
  external void next([num quantity]);

  /// Play an animation based on the given key. The animation should previously have been added via `animations.add`
  /// If the requested animation is already playing this request will be ignored.
  /// If you need to reset an already running animation do so directly on the Animation object itself.
  /// If you need to jump to a specific frame of this animation, then call `play` and immediately after it,
  /// set the frame you require (i.e. `animation.play(); animation.frame = 4`).
  external Animation play(String name,
      [num frameRate, bool loop, bool killOnComplete]);

  /// Moves backwards the given number of frames in the current animation, taking the loop value into consideration.
  external void previous([num quantity]);

  /// Stop playback of an animation. If a name is given that specific animation is stopped, otherwise the current animation is stopped.
  /// The currentAnim property of the AnimationManager is automatically set to the animation given.
  external void stop([String name, bool resetFrame]);

  /// The main update function is called by the Sprites update loop. It's responsible for updating animation frames and firing related events.
  external bool update();

  /// Check whether the frames in the given array are valid and exist.
  external bool validateFrames(List<Frame> frames, [bool useNumericIndex]);
}

/// Responsible for parsing sprite sheet and JSON data into the internal FrameData format that Phaser uses for animations.
@JS("Phaser.AnimationParser")
class AnimationParser {
  // @Ignore
  AnimationParser.fakeConstructor$();

  /// Parse the JSON data and extract the animation frame data from it.
  external static FrameData JSONData(Game game, dynamic json);

  /// Parse the JSON data and extract the animation frame data from it.
  external static FrameData JSONDataHash(Game game, dynamic json);

  /// Parse the JSON data and extract the animation frame data from it.
  external static FrameData JSONDataPyxel(Game game, dynamic json);

  /// Parse a Sprite Sheet and extract the animation frame data from it.
  external static FrameData spriteSheet(
      Game game, String key, num frameWidth, num frameHeight,
      [num frameMax, num margin, num spacing, num skipFrames]);

  /// Parse the XML data and extract the animation frame data from it.
  external static FrameData XMLData(Game game, dynamic xml);
}

/// Audio Sprites are a combination of audio files and a JSON configuration.
/// The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite
@JS("Phaser.AudioSprite")
class AudioSprite {
  // @Ignore
  AudioSprite.fakeConstructor$();

  /// Audio Sprites are a combination of audio files and a JSON configuration.
  /// The JSON follows the format of that created by https://github.com/tonistiigi/audiosprite
  external factory AudioSprite(Game game, String key);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// Asset key for the Audio Sprite.
  external String get key;
  external set key(String v);

  /// JSON audio atlas object.
  external dynamic get config;
  external set config(dynamic v);

  /// If a sound is set to auto play, this holds the marker key of it.
  external String get autoplayKey;
  external set autoplayKey(String v);

  /// Is a sound set to autoplay or not?
  external bool get autoplay;
  external set autoplay(bool v);

  /// An object containing the Phaser.Sound objects for the Audio Sprite.
  external dynamic get sounds;
  external set sounds(dynamic v);

  /// Get a sound with the given name.
  external Sound JS$get(String marker);

  /// Play a sound with the given name.
  external Sound play(String marker, [num volume]);

  /// Stop a sound with the given name.
  external Sound stop(String marker);
}

/// ArraySet is a Set data structure (items must be unique within the set) that also maintains order.
/// This allows specific items to be easily added or removed from the Set.
/// Item equality (and uniqueness) is determined by the behavior of `Array.indexOf`.
/// This used primarily by the Input subsystem.
@JS("Phaser.ArraySet")
class ArraySet {
  // @Ignore
  ArraySet.fakeConstructor$();

  /// ArraySet is a Set data structure (items must be unique within the set) that also maintains order.
  /// This allows specific items to be easily added or removed from the Set.
  /// Item equality (and uniqueness) is determined by the behavior of `Array.indexOf`.
  /// This used primarily by the Input subsystem.
  external factory ArraySet(List<dynamic> list);

  /// Current cursor position as established by `first` and `next`.
  external num get position;
  external set position(num v);

  /// The backing array.
  external List<dynamic> get list;
  external set list(List<dynamic> v);

  /// Number of items in the ArraySet. Same as `list.length`.
  external num get total;
  external set total(num v);

  /// Returns the first item and resets the cursor to the start.
  external dynamic get first;
  external set first(dynamic v);

  /// Returns the the next item (based on the cursor) and advances the cursor.
  external dynamic get next;
  external set next(dynamic v);

  /// Adds a new element to the end of the list.
  /// If the item already exists in the list it is not moved.
  external dynamic add(dynamic item);

  /// Gets an item from the set based on the property strictly equaling the value given.
  /// Returns null if not found.
  external dynamic getByKey(String property, dynamic value);

  /// Gets the index of the item in the list, or -1 if it isn't in the list.
  external num getIndex(dynamic item);

  /// Checks for the item within this list.
  external bool exists(dynamic item);

  /// Removes all the items.
  external void reset();

  /// Removes the given element from this list if it exists.
  external dynamic remove(dynamic item);

  /// Removes every member from this ArraySet and optionally destroys it.
  external void removeAll([bool destoy]);

  /// Sets the property `key` to the given value on all members of this list.
  external void setAll(dynamic key, dynamic value);

  /// Calls a function on all members of this list, using the member as the context for the callback.
  /// If the `key` property is present it must be a function.
  /// The function is invoked using the item as the context.
  external void callAll(String key,
      [dynamic parameter1,
      dynamic parameter2,
      dynamic parameter3,
      dynamic parameter4,
      dynamic parameter5]);
}

/// Utility functions for dealing with Arrays.
@JS("Phaser.ArrayUtils")
class ArrayUtils {
  // @Ignore
  ArrayUtils.fakeConstructor$();

  /// Fetch a random entry from the given array.
  /// Will return null if there are no array items that fall within the specified range
  /// or if there is no item for the randomly chosen index.
  external static dynamic/*=T*/ getRandomItem/*<T>*/(
      List<dynamic/*=T*/ > objects,
      [num startIndex,
      num length]);

  /// Removes a random object from the given array and returns it.
  /// Will return null if there are no array items that fall within the specified range
  /// or if there is no item for the randomly chosen index.
  external static dynamic/*=T*/ removeRandomItem/*<T>*/(
      List<dynamic/*=T*/ > objects,
      [num startIndex,
      num length]);

  /// Remove one or more items at the given index and reorder the array.
  /// The new array length will be `array.length - count`.
  /// This is an alternative to `array.splice(startIndex, count)`.
  external static dynamic/*=T*/ remove/*<T>*/(
      List<dynamic/*=T*/ > array, num startIndex,
      [num count]);

  /// A standard Fisher-Yates Array shuffle implementation which modifies the array in place.
  external static List<dynamic/*=T*/ > shuffle/*<T>*/(
      List<dynamic/*=T*/ > array);

  /// Transposes the elements of the given matrix (array of arrays).
  external static dynamic/*=T*/ transposeMatrix/*<T>*/(
      List<dynamic/*=T*/ > array);

  /// Rotates the given matrix (array of arrays).
  /// Based on the routine from [http://jsfiddle.net/MrPolywhirl/NH42z/].
  external static dynamic rotateMatrix(
      dynamic matrix, dynamic /*num|String*/ direction);

  /// Snaps a value to the nearest value in a sorted numeric array.
  /// The result will always be in the range `[first_value, last_value]`.
  external static num findClosest(num value, List<num> arr);

  /// Moves the element from the start of the array to the end, shifting all items in the process.
  /// The "rotation" happens to the left.
  /// Before: `[ A, B, C, D, E, F ]`
  /// After: `[ B, C, D, E, F, A ]`
  /// See also Phaser.ArrayUtils.rotateRight
  external static dynamic rotate(List<dynamic> array);

  /// Moves the element from the start of the array to the end, shifting all items in the process.
  /// The "rotation" happens to the left.
  /// Before: `[ A, B, C, D, E, F ]`
  /// After: `[ B, C, D, E, F, A ]`
  /// See also Phaser.ArrayUtils.rotateRight
  external static dynamic rotateLeft(List<dynamic> array);

  /// Moves the element from the end of the array to the start, shifting all items in the process.
  /// The "rotation" happens to the right.
  /// Before: `[ A, B, C, D, E, F ]`
  /// After: `[ F, A, B, C, D, E ]`
  /// See also Phaser.ArrayUtils.rotateLeft.
  external static dynamic rotateRight(List<dynamic> array);

  /// Create an array representing the inclusive range of numbers (usually integers) in `[start, end]` (or `[0, start]`, if `end` is omitted).
  /// This is equivalent to `numberArrayStep(start, 1 + end, 1)`.
  /// When exactly one argument is passed, it's used as `end` and 0 is used as `start`. The length of the result is (1 + end).
  /// ##### Examples
  /// ```javascript
  /// numberArray(3);    // -> [0, 1, 2, 3]
  /// numberArray(0, 3); // -> [0, 1, 2, 3]
  /// numberArray(1, 3); // -> [1, 2, 3]
  /// ```
  external static List<num> numberArray(num start, [num end]);

  /// Create an array of numbers (positive and/or negative) progressing from `start`
  /// up to but not including `end` by advancing by `step`.
  /// If `start` is less than `end` a zero-length range is created unless a negative `step` is specified.
  /// Certain values for `start` and `end` (eg. NaN/undefined/null) are currently coerced to 0;
  /// for forward compatibility make sure to pass in actual numbers.
  external static List<num> numberArrayStep(num start, [num end, num step]);
}

@anonymous
@JS()
abstract class BitmapFont {
  external BaseTexture get base;
  external set base(BaseTexture v);
  external ImageElement get data;
  external set data(ImageElement v);
  external BMFont get font;
  external set font(BMFont v);
  external String get url;
  external set url(String v);
  external factory BitmapFont(
      {BaseTexture base, ImageElement data, BMFont font, String url});
}

@anonymous
@JS()
abstract class BMFont {
  external List<BMFontChar> get chars;
  external set chars(List<BMFontChar> v);
  external String get font;
  external set font(String v);
  external num get lineHeight;
  external set lineHeight(num v);
  external num get size;
  external set size(num v);
  external factory BMFont(
      {List<BMFontChar> chars, String font, num lineHeight, num size});
}

@anonymous
@JS()
abstract class BMFontChar {
  external num get x;
  external set x(num v);
  external num get y;
  external set y(num v);
  external num get width;
  external set width(num v);
  external num get height;
  external set height(num v);
  external num get xOffset;
  external set xOffset(num v);
  external num get yOffset;
  external set yOffset(num v);
  external num get xAdvance;
  external set xAdvance(num v);
  external List<num> get kerning;
  external set kerning(List<num> v);
  external BaseTexture get texture;
  external set texture(BaseTexture v);
  external factory BMFontChar(
      {num x,
      num y,
      num width,
      num height,
      num xOffset,
      num yOffset,
      num xAdvance,
      List<num> kerning,
      BaseTexture texture});
}

/// A BitmapData object contains a Canvas element to which you can draw anything you like via normal Canvas context operations.
/// A single BitmapData can be used as the texture for one or many Images / Sprites.
/// So if you need to dynamically create a Sprite texture then they are a good choice.
/// Important note: Every BitmapData creates its own Canvas element. Because BitmapData's are now Game Objects themselves, and don't
/// live on the display list, they are NOT automatically cleared when you change State. Therefore you _must_ call BitmapData.destroy
/// in your State's shutdown method if you wish to free-up the resources the BitmapData used, it will not happen for you.
@JS("Phaser.BitmapData")
class BitmapData {
  // @Ignore
  BitmapData.fakeConstructor$();

  /// A BitmapData object contains a Canvas element to which you can draw anything you like via normal Canvas context operations.
  /// A single BitmapData can be used as the texture for one or many Images / Sprites.
  /// So if you need to dynamically create a Sprite texture then they are a good choice.
  /// Important note: Every BitmapData creates its own Canvas element. Because BitmapData's are now Game Objects themselves, and don't
  /// live on the display list, they are NOT automatically cleared when you change State. Therefore you _must_ call BitmapData.destroy
  /// in your State's shutdown method if you wish to free-up the resources the BitmapData used, it will not happen for you.
  external factory BitmapData(Game game, String key,
      [num width, num height, bool skipPool]);

  /// The PIXI.BaseTexture.
  external BaseTexture get baseTexture;
  external set baseTexture(BaseTexture v);
  external ByteBuffer get buffer;
  external set buffer(ByteBuffer v);

  /// The canvas to which this BitmapData draws.
  external CanvasElement get canvas;
  external set canvas(CanvasElement v);

  /// The 2d context of the canvas.
  external CanvasRenderingContext2D get context;
  external set context(CanvasRenderingContext2D v);

  /// A reference to BitmapData.context.
  external CanvasRenderingContext2D get ctx;
  external set ctx(CanvasRenderingContext2D v);

  /// A Uint8ClampedArray view into BitmapData.buffer.
  /// Note that this is unavailable in some browsers (such as Epic Browser due to its security restrictions)
  external Uint8List get data;
  external set data(Uint8List v);

  /// If dirty this BitmapData will be re-rendered.
  external bool get dirty;
  external set dirty(bool v);

  /// If disableTextureUpload is true this BitmapData will never send its image data to the GPU when its dirty flag is true.
  external bool get disableTextureUpload;
  external set disableTextureUpload(bool v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// The height of the BitmapData in pixels.
  external num get height;
  external set height(num v);

  /// The context image data.
  /// Please note that a call to BitmapData.draw() or BitmapData.copy() does not update immediately this property for performance reason. Use BitmapData.update() to do so.
  /// This property is updated automatically after the first game loop, according to the dirty flag property.
  external ImageData get imageData;
  external set imageData(ImageData v);

  /// The key of the BitmapData in the Cache, if stored there.
  external String get key;
  external set key(String v);
  external String get op;
  external set op(String v);

  /// An Uint32Array view into BitmapData.buffer.
  external Uint32List get pixels;
  external set pixels(Uint32List v);
  external bool get smoothed;
  external set smoothed(bool v);

  /// The context property needed for smoothing this Canvas.
  external String get smoothProperty;
  external set smoothProperty(String v);

  /// The PIXI.Texture.
  external Texture get texture;
  external set texture(Texture v);

  /// The Frame this BitmapData uses for rendering.
  external Frame get textureFrame;
  external set textureFrame(Frame v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// The width of the BitmapData in pixels.
  external num get width;
  external set width(num v);

  /// Gets a JavaScript object that has 6 properties set that are used by BitmapData in a transform.
  /*external static dynamic getTransform(num translateX, num translateY, num scaleX, num scaleY, num skewX, num skewY);*/
  /// Gets a JavaScript object that has 6 properties set that are used by BitmapData in a transform.
  /*external dynamic getTransform(num translateX, num translateY, num scaleX,
    num scaleY, num skewX, num skewY);*/
  external dynamic getTransform(num translateX, num translateY, num scaleX,
      num scaleY, num skewX, num skewY);
  external BitmapData add(dynamic object);
  external Image addToWorld(
      [num x, num y, num anchorX, num anchorY, num scaleX, num scaleY]);
  external BitmapData alphaMask(dynamic source,
      [dynamic mask, Rectangle sourceRect, Rectangle maskRect]);
  external BitmapData blendAdd();
  external BitmapData blendColor();
  external BitmapData blendColorBurn();
  external BitmapData blendColorDodge();
  external BitmapData blendDarken();
  external BitmapData blendDestinationAtop();
  external BitmapData blendDestinationIn();
  external BitmapData blendDestinationOut();
  external BitmapData blendDestinationOver();
  external BitmapData blendDifference();
  external BitmapData blendExclusion();
  external BitmapData blendHardLight();
  external BitmapData blendHue();
  external BitmapData blendLighten();
  external BitmapData blendLuminosity();
  external BitmapData blendMultiply();
  external BitmapData blendOverlay();
  external BitmapData blendReset();
  external BitmapData blendSaturation();
  external BitmapData blendScreen();
  external BitmapData blendSoftLight();
  external BitmapData blendSourceAtop();
  external BitmapData blendSourceIn();
  external BitmapData blendSourceOut();
  external BitmapData blendSourceOver();
  external BitmapData blendXor();
  external BitmapData circle(num x, num y, num radius, [String fillStyle]);
  external BitmapData clear([num x, num y, num width, num height]);
  external BitmapData cls();
  external BitmapData copy(
      [dynamic source,
      num x,
      num y,
      num width,
      num height,
      num tx,
      num ty,
      num newWidth,
      num newHeight,
      num rotate,
      num anchorX,
      num anchorY,
      num scaleX,
      num scaleY,
      num alpha,
      String blendMode,
      bool roundPx]);
  external void copyPixels(dynamic source, Rectangle area, num x, num y,
      [num alpha]);
  external BitmapData copyRect(dynamic source, Rectangle area,
      [num x, num y, num alpha, String blendMode, bool roundPx]);
  external BitmapData copyTransform(dynamic source,
      [String blendMode, bool roundPx]);
  external void destroy();
  external BitmapData draw(dynamic source,
      [num x, num y, num width, num height, String blendMode, bool roundPx]);
  external BitmapData drawFull(dynamic parent,
      [String blendMode, bool roundPx]);
  external BitmapData drawGroup(Group group, [String blendMode, bool roundPx]);
  external BitmapData extract(BitmapData destination, num r, num g, num b,
      [num a, bool resize, num r2, num g2, num b2]);
  external BitmapData fill(num r, num g, num b, [num a]);
  external Texture generateTexture(String key,
      [void callback(Texture texture), dynamic callbackContext]);
  external Rectangle getBounds([Rectangle rect]);
  external dynamic /*{ r: number; g: number; b: number; x: number; y: number; }*/ getFirstPixel(
      num direction);
  external dynamic getPixel(num x, num y, [dynamic out]);
  external dynamic getPixelRGB(num x, num y, [dynamic out, bool hsl, bool hsv]);
  external num getPixel32(num x, num y);
  external ImageData getPixels(Rectangle rect);

  /// Draws a line between the coordinates given in the color and thickness specified.
  external BitmapData line(num x1, num y1, num x2, num y2,
      [String color, num width]);

  /// Takes the given Game Object, resizes this BitmapData to match it and then draws it into this BitmapDatas canvas, ready for further processing.
  /// The source game object is not modified by this operation.
  /// If the source object uses a texture as part of a Texture Atlas or Sprite Sheet, only the current frame will be used for sizing.
  /// If a string is given it will assume it's a cache key and look in Phaser.Cache for an image key matching the string.
  external BitmapData load(dynamic source);

  /// Shifts the contents of this BitmapData by the distances given.
  /// The image will wrap-around the edges on all sides if the wrap argument is true (the default).
  external BitmapData move(num x, num y, [bool wrap]);

  /// Shifts the contents of this BitmapData horizontally.
  /// The image will wrap-around the sides if the wrap argument is true (the default).
  external BitmapData moveH(num distance, [bool wrap]);

  /// Shifts the contents of this BitmapData vertically.
  /// The image will wrap-around the sides if the wrap argument is true (the default).
  external BitmapData moveV(num distance, [bool wrap]);

  /// Draws a polygon.
  external BitmapData polygon(List<dynamic> points,
      [dynamic /*String|CanvasGradient|CanvasPattern*/ fillStyle,
      num lineWidth,
      dynamic /*String|CanvasGradient|CanvasPattern*/ strokeStyle]);

  /// Scans through the area specified in this BitmapData and sends the color for every pixel to the given callback along with its x and y coordinates.
  /// Whatever value the callback returns is set as the new color for that pixel, unless it returns the same color, in which case it's skipped.
  /// Note that the format of the color received will be different depending on if the system is big or little endian.
  /// It is expected that your callback will deal with endianess. If you'd rather Phaser did it then use processPixelRGB instead.
  /// The callback will also be sent the pixels x and y coordinates respectively.
  external BitmapData processPixel(
      void callback(num color, num x, num y), dynamic callbackContext,
      [num x, num y, num width, num height]);

  /// Scans through the area specified in this BitmapData and sends a color object for every pixel to the given callback.
  /// The callback will be sent a color object with 6 properties: `{ r: number, g: number, b: number, a: number, color: number, rgba: string }`.
  /// Where r, g, b and a are integers between 0 and 255 representing the color component values for red, green, blue and alpha.
  /// The `color` property is an Int32 of the full color. Note the endianess of this will change per system.
  /// The `rgba` property is a CSS style rgba() string which can be used with context.fillStyle calls, among others.
  /// The callback will also be sent the pixels x and y coordinates respectively.
  /// The callback must return either `false`, in which case no change will be made to the pixel, or a new color object.
  /// If a new color object is returned the pixel will be set to the r, g, b and a color values given within it.
  external BitmapData processPixelRGB(
      void callback(ColorComponents color, num x, num y),
      dynamic callbackContext,
      [num x,
      num y,
      num width,
      num height]);

  /// Draws a filled Rectangle to the BitmapData at the given x, y coordinates and width / height in size.
  external BitmapData rect(num x, num y, num width, num height,
      [String fillStyle]);

  /// If the game is running in WebGL this will push the texture up to the GPU if it's dirty.
  /// This is called automatically if the BitmapData is being used by a Sprite, otherwise you need to remember to call it in your render function.
  /// If you wish to suppress this functionality set BitmapData.disableTextureUpload to `true`.
  external BitmapData render();

  /// Replaces all pixels matching one color with another. The color values are given as two sets of RGBA values.
  /// An optional region parameter controls if the replacement happens in just a specific area of the BitmapData or the entire thing.
  external BitmapData replaceRGB(
      num r1, num g1, num b1, num a1, num r2, num g2, num b2, num a2,
      [Rectangle region]);

  /// Resizes the BitmapData. This changes the size of the underlying canvas and refreshes the buffer.
  external BitmapData resize(num width, num height);
  external void resizeFrame(dynamic parent, num width, num height);

  /// Sets the hue, saturation and lightness values on every pixel in the given region, or the whole BitmapData if no region was specified.
  external BitmapData setHSL([num h, num s, num l, Rectangle region]);

  /// Sets the color of the given pixel to the specified red, green and blue values.
  external BitmapData setPixel(num x, num y, num red, num green, num blue,
      [bool immediate]);

  /// Sets the color of the given pixel to the specified red, green, blue and alpha values.
  external BitmapData setPixel32(
      num x, num y, num red, num green, num blue, num alpha,
      [bool immediate]);

  /// Sets the shadow properties of this BitmapDatas context which will affect all draw operations made to it.
  /// You can cancel an existing shadow by calling this method and passing no parameters.
  /// Note: At the time of writing (October 2014) Chrome still doesn't support shadowBlur used with drawImage.
  external BitmapData shadow(String color, [num blur, num x, num y]);

  /// Shifts any or all of the hue, saturation and lightness values on every pixel in the given region, or the whole BitmapData if no region was specified.
  /// Shifting will add the given value onto the current h, s and l values, not replace them.
  /// The hue is wrapped to keep it within the range 0 to 1. Saturation and lightness are clamped to not exceed 1.
  external BitmapData shiftHSL([num h, num s, num l, Rectangle region]);

  /// Draws text to the BitmapData in the given font and color.
  /// The default font is 14px Courier, so useful for quickly drawing debug text.
  /// If you need to do a lot of font work to this BitmapData we'd recommend implementing your own text draw method.
  external BitmapData text(String text,
      [num x, num y, String font, String color, bool shadow]);

  /// Takes the given Line object and image and renders it to this BitmapData as a repeating texture line.
  external BitmapData textureLine(Line line, String key, [String repeat]);

  /// This re-creates the BitmapData.imageData from the current context.
  /// It then re-builds the ArrayBuffer, the data Uint8ClampedArray reference and the pixels Int32Array.
  /// If not given the dimensions defaults to the full size of the context.
  /// Warning: This is a very expensive operation, so use it sparingly.
  external BitmapData update([num x, num y, num width, num height]);

  /// Updates a portion of the BitmapData from a source Bitmap.
  /// This optimization is important if calling update() on a large Bitmap is causing performance issues.
  /// Make sure you use getPixel32() instead of getPixel().
  /// This does not work with floating point numbers for x and y.
  external BitmapData copyBitmapData(BitmapData source, num x, num y);
}

/// BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.
/// It then generates a new Sprite object for each letter of the text, proportionally spaced out and aligned to
/// match the font structure.
/// BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
/// to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by
/// processing the font texture in an image editor, applying fills and any other effects required.
/// To create multi-line text insert \r, \n or \r\n escape codes into the text string.
/// If you are having performance issues due to the volume of sprites being rendered, and do not require the text to be constantly
/// updating, you can use BitmapText.generateTexture to create a static texture from this BitmapText.
/// To create a BitmapText data files you can use:
/// BMFont (Windows, free): http://www.angelcode.com/products/bmfont/
/// Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner
/// Littera (Web-based, free): http://kvazars.com/littera/
/// For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of
/// converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson
/// If you were using an older version of Phaser (< 2.4) and using the DOMish parser hack, please remove this. It isn't required any longer.
@JS("Phaser.BitmapText")
class BitmapText extends DisplayObjectContainer {
  // @Ignore
  BitmapText.fakeConstructor$() : super.fakeConstructor$();

  /// BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.
  /// It then generates a new Sprite object for each letter of the text, proportionally spaced out and aligned to
  /// match the font structure.
  /// BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
  /// to use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by
  /// processing the font texture in an image editor, applying fills and any other effects required.
  /// To create multi-line text insert \r, \n or \r\n escape codes into the text string.
  /// If you are having performance issues due to the volume of sprites being rendered, and do not require the text to be constantly
  /// updating, you can use BitmapText.generateTexture to create a static texture from this BitmapText.
  /// To create a BitmapText data files you can use:
  /// BMFont (Windows, free): http://www.angelcode.com/products/bmfont/
  /// Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner
  /// Littera (Web-based, free): http://kvazars.com/littera/
  /// For most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of
  /// converting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: http://codebeautify.org/xmltojson
  /// If you were using an older version of Phaser (< 2.4) and using the DOMish parser hack, please remove this. It isn't required any longer.
  external factory BitmapText(Game game, num x, num y, String font,
      [String text, num size, String align]);

  /// Alignment for multi-line text ('left', 'center' or 'right'), does not affect single lines of text.
  external String get align;
  external set align(String v);

  /// A useful flag to control if the Game Object is alive or dead.
  /// This is set automatically by the Health components `damage` method should the object run out of health.
  /// Or you can toggle it via your game code.
  /// This property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.
  /// However you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.
  /// Default: true
  external bool get alive;
  external set alive(bool v);

  /// The anchor value of this BitmapText.
  external PhaserPoint get anchor;
  external set anchor(Point v);

  /// If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.
  /// Through it you can create, play, pause and stop animations.
  external AnimationManager get animations;
  external set animations(AnimationManager v);

  /// The angle property is the rotation of the Game Object in *degrees* from its original orientation.
  /// Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.
  /// Values outside this range are added to or subtracted from 360 to obtain a value within the range.
  /// For example, the statement player.angle = 450 is the same as player.angle = 90.
  /// If you wish to work in radians instead of degrees you can use the property `rotation` instead.
  /// Working in radians is slightly faster as it doesn't have to perform any calculations.
  external num get angle;
  external set angle(num v);

  /// A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.
  /// If it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.
  /// This keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.
  /// This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,
  /// or you have tested performance and find it acceptable.
  external bool get autoCull;
  external set autoCull(bool v);

  /// `body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated
  /// properties and methods via it.
  /// By default Game Objects won't add themselves to any physics system and their `body` property will be `null`.
  /// To enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object
  /// and `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.
  /// You can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.
  /// Important: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5,
  /// so the physics body is centered on the Game Object.
  /// If you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.
  external dynamic /*Body|P2_Body|Ninja_Body|dynamic*/ get body;
  external set body(dynamic /*Body|P2_Body|Ninja_Body|dynamic*/ v);

  /// The sum of the y and height properties.
  /// This is the same as `y + height - offsetY`.
  external num get bottom;
  external set bottom(num v);

  /// The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.
  /// The values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.
  external PhaserPoint get cameraOffset;
  external set cameraOffset(Point v);

  /// If this is set to `true` the Game Object checks if it is within the World bounds each frame.
  /// When it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.
  /// If it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.
  /// It also optionally kills the Game Object if `outOfBoundsKill` is `true`.
  /// When `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.
  /// This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,
  /// or you have tested performance and find it acceptable.
  external bool get checkWorldBounds;
  external set checkWorldBounds(bool v);

  /// An empty Object that belongs to this Game Object.
  /// This value isn't ever used internally by Phaser, but may be used by your own code, or
  /// by Phaser Plugins, to store data that needs to be associated with the Game Object,
  /// without polluting the Game Object directly.
  /// Default: {}
  external dynamic get data;
  external set data(dynamic v);

  /// As a Game Object runs through its destroy method this flag is set to true,
  /// and can be checked in any sub-systems or plugins it is being destroyed from.
  external bool get destroyPhase;
  external set destroyPhase(bool v);

  /// A debug flag designed for use with `Game.enableStep`.
  external bool get debug;
  external set debug(bool v);

  /// The dirty state of this object.
  external bool get dirty;
  external set dirty(bool v);

  /// All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this
  /// Game Object, or any of its components.
  external Events get events;
  external set events(Events v);

  /// Controls if this Game Object is processed by the core game loop.
  /// If this Game Object has a physics body it also controls if its physics body is updated or not.
  /// When `exists` is set to `false` it will remove its physics body from the physics world if it has one.
  /// It also toggles the `visible` property to false as well.
  /// Setting `exists` to true will add its physics body back in to the physics world, if it has one.
  /// It will also set the `visible` property to `true`.
  external bool get exists;
  external set exists(bool v);

  /// A Game Object that is "fixed" to the camera is rendered at a given x/y offsets from the top left of the camera. The offsets
  /// are stored in the `cameraOffset` property, which is initialized with the current object coordinates.
  /// The values are adjusted at the rendering stage, overriding the Game Objects actual world position.
  /// The end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world
  /// the camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times
  /// regardless where in the world the camera is.
  /// Note that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.
  /// Be careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.
  external bool get fixedToCamera;
  external set fixedToCamera(bool v);

  /// The font the text will be rendered in, i.e. 'Arial'. Must be loaded in the browser before use.
  external String get font;
  external set font(String v);

  /// The size of the font in pixels.
  external num get fontSize;
  external set fontSize(num v);

  /// A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.
  /// This property is mostly used internally by the physics systems, but is exposed for the use of plugins.
  external bool get fresh;
  external set fresh(bool v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// The Input Handler for this Game Object.
  /// By default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.
  /// After you have done this, this property will be a reference to the Phaser InputHandler.
  external InputHandler get input;
  external set input(InputHandler v);

  /// By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created
  /// for this Game Object and it will then start to process click / touch events and more.
  /// You can then access the Input Handler via `this.input`.
  /// Note that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.
  /// If you set this property to false it will stop the Input Handler from processing any more input events.
  /// If you want to _temporarily_ disable input for a Game Object, then it's better to set
  /// `input.enabled = false`, as it won't reset any of the Input Handlers internal properties.
  /// You can then toggle this back on as needed.
  external bool get inputEnabled;
  external set inputEnabled(bool v);

  /// Checks if the Game Objects bounds intersect with the Game Camera bounds.
  /// Returns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.
  external bool get inCamera;
  external set inCamera(bool v);

  /// Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.
  external bool get inWorld;
  external set inWorld(bool v);

  /// The key of the image or texture used by this Game Object during rendering.
  /// If it is a string it's the string used to retrieve the texture from the Phaser Image Cache.
  /// It can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
  /// If a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.
  /// If a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.
  external dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ get key;
  external set key(dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ v);

  /// The left coordinate of the Game Object.
  /// This is the same as `x - offsetX`.
  external num get left;
  external set left(num v);

  /// A user defined name given to this Game Object.
  /// This value isn't ever used internally by Phaser, it is meant as a game level property.
  external String get name;
  external set name(String v);

  /// The components this Game Object has installed.
  external dynamic get components;
  external set components(dynamic v);

  /// The lifespan allows you to give a Game Object a lifespan in milliseconds.
  /// Once the Game Object is 'born' you can set this to a positive value.
  /// It is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.
  /// When it reaches zero it will call the `kill` method.
  /// Very handy for particles, bullets, collectibles, or any other short-lived entity.
  external num get lifespan;
  external set lifespan(num v);

  /// The maximum display width of this BitmapText in pixels.
  /// If BitmapText.text is longer than maxWidth then the lines will be automatically wrapped
  /// based on the last whitespace character found in the line.
  /// If no whitespace was found then no wrapping will take place and consequently the maxWidth value will not be honored.
  /// Disable maxWidth by setting the value to 0. The maximum width of this BitmapText in pixels.
  external num get maxWidth;
  external set maxWidth(num v);

  /// The amount the Game Object is visually offset from its x coordinate.
  /// This is the same as `width * anchor.x`.
  /// It will only be > 0 if anchor.x is not equal to zero.
  external num get offsetX;
  external set offsetX(num v);

  /// The amount the Game Object is visually offset from its y coordinate.
  /// This is the same as `height * anchor.y`.
  /// It will only be > 0 if anchor.y is not equal to zero.
  external num get offsetY;
  external set offsetY(num v);

  /// If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.
  external bool get outOfBoundsKill;
  external set outOfBoundsKill(bool v);

  /// A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.
  /// You can set it directly to allow you to flag an object to be destroyed on its next update.
  /// This is extremely useful if you wish to destroy an object from within one of its own callbacks
  /// such as with Buttons or other Input events.
  external bool get pendingDestroy;
  external set pendingDestroy(bool v);

  /// The const physics body type of this object.
  external num get physicsType;
  external set physicsType(num v);

  /// The position the Game Object was located in the previous frame.
  external PhaserPoint get previousPosition;
  external set previousPosition(Point v);

  /// The rotation the Game Object was in set to in the previous frame. Value is in radians.
  external num get previousRotation;
  external set previousRotation(num v);

  /// The coordinates, in pixels, of this DisplayObject, relative to its parent container.
  /// The value of this property does not reflect any positioning happening further up the display list.
  /// To obtain that value please see the `worldPosition` property.
  external PhaserPoint get position;
  external set position(Point v);

  /// The render order ID is used internally by the renderer and Input Manager and should not be modified.
  /// This property is mostly used internally by the renderers, but is exposed for the use of plugins.
  external num get renderOrderID;
  external set renderOrderID(num v);

  /// The right coordinate of the Game Object.
  /// This is the same as `x + width - offsetX`.
  external num get right;
  external set right(num v);

  /// The text to be displayed by this BitmapText object.
  external String get text;
  external set text(String v);

  /// Enable or disable texture smoothing for this BitmapText.
  /// The smoothing is applied to the BaseTexture of this font, which all letters of the text reference.
  /// Smoothing is enabled by default.
  external bool get smoothed;
  external set smoothed(bool v);

  /// The width in pixels of the overall text area, taking into consideration multi-line text.
  external num get textWidth;
  external set textWidth(num v);

  /// The height in pixels of the overall text area, taking into consideration multi-line text.
  external num get textHeight;
  external set textHeight(num v);

  /// The tint applied to the BitmapText. This is a hex value. Set to white to disable (0xFFFFFF)
  external num get tint;
  external set tint(num v);

  /// The y coordinate of the Game Object.
  /// This is the same as `y - offsetY`.
  external num get top;
  external set top(num v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// The world coordinates of this Game Object in pixels.
  /// Depending on where in the display list this Game Object is placed this value can differ from `position`,
  /// which contains the x/y coordinates relative to the Game Objects parent.
  external PhaserPoint get world;
  external set world(Point v);

  /// The horizontal position of the DisplayObject, in pixels, relative to its parent.
  /// If you need the world position of the DisplayObject, use `DisplayObject.worldPosition` instead.
  external num get x;
  external set x(num v);

  /// The vertical position of the DisplayObject, in pixels, relative to its parent.
  /// If you need the world position of the DisplayObject, use `DisplayObject.worldPosition` instead.
  external num get y;
  external set y(num v);

  /// The z depth of this Game Object within its parent Group.
  /// No two objects in a Group can have the same z value.
  /// This value is adjusted automatically whenever the Group hierarchy changes.
  /// If you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.
  external num get z;
  external set z(num v);

  /// Aligns this Game Object within another Game Object, or Rectangle, known as the
  /// 'container', to one of 9 possible positions.
  /// The container must be a Game Object, or Phaser.Rectangle object. This can include properties
  /// such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world
  /// and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,
  /// TileSprites or Buttons.
  /// Please note that aligning a Sprite to another Game Object does **not** make it a child of
  /// the container. It simply modifies its position coordinates so it aligns with it.
  /// The position constants you can use are:
  /// `Phaser.TOP_LEFT`, `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`,
  /// `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`,
  /// `Phaser.BOTTOM_CENTER` and `Phaser.BOTTOM_RIGHT`.
  /// The Game Objects are placed in such a way that their _bounds_ align with the
  /// container, taking into consideration rotation, scale and the anchor property.
  /// This allows you to neatly align Game Objects, irrespective of their position value.
  /// The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final
  /// aligned position of the Game Object. For example:
  /// `sprite.alignIn(background, Phaser.BOTTOM_RIGHT, -20, -20)`
  /// Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.
  /// Think of the offsets as applying an adjustment to the containers bounds before the alignment takes place.
  /// So providing a negative offset will 'shrink' the container bounds by that amount, and providing a positive
  /// one expands it.
  external dynamic alignIn(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// Aligns this Game Object to the side of another Game Object, or Rectangle, known as the
  /// 'parent', in one of 11 possible positions.
  /// The parent must be a Game Object, or Phaser.Rectangle object. This can include properties
  /// such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world
  /// and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,
  /// TileSprites or Buttons.
  /// Please note that aligning a Sprite to another Game Object does **not** make it a child of
  /// the parent. It simply modifies its position coordinates so it aligns with it.
  /// The position constants you can use are:
  /// `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_TOP`,
  /// `Phaser.LEFT_CENTER`, `Phaser.LEFT_BOTTOM`, `Phaser.RIGHT_TOP`, `Phaser.RIGHT_CENTER`,
  /// `Phaser.RIGHT_BOTTOM`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER`
  /// and `Phaser.BOTTOM_RIGHT`.
  /// The Game Objects are placed in such a way that their _bounds_ align with the
  /// parent, taking into consideration rotation, scale and the anchor property.
  /// This allows you to neatly align Game Objects, irrespective of their position value.
  /// The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final
  /// aligned position of the Game Object. For example:
  /// `sprite.alignTo(background, Phaser.BOTTOM_RIGHT, -20, -20)`
  /// Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.
  /// Think of the offsets as applying an adjustment to the parents bounds before the alignment takes place.
  /// So providing a negative offset will 'shrink' the parent bounds by that amount, and providing a positive
  /// one expands it.
  external dynamic alignTo(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// Destroy this DisplayObject.
  /// Removes any cached sprites, sets renderable flag to false, and nulls filters, bounds and mask.
  /// Also iteratively calls `destroy` on any children.
  external void destroy([bool destroyChildren]);

  /// Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.
  /// It will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.
  /// Note that killing a Game Object is a way for you to quickly recycle it in an object pool,
  /// it doesn't destroy the object or free it up from memory.
  /// If you don't need this Game Object any more you should call `destroy` instead.
  external void kill();

  /// Automatically called by World.preUpdate.
  external void postUpdate();

  /// Automatically called by World.preUpdate.
  external void preUpdate();

  /// If a BitmapText changes from having a large number of characters to having very few characters it will cause lots of
  /// Sprites to be retained in the BitmapText._glyphs array. Although they are not attached to the display list they
  /// still take up memory while sat in the glyphs pool waiting to be re-used in the future.
  /// If you know that the BitmapText will not grow any larger then you can purge out the excess glyphs from the pool
  /// by calling this method.
  /// Calling this doesn't prevent you from increasing the length of the text again in the future.
  external num purgeGlyphs();

  /// Resets the Game Object.
  /// This moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`,
  /// `visible` and `renderable` to true.
  /// If this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.
  /// If this Game Object has a Physics Body it will reset the Body.
  external BitmapText reset(num x, num y, [num health]);

  /// Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.
  /// A resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.
  /// It will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.
  external BitmapText revive([num health]);

  /// Given the input text this will scan the characters until either a newline is encountered,
  /// or the line exceeds maxWidth, taking into account kerning, character widths and scaling.
  /// The text to be displayed by this BitmapText object.
  external dynamic /*{ width: number; text: string; end: boolean; chars: string[] }*/ scanLine(
      dynamic data, num scale, String text);

  /// The text to be displayed by this BitmapText object.
  /// It's faster to use `BitmapText.text = string`, but this is kept for backwards compatibility.
  external void setText(String text);

  /// Override this method in your own custom objects to handle any update requirements.
  /// It is called immediately after `preUpdate` and before `postUpdate`.
  /// Remember if this Game Object has any children you should call update on those too.
  external void update();

  /// Renders text and updates it when needed.
  external void updateText();

  /// Updates the transform of this object.
  external void updateTransform([container]);
}

/// Create a new `Bullet` object. Bullets are used by the `Phaser.Weapon` class, and are normal Sprites,
/// with a few extra properties in the data object to handle Weapon specific features.
@JS("Phaser.Bullet")
class Bullet extends Sprite {
  // @Ignore
  Bullet.fakeConstructor$() : super.fakeConstructor$();

  /// Create a new `Bullet` object. Bullets are used by the `Phaser.Weapon` class, and are normal Sprites,
  /// with a few extra properties in the data object to handle Weapon specific features.
  external factory Bullet(Game game, num x, num y,
      [dynamic key, dynamic frame]);

  /// Kills the Bullet, freeing it up for re-use by the Weapon bullet pool.
  /// Also dispatches the `Weapon.onKill` signal.
  external Bullet kill();

  /// Updates the Bullet, killing as required.
  external void update();
}

/// Create a new `Button` object. A Button is a special type of Sprite that is set-up to handle Pointer events automatically.
/// The four states a Button responds to are:
/// * 'Over' - when the Pointer moves over the Button. This is also commonly known as 'hover'.
/// * 'Out' - when the Pointer that was previously over the Button moves out of it.
/// * 'Down' - when the Pointer is pressed down on the Button. I.e. touched on a touch enabled device or clicked with the mouse.
/// * 'Up' - when the Pointer that was pressed down on the Button is released again.
/// A different texture/frame and activation sound can be specified for any of the states.
/// Frames can be specified as either an integer (the frame ID) or a string (the frame name); the same values that can be used with a Sprite constructor.
@JS("Phaser.Button")
class Button extends Image {
  // @Ignore
  Button.fakeConstructor$() : super.fakeConstructor$();

  /// Create a new `Button` object. A Button is a special type of Sprite that is set-up to handle Pointer events automatically.
  /// The four states a Button responds to are:
  /// * 'Over' - when the Pointer moves over the Button. This is also commonly known as 'hover'.
  /// * 'Out' - when the Pointer that was previously over the Button moves out of it.
  /// * 'Down' - when the Pointer is pressed down on the Button. I.e. touched on a touch enabled device or clicked with the mouse.
  /// * 'Up' - when the Pointer that was pressed down on the Button is released again.
  /// A different texture/frame and activation sound can be specified for any of the states.
  /// Frames can be specified as either an integer (the frame ID) or a string (the frame name); the same values that can be used with a Sprite constructor.
  external factory Button(Game game,
      [num x,
      num y,
      String key,
      Function callback,
      dynamic callbackContext,
      dynamic /*String|num*/ overFrame,
      dynamic /*String|num*/ outFrame,
      dynamic /*String|num*/ downFrame,
      dynamic /*String|num*/ upFrame]);

  /// When the Button is touched / clicked and then released you can force it to enter a state of "out" instead of "up".
  /// This can also accept a [Phaser.PointerModer pointer mode bitmask] for more refined control.
  external bool get forceOut;
  external set forceOut(bool v);

  /// When true the the texture frame will not be automatically switched on up/down/over/out events.
  external bool get freezeFrames;
  external set freezeFrames(bool v);

  /// The Sound to be played when this Buttons Down state is activated.
  external dynamic /*Sound|AudioSprite*/ get onDownSound;
  external set onDownSound(dynamic /*Sound|AudioSprite*/ v);

  /// The Sound Marker used in conjunction with the onDownSound.
  external String get onDownSoundMarker;
  external set onDownSoundMarker(String v);

  /// The Signal (or event) dispatched when this Button is in an Down state.
  external Signal get onInputDown;
  external set onInputDown(Signal v);

  /// The Signal (or event) dispatched when this Button is in an Out state.
  external Signal get onInputOut;
  external set onInputOut(Signal v);

  /// The Signal (or event) dispatched when this Button is in an Over state.
  external Signal get onInputOver;
  external set onInputOver(Signal v);

  /// The Signal (or event) dispatched when this Button is in an Up state.
  external Signal get onInputUp;
  external set onInputUp(Signal v);

  /// The Sound to be played when this Buttons Out state is activated.
  external dynamic /*Sound|AudioSprite*/ get onOutSound;
  external set onOutSound(dynamic /*Sound|AudioSprite*/ v);

  /// The Sound Marker used in conjunction with the onOutSound.
  external String get onOutSoundMarker;
  external set onOutSoundMarker(String v);

  /// The Sound to be played when this Buttons Over state is activated.
  external dynamic /*Sound|AudioSprite*/ get onOverSound;
  external set onOverSound(dynamic /*Sound|AudioSprite*/ v);

  /// The Sound Marker used in conjunction with the onOverSound.
  external String get onOverSoundMarker;
  external set onOverSoundMarker(String v);

  /// If true then onOver events (such as onOverSound) will only be triggered if the Pointer object causing them was the Mouse Pointer.
  /// The frame will still be changed as applicable.
  /// Default: true
  external bool get onOverMouseOnly;
  external set onOverMouseOnly(bool v);

  /// The Sound to be played when this Buttons Up state is activated.
  external dynamic /*Sound|AudioSprite*/ get onUpSound;
  external set onUpSound(dynamic /*Sound|AudioSprite*/ v);
  external String get onUpSoundMaker;
  external set onUpSoundMaker(String v);

  /// The const physics body type of this object.
  external num get physicsType;
  external set physicsType(num v);

  /// The Phaser Object Type.
  external num get type;
  external set type(num v);

  /// Clears all of the frames set on this Button.
  external void clearFrames();

  /// The Sound to be played when a Pointer presses down on this Button.
  external void setDownSound(dynamic /*Sound|AudioSprite*/ sound,
      [String marker]);

  /// Used to manually set the frames that will be used for the different states of the Button.
  /// Frames can be specified as either an integer (the frame ID) or a string (the frame name); these are the same values that can be used with a Sprite constructor.
  external void setFrames(
      [dynamic /*String|num*/ overFrame,
      dynamic /*String|num*/ outFrame,
      dynamic /*String|num*/ downFrame,
      dynamic /*String|num*/ upFrame]);

  /// Internal function that handles input events.
  external void onInputOverHandler(Button sprite, Pointer pointer);

  /// Internal function that handles input events.
  external void onInputOutHandler(Button sprite, Pointer pointer);

  /// Internal function that handles input events.
  external void onInputDownHandler(Button sprite, Pointer pointer);

  /// Internal function that handles input events.
  external void onInputUpHandler(Button sprite, Pointer pointer, bool isOver);
  external void removedFromWorld();

  /// The Sound to be played when a Pointer moves out of this Button.
  external void setOutSound(dynamic /*Sound|AudioSprite*/ sound,
      [String marker]);

  /// The Sound to be played when a Pointer moves over this Button.
  external void setOverSound(dynamic /*Sound|AudioSprite*/ sound,
      [String marker]);

  /// Sets the sounds to be played whenever this Button is interacted with. Sounds can be either full Sound objects, or markers pointing to a section of a Sound object.
  /// The most common forms of sounds are 'hover' effects and 'click' effects, which is why the order of the parameters is overSound then downSound.
  /// Call this function with no parameters to reset all sounds on this Button.
  external void setSounds(
      [dynamic /*Sound|AudioSprite*/ overSound,
      String overMarker,
      dynamic /*Sound|AudioSprite*/ downSound,
      String downMarker,
      dynamic /*Sound|AudioSprite*/ outSound,
      String outMarker,
      dynamic /*Sound|AudioSprite*/ upSound,
      String upMarker]);
  external void setState(num newState);

  /// The Sound to be played when a Pointer has pressed down and is released from this Button.
  external void setUpSound(dynamic /*Sound|AudioSprite*/ sound,
      [String marker]);
}

/// Enumeration categorizing operational modes of pointers.
/// PointerType values represent valid bitmasks.
/// For example, a value representing both Mouse and Touch devices
/// can be expressed as `PointerMode.CURSOR | PointerMode.CONTACT`.
/// Values may be added for future mode categorizations.
@JS("Phaser.PointerMode")
class PointerMode {
  // @Ignore
  PointerMode.fakeConstructor$();

  /// A 'CURSOR' is a pointer with a *passive cursor* such as a mouse, touchpad, watcom stylus, or even TV-control arrow-pad.
  /// It has the property that a cursor is passively moved without activating the input.
  /// This currently corresponds with [Phaser.Pointer#isMouse] property.
  external static num get CURSOR;
  external static set CURSOR(num v);

  /// A 'CONTACT' pointer has an *active cursor* that only tracks movement when actived; notably this is a touch-style input.
  external static num get CONTACT;
  external static set CONTACT(num v);
}

/// Phaser has one single cache in which it stores all assets.
/// The cache is split up into sections, such as images, sounds, video, json, etc. All assets are stored using
/// a unique string-based key as their identifier. Assets stored in different areas of the cache can have the
/// same key, for example 'playerWalking' could be used as the key for both a sprite sheet and an audio file,
/// because they are unique data types.
/// The cache is automatically populated by the Phaser.Loader. When you use the loader to pull in external assets
/// such as images they are automatically placed into their respective cache. Most common Game Objects, such as
/// Sprites and Videos automatically query the cache to extract the assets they need on instantiation.
/// You can access the cache from within a State via `this.cache`. From here you can call any public method it has,
/// including adding new entries to it, deleting them or querying them.
/// Understand that almost without exception when you get an item from the cache it will return a reference to the
/// item stored in the cache, not a copy of it. Therefore if you retrieve an item and then modify it, the original
/// object in the cache will also be updated, even if you don't put it back into the cache again.
/// By default when you change State the cache is _not_ cleared, although there is an option to clear it should
/// your game require it. In a typical game set-up the cache is populated once after the main game has loaded and
/// then used as an asset store.
@JS("Phaser.Cache")
class Cache {
  // @Ignore
  Cache.fakeConstructor$();

  /// Phaser has one single cache in which it stores all assets.
  /// The cache is split up into sections, such as images, sounds, video, json, etc. All assets are stored using
  /// a unique string-based key as their identifier. Assets stored in different areas of the cache can have the
  /// same key, for example 'playerWalking' could be used as the key for both a sprite sheet and an audio file,
  /// because they are unique data types.
  /// The cache is automatically populated by the Phaser.Loader. When you use the loader to pull in external assets
  /// such as images they are automatically placed into their respective cache. Most common Game Objects, such as
  /// Sprites and Videos automatically query the cache to extract the assets they need on instantiation.
  /// You can access the cache from within a State via `this.cache`. From here you can call any public method it has,
  /// including adding new entries to it, deleting them or querying them.
  /// Understand that almost without exception when you get an item from the cache it will return a reference to the
  /// item stored in the cache, not a copy of it. Therefore if you retrieve an item and then modify it, the original
  /// object in the cache will also be updated, even if you don't put it back into the cache again.
  /// By default when you change State the cache is _not_ cleared, although there is an option to clear it should
  /// your game require it. In a typical game set-up the cache is populated once after the main game has loaded and
  /// then used as an asset store.
  external factory Cache(Game game);
  external static num get BINARY;
  external static set BINARY(num v);
  external static num get BITMAPDATA;
  external static set BITMAPDATA(num v);
  external static num get BITMAPFONT;
  external static set BITMAPFONT(num v);
  external static num get CANVAS;
  external static set CANVAS(num v);
  external static num get IMAGE;
  external static set IMAGE(num v);
  external static num get JSON;
  external static set JSON(num v);
  external static num get PHYSICS;
  external static set PHYSICS(num v);

  /// The maximum amount of time (ms) to wait for the built-in DEFAULT and MISSING images to load.
  /// Default: 1000
  external static num get READY_TIMEOUT;
  external static set READY_TIMEOUT(num v);
  external static num get RENDER_TEXTURE;
  external static set RENDER_TEXTURE(num v);
  external static num get SHADER;
  external static set SHADER(num v);
  external static num get SOUND;
  external static set SOUND(num v);
  external static num get SPRITE_SHEET;
  external static set SPRITE_SHEET(num v);
  external static num get TEXT;
  external static set TEXT(num v);
  external static num get TEXTURE;
  external static set TEXTURE(num v);
  external static num get TEXTURE_ATLAS;
  external static set TEXTURE_ATLAS(num v);
  external static num get TILEMAP;
  external static set TILEMAP(num v);
  external static num get XML;
  external static set XML(num v);
  external static num get VIDEO;
  external static set VIDEO(num v);

  /// The default image used for a texture when no other is specified.
  external static Texture get DEFAULT;
  external static set DEFAULT(Texture v);

  /// The default image used for a texture when the source image is missing.
  external static Texture get MISSING;
  external static set MISSING(Texture v);

  /// Automatically resolve resource URLs to absolute paths for use with the Cache.getURL method.
  external bool get autoResolveURL;
  external set autoResolveURL(bool v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// Dispatched when the DEFAULT and MISSING images have loaded (or the [#READY_TIMEOUT load timeout] was exceeded).
  external Signal get onReady;
  external set onReady(Signal v);

  /// This event is dispatched when the sound system is unlocked via a touch event on cellular devices.
  external Signal get onSoundUnlock;
  external set onSoundUnlock(Signal v);

  /// Add a binary object in to the cache.
  external void addBinary(String key, dynamic binaryData);

  /// Add a BitmapData object to the cache.
  external BitmapData addBitmapData(String key, BitmapData bitmapData,
      [FrameData frameData]);

  /// Add a new Bitmap Font to the Cache.
  external void addBitmapFont(
      String key, String url, dynamic data, dynamic atlasData, String atlasType,
      [num xSpacing, num ySpacing]);

  /// Add a new Bitmap Font to the Cache, where the font texture is part of a Texture Atlas.
  /// The atlas must already exist in the cache, and be available based on the given `atlasKey`.
  /// The `atlasFrame` specifies the name of the frame within the atlas that the Bitmap Font is
  /// stored in.
  /// The `dataKey` is the key of the XML or JSON Bitmap Font Data, which must already be in
  /// the Cache.
  external void addBitmapFontFromAtlas(
      String key, String atlasKey, String atlasFrame, String dataKey,
      [String dataType, num xSpacing, num ySpacing]);

  /// Add a new canvas object in to the cache.
  external void addCanvas(String key, CanvasElement canvas,
      [CanvasRenderingContext2D context]);

  /// Adds a default image to be used in special cases such as WebGL Filters.
  /// It uses the special reserved key of `__default`.
  /// This method is called automatically when the Cache is created.
  /// This image is skipped when `Cache.destroy` is called due to its internal requirements.
  external void addDefaultImage();

  /// Adds an Image file into the Cache. The file must have already been loaded, typically via Phaser.Loader, but can also have been loaded into the DOM.
  /// If an image already exists in the cache with the same key then it is removed and destroyed, and the new image inserted in its place.
  /// If the image has not yet been fetched (successfully or not), a `console.warn` message will be displayed.
  external ImageElement addImage(String key, String url, dynamic data);

  /// Add a new json object into the cache.
  external void addJSON(String key, String urL, dynamic data);

  /// Adds an image to be used when a key is wrong / missing.
  /// It uses the special reserved key of `__missing`.
  /// This method is called automatically when the Cache is created.
  /// This image is skipped when `Cache.destroy` is called due to its internal requirements.
  external void addMissingImage();

  /// Add a new physics data object to the Cache.
  external void addPhysicsData(
      String key, String url, dynamic JSONData, num format);

  /// Add a new Phaser.RenderTexture in to the cache.
  external void addRenderTexture(String key, PhaserRenderTexture texture);

  /// Adds a Fragment Shader in to the Cache. The file must have already been loaded, typically via Phaser.Loader.
  external void addShader(String key, String url, dynamic data);

  /// Adds a Sound file into the Cache. The file must have already been loaded, typically via Phaser.Loader.
  external void addSound(
      String key, String url, dynamic data, bool webAudio, bool audioTag);

  /// Add a new sprite sheet in to the cache.
  external void addSpriteSheet(
      String key, String url, dynamic data, num frameWidth, num frameHeight,
      [num frameMax, num margin, num spacing, num skipFrames]);

  /// Add a new text data.
  external void addText(String key, String url, dynamic data);

  /// Add a new texture atlas to the Cache.
  external void addTextureAtlas(
      String key, String url, dynamic data, dynamic atlasData, num format);

  /// Add a new tilemap to the Cache.
  external void addTilemap(String key, String url, dynamic mapData, num format);

  /// Adds a Video file into the Cache. The file must have already been loaded, typically via Phaser.Loader.
  external void addVideo(String key, String url, dynamic data, [bool isBlob]);

  /// Add a new xml object into the cache.
  external void addXML(String key, String url, dynamic data);

  /// Checks if the given key exists in the Binary Cache.
  external bool checkBinaryKey(String key);

  /// Checks if the given key exists in the BitmapData Cache.
  external bool checkBitmapDataKey(String key);

  /// Checks if the given key exists in the BitmapFont Cache.
  external bool checkBitmapFontKey(String key);

  /// Checks if the given key exists in the Canvas Cache.
  external bool checkCanvasKey(String key);

  /// Checks if the given key exists in the Image Cache. Note that this also includes Texture Atlases, Sprite Sheets and Retro Fonts.
  external bool checkImageKey(String key);

  /// Checks if the given key exists in the JSON Cache.
  external bool checkJSONKey(String key);

  /// Checks if a key for the given cache object type exists.
  external bool checkKey(num cache, String key);

  /// Checks if the given key exists in the Physics Cache.
  external bool checkPhysicsKey(String key);

  /// Checks if the given key exists in the Render Texture Cache.
  external bool checkRenderTextureKey(String key);

  /// Checks if the given key exists in the Fragment Shader Cache.
  external bool checkShaderKey(String key);

  /// Checks if the given key exists in the Sound Cache.
  external bool checkSoundKey(String key);

  /// Checks if the given key exists in the Text Cache.
  external bool checkTextKey(String key);

  /// Checks if the given key exists in the Texture Cache.
  external bool checkTextureKey(String key);

  /// Checks if the given key exists in the Tilemap Cache.
  external bool checkTilemapKey(String key);

  /// Checks if the given URL has been loaded into the Cache.
  /// This method will only work if Cache.autoResolveURL was set to `true` before any preloading took place.
  /// The method will make a DOM src call to the URL given, so please be aware of this for certain file types, such as Sound files on Firefox
  /// which may cause double-load instances.
  external dynamic checkURL(String url);
  external dynamic checkUrl(String url);

  /// Checks if the given key exists in the XML Cache.
  external bool checkXMLKey(String key);

  /// Checks if the given key exists in the Video Cache.
  external bool checkVideoKey(String key);

  /// Empties out all of the GL Textures from Images stored in the cache.
  /// This is called automatically when the WebGL context is lost and then restored.
  external void clearGLTextures();

  /// Add a new decoded sound.
  external void decodedSound(String key, dynamic data);

  /// Clears the cache. Removes every local cache object reference.
  /// If an object in the cache has a `destroy` method it will be called;
  /// otherwise, `destroy` will be called on any of the object's `base`, `data`,
  /// `frameData`, or `texture` properties.
  external void destroy();

  /// Gets a PIXI.BaseTexture by key from the given Cache.
  external BaseTexture getBaseTexture(String key, [num cache]);

  /// Gets a binary object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external dynamic getBinary(String key);

  /// Gets a BitmapData object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external BitmapData getBitmapData(String key);

  /// Gets a Bitmap Font object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external BitmapFont getBitmapFont(String key);

  /// Gets a Canvas object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external CanvasElement getCanvas(String key);

  /// Get a single frame by key. You'd only do this to get the default Frame created for a non-atlas/spritesheet image.
  external Frame getFrame(String key, [num cache]);

  /// Get a single frame out of a frameData set by key.
  external Frame getFrameByIndex(String key, num index, [num cache]);

  /// Get a single frame out of a frameData set by key.
  external Frame getFrameByName(String key, String name, [num cache]);

  /// Get the total number of frames contained in the FrameData object specified by the given key.
  external num getFrameCount(String key, [num cache]);

  /// Gets a Phaser.FrameData object from the Image Cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external FrameData getFrameData(String key, [num cache]);

  /// Gets a Image object from the cache. This returns a DOM Image object, not a Phaser.Image object.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  /// Only the Image cache is searched, which covers images loaded via Loader.image, Sprite Sheets and Texture Atlases.
  /// If you need the image used by a bitmap font or similar then please use those respective 'get' methods.
  external ImageElement getImage(String key, [bool full]);

  /// Get an item from a cache based on the given key and property.
  /// This method is mostly used internally by other Cache methods such as `getImage` but is exposed
  /// publicly for your own use as well.
  external dynamic getItem(String key, num cache,
      [String method, String property]);

  /// Gets a JSON object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  /// You can either return the object by reference (the default), or return a clone
  /// of it by setting the `clone` argument to `true`.
  external dynamic getJSON(String key, [bool clone]);

  /// Gets all keys used in the requested Cache.
  external List<String> getKeys(num cache);

  /// Gets a Physics Data object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  /// You can get either the entire data set, a single object or a single fixture of an object from it.
  external List<dynamic> getPhysicsData(String key,
      [String object, String fixtureKey]);

  /// Gets a RenderTexture object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external CachedRenderTexture getRenderTexture(String key);

  /// Gets a fragment shader object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external String getShader(String key);

  /// Gets a Phaser.Sound object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external Sound getSound(String key);

  /// Gets a raw Sound data object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external dynamic getSoundData(String key);
  external bool getSpriteSheetKey(String key);

  /// Gets a Text object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external String getText(String key);
  external List<String> getTextKeys();
  external PhaserRenderTexture getTexture(String key);
  external bool getTextureAtlasKey(String key);

  /// Get a single texture frame by key.
  /// You'd only do this to get the default Frame created for a non-atlas / spritesheet image.
  external Frame getTextureFrame(String key);
  external dynamic getTilemap(String key);

  /// Gets a raw Tilemap data object from the cache. This will be in either CSV or JSON format.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external dynamic getTilemapData(String key);

  /// Get a cached object by the URL.
  /// This only returns a value if you set Cache.autoResolveURL to `true` *before* starting the preload of any assets.
  /// Be aware that every call to this function makes a DOM src query, so use carefully and double-check for implications in your target browsers/devices.
  external dynamic getURL(String url);

  /// Gets an XML object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external dynamic getXML(String key);

  /// Gets a Phaser.Video object from the cache.
  /// The object is looked-up based on the key given.
  /// Note: If the object cannot be found a `console.warn` message is displayed.
  external Video getVideo(String key);

  /// Check if the FrameData for the given key exists in the Image Cache.
  external bool hasFrameData(String key, [num cache]);

  /// Check if the given sound has finished decoding.
  external bool isSoundDecoded(String key);

  /// Check if the given sound is ready for playback.
  /// A sound is considered ready when it has finished decoding and the device is no longer touch locked.
  external bool isSoundReady(String key);
  external bool isSpriteSheet(String key);

  /// Reload a Sound file from the server.
  external void reloadSound(String key);

  /// Fires the onSoundUnlock event when the sound has completed reloading.
  external void reloadSoundComplete(String key);

  /// Removes a binary file from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeBinary(String key);

  /// Removes a bitmap data from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeBitmapData(String key);

  /// Removes a bitmap font from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeBitmapFont(String key);

  /// Removes a canvas from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeCanvas(String key);

  /// Removes an image from the cache.
  /// You can optionally elect to destroy it as well. This calls BaseTexture.destroy on it.
  /// Note that this only removes it from the Phaser Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeImage(String key, [bool destroyBaseTexture]);

  /// Removes a json object from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeJSON(String key);

  /// Removes a physics data file from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removePhysics(String key);

  /// Removes a Render Texture from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeRenderTexture(String key);

  /// Removes a shader from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeShader(String key);

  /// Removes a sound from the cache.
  /// If any `Phaser.Sound` objects use the audio file in the cache that you remove with this method, they will
  /// _automatically_ destroy themselves. If you wish to have full control over when Sounds are destroyed then
  /// you must finish your house-keeping and destroy them all yourself first, before calling this method.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeSound(String key);

  /// Removes a Sprite Sheet from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeSpriteSheet(String key);

  /// Removes a text file from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeText(String key);

  /// Removes a Texture Atlas from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeTextureAtlas(String key);

  /// Removes a tilemap from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeTilemap(String key);

  /// Removes a xml object from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeXML(String key);

  /// Removes a video from the cache.
  /// Note that this only removes it from the Phaser.Cache. If you still have references to the data elsewhere
  /// then it will persist in memory.
  external void removeVideo(String key);

  /// Replaces a set of frameData with a new Phaser.FrameData object.
  external void updateFrameData(String key, dynamic frameData, [num cache]);

  /// Updates the sound object in the cache.
  external void updateSound(String key, String property, Sound value);
}

@anonymous
@JS()
abstract class CachedRenderTexture {
  external Frame get frame;
  external set frame(Frame v);
  external PhaserRenderTexture get texture;
  external set texture(PhaserRenderTexture v);
  external factory CachedRenderTexture({Frame frame, PhaserRenderTexture texture});
}

/// A Camera is your view into the game world. It has a position and size and renders only those objects within its field of view.
/// The game automatically creates a single Stage sized camera on boot. Move the camera around the world with Phaser.Camera.x/y
@JS("Phaser.Camera")
class Camera {
  // @Ignore
  Camera.fakeConstructor$();

  /// A Camera is your view into the game world. It has a position and size and renders only those objects within its field of view.
  /// The game automatically creates a single Stage sized camera on boot. Move the camera around the world with Phaser.Camera.x/y
  external factory Camera(
      Game game, num id, num x, num y, num width, num height);

  /// A follow style that uses no deadzone.
  external static num get FOLLOW_LOCKON;
  external static set FOLLOW_LOCKON(num v);

  /// A follow style that uses a tall, narrow deadzone (0.33 x 0.125) with a center slightly above the view center.
  external static num get FOLLOW_PLATFORMER;
  external static set FOLLOW_PLATFORMER(num v);

  /// A follow style that uses a square deadzone (0.25 of the larger view edge).
  external static num get FOLLOW_TOPDOWN;
  external static set FOLLOW_TOPDOWN(num v);

  /// A follow style that uses a small square deadzone (0.125 of the larger view edge).
  external static num get FOLLOW_TOPDOWN_TIGHT;
  external static set FOLLOW_TOPDOWN_TIGHT(num v);
  external static num get SHAKE_BOTH;
  external static set SHAKE_BOTH(num v);
  external static num get SHAKE_HORIZONTAL;
  external static set SHAKE_HORIZONTAL(num v);
  external static num get SHAKE_VERTICAL;
  external static set SHAKE_VERTICAL(num v);
  external static num get ENABLE_FX;
  external static set ENABLE_FX(num v);

  /// Whether this camera is flush with the World Bounds or not.
  /// The Cameras x coordinate. This value is automatically clamped if it falls outside of the World bounds. Gets or sets the cameras x position.
  /// The Cameras y coordinate. This value is automatically clamped if it falls outside of the World bounds. Gets or sets the cameras y position.
  external dynamic /*{ x: boolean; y: boolean; }*/ get atLimit;
  external set atLimit(dynamic /*{ x: boolean; y: boolean; }*/ v);

  /// The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.
  /// The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound
  /// at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the top-left of the world. The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.
  external Rectangle get bounds;
  external set bounds(Rectangle v);

  /// Moving inside this Rectangle will not cause the camera to move.
  external Rectangle get deadzone;
  external set deadzone(Rectangle v);

  /// The display object to which all game objects are added. Set by World.boot.
  external DisplayObject get displayObject;
  external set displayObject(DisplayObject v);

  /// Reserved for future multiple camera set-ups.
  external num get id;
  external set id(num v);

  /// Immobile [Phaser.Camera#view view] rectangle. Its top-left is always (0, 0). You can use this align fixedToCamera objects.
  external Rectangle get fixedView;
  external set fixedView(Rectangle v);

  /// The Graphics object used to handle camera fx such as fade and flash.
  external Graphics get fx;
  external set fx(Graphics v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// The Cameras height. By default this is the same as the Game size and should not be adjusted for now. Gets or sets the cameras height.
  external num get height;
  external set height(num v);

  /// The linear interpolation value to use when following a target.
  /// The default values of 1 means the camera will instantly snap to the target coordinates.
  /// A lower value, such as 0.1 means the camera will more slowly track the target, giving
  /// a smooth transition. You can set the horizontal and vertical values independently, and also
  /// adjust this value in real-time during your game.
  external PhaserPoint get lerp;
  external set lerp(Point v);

  /// The Cameras position. This value is automatically clamped if it falls outside of the World bounds. Gets or sets the cameras xy position using Phaser.Point object.
  external PhaserPoint get position;
  external set position(Point v);

  /// If a Camera has roundPx set to `true` it will call `view.floor` as part of its update loop, keeping its boundary to integer values. Set this to `false` to disable this from happening.
  /// Default: true
  external bool get roundPx;
  external set roundPx(bool v);

  /// The scale of the display object to which all game objects are added. Set by World.boot.
  external PhaserPoint get scale;
  external set scale(Point v);

  /// The Cameras shake intensity. Gets or sets the cameras shake intensity.
  external num get shakeIntensity;
  external set shakeIntensity(num v);

  /// This signal is dispatched when the camera fade effect completes.
  /// When the fade effect completes you will be left with the screen black (or whatever
  /// color you faded to). In order to reset this call `Camera.resetFX`. This is called
  /// automatically when you change State.
  external Signal get onFadeComplete;
  external set onFadeComplete(Signal v);

  /// This signal is dispatched when the camera flash effect completes.
  external Signal get onFlashComplete;
  external set onFlashComplete(Signal v);

  /// This signal is dispatched when the camera shake effect completes.
  external Signal get onShakeComplete;
  external set onShakeComplete(Signal v);

  /// If the camera is tracking a Sprite, this is a reference to it, otherwise null.
  external Sprite get target;
  external set target(Sprite v);

  /// The total number of Sprites with `autoCull` set to `true` that are visible by this Camera.
  external num get totalInView;
  external set totalInView(num v);

  /// Camera view.
  /// The view into the world we wish to render (by default the game dimensions).
  /// The x/y values are in world coordinates, not screen coordinates, the width/height is how many pixels to render.
  /// Sprites outside of this view are not rendered if Sprite.autoCull is set to `true`. Otherwise they are always rendered.
  external Rectangle get view;
  external set view(Rectangle v);

  /// Whether this camera is visible or not.
  /// Default: true
  external bool get visible;
  external set visible(bool v);

  /// The Cameras width. By default this is the same as the Game size and should not be adjusted for now. Gets or sets the cameras width.
  external num get width;
  external set width(num v);

  /// A reference to the game world.
  external World get world;
  external set world(World v);

  /// The Cameras x coordinate. This value is automatically clamped if it falls outside of the World bounds. Gets or sets the cameras x position.
  external num get x;
  external set x(num v);

  /// The Cameras y coordinate. This value is automatically clamped if it falls outside of the World bounds. Gets or sets the cameras y position.
  external num get y;
  external set y(num v);

  /// Method called to ensure the camera doesn't venture outside of the game world.
  /// Called automatically by Camera.update.
  external void checkBounds();

  /// This creates a camera fade effect. It works by filling the game with the
  /// color specified, over the duration given, ending with a solid fill.
  /// You can use this for things such as transitioning to a new scene.
  /// The game will be left 'filled' at the end of this effect, likely obscuring
  /// everything. In order to reset it you can call `Camera.resetFX` and it will clear the
  /// fade. Or you can call `Camera.flash` with the same color as the fade, and it will
  /// reverse the process, bringing the game back into view again.
  /// When the effect ends the signal Camera.onFadeComplete is dispatched.
  external bool fade([num color, num duration, bool force, num alpha]);

  /// This creates a camera flash effect. It works by filling the game with the solid fill
  /// color specified, and then fading it away to alpha 0 over the duration given.
  /// You can use this for things such as hit feedback effects.
  /// When the effect ends the signal Camera.onFlashComplete is dispatched.
  external bool flash([num color, num duration, bool force, num alpha]);

  /// Move the camera focus on a display object instantly.
  external void focusOn(DisplayObject displayObject);

  /// Move the camera focus on a location instantly.
  external void focusOnXY(num x, num y);

  /// Tell the camera which sprite to follow.
  /// You can set the follow type and a linear interpolation value.
  /// Use low lerp values (such as 0.1) to automatically smooth the camera motion.
  /// If you find you're getting a slight "jitter" effect when following a Sprite it's probably to do with sub-pixel rendering of the Sprite position.
  /// This can be disabled by setting `game.renderer.renderSession.roundPixels = true` to force full pixel rendering.
  external void follow(Sprite target, [num style, num lerpX, num lerpY]);

  /// Resets the camera back to 0,0 and un-follows any object it may have been tracking.
  /// Also immediately resets any camera effects that may have been running such as
  /// shake, flash or fade.
  external void reset();

  /// Resets any active FX, such as a fade or flash and immediately clears it.
  /// Useful to calling after a fade in order to remove the fade from the Stage.
  external void resetFX();

  /// Update the Camera bounds to match the game world.
  external void setBoundsToWorld();

  /// A helper function to set both the X and Y properties of the camera at once
  /// without having to use game.camera.x and game.camera.y.
  external void setPosition(num x, num y);

  /// Sets the size of the view rectangle given the width and height in parameters.
  external void setSize(num width, num height);

  /// This creates a camera shake effect. It works by applying a random amount of additional
  /// spacing on the x and y axis each frame. You can control the intensity and duration
  /// of the effect, and if it should effect both axis or just one.
  /// When the shake effect ends the signal Camera.onShakeComplete is dispatched.
  external bool shake(
      [num intensity,
      num duration,
      bool force,
      num direction,
      bool shakeBounds]);

  /// Sets the Camera follow target to null, stopping it from following an object if it's doing so.
  external void unfollow();

  /// The camera update loop. This is called automatically by the core game loop.
  external void update();
}

/// The Canvas class handles everything related to creating the `canvas` DOM tag that Phaser will use,
/// including styles, offset and aspect ratio.
@JS("Phaser.Canvas")
class Canvas {
  // @Ignore
  Canvas.fakeConstructor$();

  /// Adds the given canvas element to the DOM. The canvas will be added as a child of the given parent.
  /// If no parent is given it will be added as a child of the document.body.
  external static CanvasElement addToDOM(
      CanvasElement canvas, HtmlElement parent,
      [bool overflowHidden]);

  /// Creates a `canvas` DOM element. The element is not automatically added to the document.
  external static CanvasElement create(DivElement parent,
      [num width, num height, String id, bool skipPool]);

  /// Returns `true` if the given context has image smoothing enabled, otherwise returns `false`.
  external static bool getSmoothingEnabled(CanvasRenderingContext2D context);

  /// Gets the Smoothing Enabled vendor prefix being used on the given context, or null if not set.
  external static String getSmoothingPrefix(CanvasRenderingContext2D context);

  /// Removes the given canvas element from the DOM.
  external static void removeFromDOM(CanvasElement canvas);

  /// Sets the background color behind the canvas. This changes the canvas style property.
  external static CanvasElement setBackgroundColor(
      CanvasElement canvas, String color);

  /// Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').
  /// Note that if this doesn't given the desired result then see the CanvasUtils.setSmoothingEnabled method.
  external static CanvasElement setImageRenderingBicubic(CanvasElement canvas);

  /// Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast' on webkit).
  /// Note that if this doesn't given the desired result then see the setSmoothingEnabled.
  external static CanvasElement setImageRenderingCrisp(CanvasElement canvas);

  /// Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.
  /// By default browsers have image smoothing enabled, which isn't always what you visually want, especially
  /// when using pixel art in a game. Note that this sets the property on the context itself, so that any image
  /// drawn to the context will be affected. This sets the property across all current browsers but support is
  /// patchy on earlier browsers, especially on mobile.
  external static CanvasRenderingContext2D setSmoothingEnabled(
      CanvasRenderingContext2D context, bool value);

  /// Sets the touch-action property on the canvas style. Can be used to disable default browser touch actions.
  external static CanvasElement setTouchAction(
      CanvasElement canvas, String value);

  /// Sets the transform of the given canvas to the matrix values provided.
  external static CanvasRenderingContext2D setTransform(
      CanvasRenderingContext2D context,
      num translateX,
      num translateY,
      num scaleX,
      num scaleY,
      num skewX,
      num skewY);

  /// Sets the user-select property on the canvas style. Can be used to disable default browser selection actions.
  external static CanvasElement setUserSelect(CanvasElement canvas,
      [String value]);
}

/// The CanvasPool is a global static object, that allows Phaser to recycle and pool Canvas DOM elements.
@JS("Phaser.CanvasPool")
class CanvasPool {
  // @Ignore
  CanvasPool.fakeConstructor$();

  /// Creates a new Canvas DOM element, or pulls one from the pool if free.
  external static CanvasElement create(HtmlElement parent,
      [num width, num height]);

  /// Gets the first free canvas index from the pool.
  external static CanvasElement getFirst();

  /// Looks up a canvas based on its parent, and if found puts it back in the pool, freeing it up for re-use.
  /// The canvas has its width and height set to 1, and its parent attribute nulled.
  external static void remove(HtmlElement parent);

  /// Looks up a canvas based on its type, and if found puts it back in the pool, freeing it up for re-use.
  /// The canvas has its width and height set to 1, and its parent attribute nulled.
  external static CanvasElement removeByCanvas(CanvasElement canvas);

  /// Gets the total number of used canvas elements in the pool.
  external static num getTotal();

  /// Gets the total number of free canvas elements in the pool.
  external static num getFree();
  external static num get length;
  external static set length(num v);

  /// Prints in-use, free, and total counts to console.log.
  external static void log();
}

/// Creates a new Circle object with the center coordinate specified by the x and y parameters and the diameter specified by the diameter parameter.
/// If you call this function without parameters, a circle with x, y, diameter and radius properties set to 0 is created.
@JS("Phaser.Circle")
class Circle {
  // @Ignore
  Circle.fakeConstructor$();

  /// Creates a new Circle object with the center coordinate specified by the x and y parameters and the diameter specified by the diameter parameter.
  /// If you call this function without parameters, a circle with x, y, diameter and radius properties set to 0 is created.
  external factory Circle([num x, num y, num diameter]);

  /// The area of this Circle.
  external num get area;
  external set area(num v);

  /// The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter. Gets or sets the bottom of the circle.
  external num get bottom;
  external set bottom(num v);

  /// The largest distance between any two points on the circle. The same as the radius * 2. Gets or sets the diameter of the circle.
  external num get diameter;
  external set diameter(num v);

  /// Determines whether or not this Circle object is empty. Will return a value of true if the Circle objects diameter is less than or equal to 0; otherwise false.
  /// If set to true it will reset all of the Circle objects properties to 0. A Circle object is empty if its diameter is less than or equal to 0. Gets or sets the empty state of the circle.
  external bool get empty;
  external set empty(bool v);

  /// The x coordinate of the leftmost point of the circle. Changing the left property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.
  external num get left;
  external set left(num v);

  /// The length of a line extending from the center of the circle to any point on the circle itself. The same as half the diameter. Gets or sets the radius of the circle.
  external num get radius;
  external set radius(num v);

  /// The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property. Gets or sets the value of the rightmost point of the circle.
  external num get right;
  external set right(num v);

  /// The sum of the y minus the radius property. Changing the top property of a Circle object has no effect on the x and y properties, but does change the diameter. Gets or sets the top of the circle.
  external num get top;
  external set top(num v);

  /// The x coordinate of the center of the circle.
  external num get x;
  external set x(num v);

  /// The y coordinate of the center of the circle.
  external num get y;
  external set y(num v);

  /// Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
  /*external static Point circumferencePoint(Circle a, num angle, bool asDegrees, [Point out]);*/
  /// Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.
  /*external Point circumferencePoint(num angle, [bool asDegrees, Point out]);*/
  external Point circumferencePoint(dynamic /*Circle|num*/ a_angle,
      [dynamic /*num|bool*/ angle_asDegrees,
      dynamic /*bool|Point*/ asDegrees_out,
      Point out]);
  /*external static bool contains(Circle a, num x, num y);*/
  /// Return true if the given x/y coordinates are within this Circle object.
  /*external bool contains(num x, num y);*/
  external bool contains(dynamic /*Circle|num*/ a_x, num x_y, [num y]);
  external static bool equals(Circle a, Circle b);
  external static bool intersects(Circle a, Circle b);
  external static bool intersectsRectangle(Circle c, Rectangle r);
  external num circumference();
  external Circle clone(Circle output);

  /// Copies the x, y and diameter properties from any given object to this Circle.
  external Circle copyFrom(dynamic source);

  /// Copies the x, y and diameter properties from this Circle to any given object.
  external dynamic copyTo(dynamic dest);

  /// Returns the distance from the center of the Circle object to the given object
  /// (can be Circle, Point or anything with x/y properties)
  external num distance(dynamic dest, [bool round]);

  /// Returns the framing rectangle of the circle as a Phaser.Rectangle object.
  external Rectangle getBounds();

  /// Adjusts the location of the Circle object, as determined by its center coordinate, by the specified amounts.
  external Circle offset(num dx, num dy);

  /// Adjusts the location of the Circle object using a Point object as a parameter. This method is similar to the Circle.offset() method, except that it takes a Point object as a parameter.
  external Circle offsetPoint(Point point);

  /// Returns a uniformly distributed random point from anywhere within this Circle.
  /// If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an existing object.
  external Point random([Point out]);

  /// Creates or positions points on the circle.
  /// The points are equally distributed in the half-closed interval [startAngle, endAngle). The default arc is the entire circle.
  /// If the `out` argument is omitted, this method creates and returns an array of [Phaser.Point points]. If an array is passed as `out`, its items are treated as points and placed in the same way.
  external List<dynamic> sample(
      [num steps,
      num startAngle,
      num endAngle,
      bool asDegrees,
      List<dynamic> out]);
  external Rectangle scale(num x, [num y]);

  /// Sets the members of Circle to the specified values.
  external Circle setTo(num x, num y, num diameter);

  /// Returns a string representation of this object.
  external String toString();
}

/// The Phaser.Color class is a set of static methods that assist in color manipulation and conversion.
@JS("Phaser.Color")
class Color {
  // @Ignore
  Color.fakeConstructor$();

  /// Return a string containing a hex representation of the given color component.
  external static String componentToHex(num color);

  /// A utility function to create a lightweight 'color' object with the default components.
  /// Any components that are not specified will default to zero.
  /// This is useful when you want to use a shared color object for the getPixel and getPixelAt methods.
  external static ColorComponents createColor(
      [num r, num g, num b, num a, num h, num s, num l, num v]);

  /// A utility to convert an integer in 0xRRGGBBAA format to a color object.
  /// This does not rely on endianness.
  external static ColorComponents fromRGBA(num rgba, [ColorComponents out]);

  /// Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component, as a value between 0 and 255.
  external static num getAlpha(num color);

  /// Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component as a value between 0 and 1.
  external static num getAlphaFloat(num color);

  /// Given a native color value (in the format 0xAARRGGBB) this will return the Blue component, as a value between 0 and 255.
  external static num getBlue(num color);

  /// Given 3 color values this will return an integer representation of it.
  external static num getColor(num red, num green, num blue);

  /// Given an alpha and 3 color values this will return an integer representation of it.
  external static num getColor32(num alpha, num red, num green, num blue);

  /// Given a native color value (in the format 0xAARRGGBB) this will return the Green component, as a value between 0 and 255.
  external static num getGreen(num color);

  /// Returns a random color value between black and white
  /// Set the min value to start each channel from the given offset.
  /// Set the max value to restrict the maximum color used per channel.
  external static num getRandomColor([num min, num max, num alpha]);

  /// Given a native color value (in the format 0xAARRGGBB) this will return the Red component, as a value between 0 and 255.
  external static num getRed(num color);

  /// Return the component parts of a color as an Object with the properties alpha, red, green, blue.
  /// Alpha will only be set if it exist in the given color (0xAARRGGBB)
  external static RGBColor getRGB(num color);

  /// Returns a CSS friendly string value from the given color.
  external static String getWebRGB(dynamic /*num|RGBColor*/ color);

  /// Converts a hex color value to an [R, G, B] array.
  external static List<num> hexToRGBArray(num color);

  /// Converts a hex string into an integer color value.
  external static num hexToRGB(String h);

  /// Converts a hex string into a Phaser Color object.
  /// The hex string can supplied as `'#0033ff'` or the short-hand format of `'#03f'`; it can begin with an optional "#" or "0x", or be unprefixed.
  /// An alpha channel is _not_ supported.
  external static ColorComponents hexToColor(String hex, [ColorComponents out]);

  /// Converts an HSL (hue, saturation and lightness) color value to RGB.
  /// Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
  /// Assumes HSL values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].
  /// Based on code by Michael Jackson (https://github.com/mjijackson)
  external static ColorComponents HSLtoRGB(num h, num s, num l,
      [ColorComponents out]);

  /// Get HSL color wheel values in an array which will be 360 elements in size.
  external static List<ColorComponents> HSLColorWheel([num s, num l]);

  /// Converts an HSV (hue, saturation and value) color value to RGB.
  /// Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
  /// Assumes HSV values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].
  /// Based on code by Michael Jackson (https://github.com/mjijackson)
  external static ColorComponents HSVtoRGB(num h, num s, num v,
      [ColorComponents out]);

  /// Get HSV color wheel values in an array which will be 360 elements in size.
  external static List<ColorComponents> HSVColorWheel([num s, num v]);

  /// Converts a hue to an RGB color.
  /// Based on code by Michael Jackson (https://github.com/mjijackson)
  external static num hueToColor(num p, num q, num t);

  /// Interpolates the two given colours based on the supplied step and currentStep properties.
  external static num interpolateColor(
      num color1, num color2, num steps, num currentStep,
      [num alpha, num colorSpace]);

  /// Interpolates the two given colours based on the supplied step and currentStep properties.
  external static num interpolateColorWithRGB(
      num color, num r, num g, num b, num steps, num currentStep);

  /// Interpolates the two given colours based on the supplied step and currentStep properties.
  external static num interpolateRGB(num r1, num g1, num b1, num r2, num g2,
      num b2, num steps, num currentStep);

  /// Calculates a linear (interpolation) value of two colors over t.
  /// This is a slightly simpler interface to [Phaser.Color.interpolateColor].
  /// The arguments are similar to [Phaser.Math.linear].
  external static num linear(num color1, num color2, num t);

  /// Calculates a linear (interpolation) value of an array of colors over t.
  /// The arguments are similar to [Phaser.Math.linearInterpolation].
  /// This can be used as a [Phaser.TweenData#interpolationFunction].
  external static num linearInterpolation(List<num> colors, num t);

  /// Packs the r, g, b, a components into a single integer, for use with Int32Array.
  /// If device is little endian then ABGR order is used. Otherwise RGBA order is used.
  external static num packPixel(num r, num g, num b, num a);

  /// Converts an RGB color array, in the format: [R, G, B], to a hex color value.
  external static num RGBArrayToHex(List<num> rgb);

  /// Converts an RGB color value to HSL (hue, saturation and lightness).
  /// Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
  /// Assumes RGB values are contained in the set [0, 255] and returns h, s and l in the set [0, 1].
  /// Based on code by Michael Jackson (https://github.com/mjijackson)
  external static ColorComponents RGBtoHSL(num r, num g, num b,
      [ColorComponents out]);

  /// Converts an RGB color value to HSV (hue, saturation and value).
  /// Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.
  /// Assumes RGB values are contained in the set [0, 255] and returns h, s and v in the set [0, 1].
  /// Based on code by Michael Jackson (https://github.com/mjijackson)
  external static ColorComponents RGBtoHSV(num r, num g, num b,
      [ColorComponents out]);

  /// Converts the given color values into a string.
  /// If prefix was '#' it will be in the format `#RRGGBB` otherwise `0xAARRGGBB`.
  external static String RGBtoString(num r, num g, num b,
      [num a, String prefix]);

  /// A utility to convert RGBA components to a 32 bit integer in RRGGBBAA format.
  external static num toRGBA(num r, num g, num b, num a);

  /// Converts RGBA components to a 32 bit integer in AABBGGRR format.
  external static num toABGR(num r, num g, num b, num a);

  /// Unpacks the r, g, b, a components into the specified color object, or a new
  /// object, for use with Int32Array. If little endian, then ABGR order is used when
  /// unpacking, otherwise, RGBA order is used. The resulting color object has the
  /// `r, g, b, a` properties which are unrelated to endianness.
  /// Note that the integer is assumed to be packed in the correct endianness. On little-endian
  /// the format is 0xAABBGGRR and on big-endian the format is 0xRRGGBBAA. If you want a
  /// endian-independent method, use fromRGBA(rgba) and toRGBA(r, g, b, a).
  external static ColorComponents unpackPixel(num rgba,
      [ColorComponents out, bool hsl, bool hsv]);

  /// Takes a color object and updates the rgba, color and color32 properties.
  external static ColorComponents updateColor(ColorComponents out);

  /// Converts a value - a "hex" string, a "CSS 'web' string", or a number - into red, green, blue, and alpha components.
  /// The value can be a string (see `hexToColor` and `webToColor` for the supported formats) or a packed integer (see `getRGB`).
  /// An alpha channel is _not_ supported when specifying a hex string.
  external static ColorComponents valueToColor(String value,
      [ColorComponents out]);

  /// Converts a CSS 'web' string into a Phaser Color object.
  /// The web string can be in the format `'rgb(r,g,b)'` or `'rgba(r,g,b,a)'` where r/g/b are in the range [0..255] and a is in the range [0..1].
  external static ColorComponents webToColor(String web, [ColorComponents out]);

  /// Blends the source color, ignoring the backdrop.
  external static num blendNormal(num a);

  /// Selects the lighter of the backdrop and source colors.
  external static num blendLighten(num a, num b);

  /// Selects the darker of the backdrop and source colors.
  external static num blendDarken(num a, num b);

  /// Multiplies the backdrop and source color values.
  /// The result color is always at least as dark as either of the two constituent
  /// colors. Multiplying any color with black produces black;
  /// multiplying with white leaves the original color unchanged.
  external static num blendMultiply(num a, num b);

  /// Takes the average of the source and backdrop colors.
  external static num blendAverage(num a, num b);

  /// Adds the source and backdrop colors together and returns the value, up to a maximum of 255.
  external static num blendAdd(num a, num b);

  /// Combines the source and backdrop colors and returns their value minus 255.
  external static num blendSubtract(num a, num b);

  /// Subtracts the darker of the two constituent colors from the lighter.
  /// Painting with white inverts the backdrop color; painting with black produces no change.
  external static num blendDifference(num a, num b);

  /// Negation blend mode.
  external static num blendNegation(num a, num b);

  /// Multiplies the complements of the backdrop and source color values, then complements the result.
  /// The result color is always at least as light as either of the two constituent colors.
  /// Screening any color with white produces white; screening with black leaves the original color unchanged.
  external static num blendScreen(num a, num b);

  /// Produces an effect similar to that of the Difference mode, but lower in contrast.
  /// Painting with white inverts the backdrop color; painting with black produces no change.
  external static num blendExclusion(num a, num b);

  /// Multiplies or screens the colors, depending on the backdrop color.
  /// Source colors overlay the backdrop while preserving its highlights and shadows.
  /// The backdrop color is not replaced, but is mixed with the source color to reflect the lightness or darkness of the backdrop.
  external static num blendOverlay(num a, num b);

  /// Darkens or lightens the colors, depending on the source color value.
  /// If the source color is lighter than 0.5, the backdrop is lightened, as if it were dodged;
  /// this is useful for adding highlights to a scene.
  /// If the source color is darker than 0.5, the backdrop is darkened, as if it were burned in.
  /// The degree of lightening or darkening is proportional to the difference between the source color and 0.5;
  /// if it is equal to 0.5, the backdrop is unchanged.
  /// Painting with pure black or white produces a distinctly darker or lighter area, but does not result in pure black or white.
  /// The effect is similar to shining a diffused spotlight on the backdrop.
  external static num blendSoftLight(num a, num b);

  /// Multiplies or screens the colors, depending on the source color value.
  /// If the source color is lighter than 0.5, the backdrop is lightened, as if it were screened;
  /// this is useful for adding highlights to a scene.
  /// If the source color is darker than 0.5, the backdrop is darkened, as if it were multiplied;
  /// this is useful for adding shadows to a scene.
  /// The degree of lightening or darkening is proportional to the difference between the source color and 0.5;
  /// if it is equal to 0.5, the backdrop is unchanged.
  /// Painting with pure black or white produces pure black or white. The effect is similar to shining a harsh spotlight on the backdrop.
  external static num blendHardLight(num a, num b);

  /// Brightens the backdrop color to reflect the source color.
  /// Painting with black produces no change.
  external static num blendColorDodge(num a, num b);

  /// Darkens the backdrop color to reflect the source color.
  /// Painting with white produces no change.
  external static num blendColorBurn(num a, num b);

  /// An alias for blendAdd, it simply sums the values of the two colors.
  external static num blendLinearDodge(num a, num b);

  /// An alias for blendSubtract, it simply sums the values of the two colors and subtracts 255.
  external static num blendLinearBurn(num a, num b);

  /// This blend mode combines Linear Dodge and Linear Burn (rescaled so that neutral colors become middle gray).
  /// Dodge applies to values of top layer lighter than middle gray, and burn to darker values.
  /// The calculation simplifies to the sum of bottom layer and twice the top layer, subtract 128. The contrast decreases.
  external static num blendLinearLight(num a, num b);

  /// This blend mode combines Color Dodge and Color Burn (rescaled so that neutral colors become middle gray).
  /// Dodge applies when values in the top layer are lighter than middle gray, and burn to darker values.
  /// The middle gray is the neutral color. When color is lighter than this, this effectively moves the white point of the bottom
  /// layer down by twice the difference; when it is darker, the black point is moved up by twice the difference. The perceived contrast increases.
  external static num blendVividLight(num a, num b);

  /// If the backdrop color (light source) is lighter than 50%, the blendDarken mode is used, and colors lighter than the backdrop color do not change.
  /// If the backdrop color is darker than 50% gray, colors lighter than the blend color are replaced, and colors darker than the blend color do not change.
  external static num blendPinLight(num a, num b);

  /// Runs blendVividLight on the source and backdrop colors.
  /// If the resulting color is 128 or more, it receives a value of 255; if less than 128, a value of 0.
  /// Therefore, all blended pixels have red, green, and blue channel values of either 0 or 255.
  /// This changes all pixels to primary additive colors (red, green, or blue), white, or black.
  external static num blendHardMix(num a, num b);

  /// Reflect blend mode. This mode is useful when adding shining objects or light zones to images.
  external static num blendReflect(num a, num b);

  /// Glow blend mode. This mode is a variation of reflect mode with the source and backdrop colors swapped.
  external static num blendGlow(num a, num b);

  /// Phoenix blend mode. This subtracts the lighter color from the darker color, and adds 255, giving a bright result.
  external static num blendPhoenix(num a, num b);
}

// Module Component

// Module Core
@JS("Phaser.Component.Core.skipTypeChecks")
external bool get skipTypeChecks;
@JS("Phaser.Component.Core.skipTypeChecks")
external set skipTypeChecks(bool v);
// End module Core

// End module Component
@anonymous
@JS()
abstract class RGBColor {
  external num get r;
  external set r(num v);
  external num get g;
  external set g(num v);
  external num get b;
  external set b(num v);
  external num get a;
  external set a(num v);
  external factory RGBColor({num r, num g, num b, num a});
}

@anonymous
@JS()
abstract class ColorComponents implements RGBColor {
  external num get h;
  external set h(num v);
  external num get s;
  external set s(num v);
  external num get v;
  external set v(num v);
  external num get l;
  external set l(num v);
  external num get color;
  external set color(num v);
  external num get color32;
  external set color32(num v);
  external String get rgba;
  external set rgba(String v);
  external factory ColorComponents(
      {num h,
      num s,
      num v,
      num l,
      num color,
      num color32,
      String rgba,
      num r,
      num g,
      num b,
      num a});
}

/// The Phaser.Create class is a collection of smaller helper methods that allow you to generate game content
/// quickly and easily, without the need for any external files. You can create textures for sprites and in
/// coming releases we'll add dynamic sound effect generation support as well (like sfxr).
/// Access this via `Game.create` (`this.game.create` from within a State object).
@JS("Phaser.Create")
class Create {
  // @Ignore
  Create.fakeConstructor$();

  /// The Phaser.Create class is a collection of smaller helper methods that allow you to generate game content
  /// quickly and easily, without the need for any external files. You can create textures for sprites and in
  /// coming releases we'll add dynamic sound effect generation support as well (like sfxr).
  /// Access this via `Game.create` (`this.game.create` from within a State object).
  external factory Create(Game game);

  /// A 16 color palette by [Arne](http://androidarts.com/palette/16pal.htm)
  external static num get PALETTE_ARNE;
  external static set PALETTE_ARNE(num v);

  /// A 16 color JMP inspired palette.
  external static num get PALETTE_JMP;
  external static set PALETTE_JMP(num v);

  /// A 16 color CGA inspired palette.
  external static num get PALETTE_CGA;
  external static set PALETTE_CGA(num v);

  /// A 16 color C64 inspired palette.
  external static num get PALETTE_C64;
  external static set PALETTE_C64(num v);

  /// A 16 color palette inspired by Japanese computers like the MSX.
  external static num get PALETTE_JAPANESE_MACHINE;
  external static set PALETTE_JAPANESE_MACHINE(num v);

  /// The internal BitmapData Create uses to generate textures from.
  external BitmapData get bmd;
  external set bmd(BitmapData v);

  /// The canvas the BitmapData uses.
  external CanvasElement get canvas;
  external set canvas(CanvasElement v);

  /// The 2d context of the canvas.
  external CanvasRenderingContext2D get ctx;
  external set ctx(CanvasRenderingContext2D v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// A range of 16 color palettes for use with sprite generation.
  external dynamic get palettes;
  external set palettes(dynamic v);

  /// Copies the contents of [bmd Create's canvas] to the given BitmapData object, or a new BitmapData object.
  external BitmapData copy(
      [BitmapData dest,
      num x,
      num y,
      num width,
      num height,
      String blendMode,
      bool roundPx]);

  /// Creates a grid texture based on the given dimensions.
  /// Use [Phaser.Loader#imageFromGrid] to preload an image of the same.
  external Texture grid(String key, num width, num height, num cellWidth,
      num cellHeight, String color,
      [bool generateTexture, Function callback, dynamic callbackContext]);

  /// Generates a new PIXI.Texture from the given data, which can be applied to a Sprite.
  /// This allows you to create game graphics quickly and easily, with no external files but that use actual proper images
  /// rather than Phaser.Graphics objects, which are expensive to render and limited in scope.
  /// Each element of the array is a string holding the pixel color values, as mapped to one of the Phaser.Create PALETTE consts.
  /// For example:
  /// `var data = [
  /// ' 333 ',
  /// ' 777 ',
  /// 'E333E',
  /// ' 333 ',
  /// ' 3 3 '
  /// ];`
  /// `game.create.texture('bob', data);`
  /// The above will create a new texture called `bob`, which will look like a little man wearing a hat. You can then use it
  /// for sprites the same way you use any other texture: `game.add.sprite(0, 0, 'bob');`
  /// Use [Phaser.Loader#imageFromTexture] to preload an image of the same.
  external Texture texture(String key, dynamic data,
      [num pixelWidth,
      num pixelHeight,
      num palette,
      bool generateTexture,
      Function callback,
      dynamic callbackContext]);
}

@anonymous
@JS()
abstract class CursorKeys {
  external Key get up;
  external set up(Key v);
  external Key get down;
  external set down(Key v);
  external Key get left;
  external set left(Key v);
  external Key get right;
  external set right(Key v);
  external factory CursorKeys({Key up, Key down, Key left, Key right});
}

/// Detects device support capabilities and is responsible for device initialization - see [Phaser.Device.whenReady whenReady].
/// This class represents a singleton object that can be accessed directly as `game.device`
/// (or, as a fallback, `Phaser.Device` when a game instance is not available) without the need to instantiate it.
/// Unless otherwise noted the device capabilities are only guaranteed after initialization. Initialization
/// occurs automatically and is guaranteed complete before [Phaser.Game] begins its "boot" phase.
/// Feature detection can be modified in the [Phaser.Device.onInitialized onInitialized] signal, e.g.,
/// ```javascript
/// Phaser.Device.onInitialized.add(function (device) {
/// device.canvasBitBltShift = true;
/// device.mspointer = false;
/// });
/// var game = new Phaser.Game();
/// ```
/// When checking features using the exposed properties only the *truth-iness* of the value should be relied upon
/// unless the documentation states otherwise: properties may return `false`, `''`, `null`, or even `undefined`
/// when indicating the lack of a feature.
/// Uses elements from System.js by MrDoob and Modernizr
@JS("Phaser.Device")
class Device {
  // @Ignore
  Device.fakeConstructor$();

  /// Same value as `littleEndian`.
  external static bool get LITTLE_ENDIAN;
  external static set LITTLE_ENDIAN(bool v);

  /// This signal is dispatched after device initialization occurs but before any of the ready
  /// callbacks (see [Phaser.Device.whenReady whenReady]) have been invoked.
  /// Local "patching" for a particular device can/should be done in this event.
  /// _Note_: This signal is removed after the device has been readied; if a handler has not been
  /// added _before_ `new Phaser.Game(..)` it is probably too late.
  external static Signal get onInitialized;
  external static set onInitialized(Signal v);
  external static void checkFullScreenSupport();

  /// Check whether the host environment can play audio.
  external static bool canPlayAudio(String type);

  /// Check whether the host environment can play video files.
  external static bool canPlayVideo(String type);

  /// Returns false.
  external static bool isConsoleOpen();

  /// Detect if the host is a an Android Stock browser.
  /// This is available before the device "ready" event.
  /// Authors might want to scale down on effects and switch to the CANVAS rendering method on those devices.
  external static String isAndroidStockBrowser();
  external static VoidFunc2Opt1<Function, dynamic> get whenReady;
  external static set whenReady(VoidFunc2Opt1<Function, dynamic> v);

  /// Is running on android?
  external bool get android;
  external set android(bool v);

  /// Set to true if running in Arora.
  external bool get arora;
  external set arora(bool v);

  /// Are Audio tags available?
  external bool get audioData;
  external set audioData(bool v);
  external String get cancelFullScreen;
  external set cancelFullScreen(String v);

  /// If the browser isn't capable of handling tinting with alpha this will be false.
  external bool get canHandleAlpha;
  external set canHandleAlpha(bool v);

  /// Whether or not the [http://caniuse.com/#feat=canvas-blending Canvas Blend Modes] are supported, consequently the ability to tint using the multiply method.
  /// Expect `false` in Internet Explorer <= 11.
  external bool get canUseMultiply;
  external set canUseMultiply(bool v);

  /// Is canvas available?
  external bool get canvas;
  external set canvas(bool v);

  /// Set to true if running in Chrome.
  external bool get chrome;
  external set chrome(bool v);

  /// Is running on chromeOS?
  external bool get chromeOS;
  external set chromeOS(bool v);

  /// If running in Chrome this will contain the major version number.
  external num get chromeVersion;
  external set chromeVersion(num v);

  /// Is the game running under CocoonJS?
  external bool get cocoonJS;
  external set cocoonJS(bool v);

  /// Is this game running with CocoonJS.App?
  external bool get cocoonJSApp;
  external set cocoonJSApp(bool v);

  /// Is the game running under Apache Cordova?
  external bool get cordova;
  external set cordova(bool v);

  /// Is the game running under the Intel Crosswalk XDK?
  external bool get crosswalk;
  external set crosswalk(bool v);

  /// Is css3D available?
  external bool get css3D;
  external set css3D(bool v);

  /// Is running on a desktop?
  external bool get desktop;
  external set desktop(bool v);

  /// The time the device became ready.
  external num get deviceReadyAt;
  external set deviceReadyAt(num v);

  /// Is the game running under GitHub Electron?
  external bool get electron;
  external set electron(bool v);

  /// Is the game running under Ejecta?
  external bool get ejecta;
  external set ejecta(bool v);

  /// Set to true if running in Epiphany.
  external bool get epiphany;
  external set epiphany(bool v);

  /// Is file available?
  external bool get file;
  external set file(bool v);

  /// Is fileSystem available?
  external bool get fileSystem;
  external set fileSystem(bool v);

  /// Set to true if running in Firefox.
  external bool get firefox;
  external set firefox(bool v);

  /// If running in Firefox this will contain the major version number.
  external num get firefoxVersion;
  external set firefoxVersion(num v);
  external bool get fullScreen;
  external set fullScreen(bool v);
  external bool get fullScreenKeyboard;
  external set fullScreenKeyboard(bool v);

  /// Does the device support the getUserMedia API?
  /// Default: true
  external bool get getUserMedia;
  external set getUserMedia(bool v);
  external Game get game;
  external set game(Game v);

  /// Can this device play h264 mp4 video files?
  external bool get h264Video;
  external set h264Video(bool v);

  /// Can this device play hls video files?
  external bool get hlsVideo;
  external set hlsVideo(bool v);

  /// Set to true if running in Internet Explorer.
  external bool get ie;
  external set ie(bool v);

  /// If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Device.trident and Device.tridentVersion.
  external num get ieVersion;
  external set ieVersion(num v);

  /// Is running on iOS?
  external bool get iOS;
  external set iOS(bool v);

  /// If running in iOS this will contain the major version number.
  external num get iOSVersion;
  external set iOSVersion(num v);

  /// The time as which initialization has completed.
  external bool get initialized;
  external set initialized(bool v);

  /// Is running on iPad?
  external bool get iPad;
  external set iPad(bool v);

  /// Is running on iPhone?
  external bool get iPhone;
  external set iPhone(bool v);

  /// Is running on iPhone4?
  external bool get iPhone4;
  external set iPhone4(bool v);
  external bool get kindle;
  external set kindle(bool v);

  /// Is running on linux?
  external bool get linux;
  external set linux(bool v);

  /// Is the device big or little endian? (only detected if the browser supports TypedArrays)
  external bool get littleEndian;
  external set littleEndian(bool v);

  /// Is localStorage available?
  external bool get localStorage;
  external set localStorage(bool v);

  /// Can this device play m4a files? True if this device can play m4a files.
  external bool get m4a;
  external set m4a(bool v);

  /// Is running on macOS?
  external bool get macOS;
  external set macOS(bool v);

  /// Set to true if running in Midori.
  external bool get midori;
  external set midori(bool v);

  /// Set to true if running in Mobile Safari.
  external bool get mobileSafari;
  external set mobileSafari(bool v);

  /// Can this device play mp3 files?
  external bool get mp3;
  external set mp3(bool v);

  /// Can this device play h264 mp4 video files?
  external bool get mp4Video;
  external set mp4Video(bool v);

  /// Is mspointer available?
  external bool get mspointer;
  external set mspointer(bool v);

  /// Is the game running under Node.js?
  external bool get node;
  external set node(bool v);

  /// Is the game running under Node-Webkit?
  external bool get nodeWebkit;
  external set nodeWebkit(bool v);

  /// Can this device play ogg files?
  external bool get ogg;
  external set ogg(bool v);

  /// Can this device play ogg video files?
  external num get oggVideo;
  external set oggVideo(num v);

  /// Set to true if running in Opera.
  external bool get opera;
  external set opera(bool v);

  /// Can this device play opus files?
  external bool get opus;
  external set opus(bool v);

  /// PixelRatio of the host device?
  external num get pixelRatio;
  external set pixelRatio(num v);

  /// Is Pointer Lock available?
  external bool get pointerLock;
  external set pointerLock(bool v);

  /// Is the browser running in strict mode (false) or quirks mode? (true)
  external bool get quirksMode;
  external set quirksMode(bool v);
  external String get requestFullScreen;
  external set requestFullScreen(String v);

  /// Set to true if running in Safari.
  external bool get safari;
  external set safari(bool v);

  /// Set to true if running in the Silk browser (as used on the Amazon Kindle)
  external bool get silk;
  external set silk(bool v);

  /// Does the device context support 32bit pixel manipulation using array buffer views?
  external bool get support32bit;
  external set support32bit(bool v);

  /// Is touch available?
  external bool get touch;
  external set touch(bool v);

  /// Set to true if running a Trident version of Internet Explorer (IE11+)
  external bool get trident;
  external set trident(bool v);

  /// If running in Internet Explorer 11 this will contain the major version number. See [http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx]
  external num get tridentVersion;
  external set tridentVersion(num v);

  /// Does the browser support TypedArrays?
  external bool get typedArray;
  external set typedArray(bool v);

  /// Does the device support the Vibration API?
  external bool get vibration;
  external set vibration(bool v);
  external bool get vita;
  external set vita(bool v);

  /// Can this device play wav files?
  external bool get wav;
  external set wav(bool v);

  /// Set to true if running as a WebApp, i.e. within a WebView
  external bool get webApp;
  external set webApp(bool v);

  /// Is the WebAudio API available?
  external bool get webAudio;
  external set webAudio(bool v);

  /// Is webGL (and stencil support) available?
  external bool get webGL;
  external set webGL(bool v);

  /// Any error raised while creating a test [Phaser.Device#webGL webGL] context.
  external Error get webGLError;
  external set webGLError(Error v);

  /// Can this device play webm files?
  external bool get webm;
  external set webm(bool v);

  /// Can this device play webm video files?
  external bool get webmVideo;
  external set webmVideo(bool v);

  /// Is running on windows?
  external bool get windows;
  external set windows(bool v);

  /// Is running on a Windows Phone?
  external bool get windowsPhone;
  external set windowsPhone(bool v);

  /// The newest type of Wheel/Scroll event supported: 'wheel', 'mousewheel', 'DOMMouseScroll'
  external String get wheelEvent;
  external set wheelEvent(String v);

  /// Is worker available?
  external bool get worker;
  external set worker(bool v);
  external bool get wp9Video;
  external set wp9Video(bool v);
}

/// DeviceButtons belong to both `Phaser.Pointer` and `Phaser.SinglePad` (Gamepad) instances.
/// For Pointers they represent the various buttons that can exist on mice and pens, such as the left button, right button,
/// middle button and advanced buttons like back and forward.
/// Access them via `Pointer.leftbutton`, `Pointer.rightButton` and so on.
/// On Gamepads they represent all buttons on the pad: from shoulder buttons to action buttons.
/// At the time of writing this there are device limitations you should be aware of:
/// - On Windows, if you install a mouse driver, and its utility software allows you to customize button actions
/// (e.g., IntelliPoint and SetPoint), the middle (wheel) button, the 4th button, and the 5th button might not be set,
/// even when they are pressed.
/// - On Linux (GTK), the 4th button and the 5th button are not supported.
/// - On Mac OS X 10.5 there is no platform API for implementing any advanced buttons.
@JS("Phaser.DeviceButton")
class DeviceButton {
  // @Ignore
  DeviceButton.fakeConstructor$();

  /// DeviceButtons belong to both `Phaser.Pointer` and `Phaser.SinglePad` (Gamepad) instances.
  /// For Pointers they represent the various buttons that can exist on mice and pens, such as the left button, right button,
  /// middle button and advanced buttons like back and forward.
  /// Access them via `Pointer.leftbutton`, `Pointer.rightButton` and so on.
  /// On Gamepads they represent all buttons on the pad: from shoulder buttons to action buttons.
  /// At the time of writing this there are device limitations you should be aware of:
  /// - On Windows, if you install a mouse driver, and its utility software allows you to customize button actions
  /// (e.g., IntelliPoint and SetPoint), the middle (wheel) button, the 4th button, and the 5th button might not be set,
  /// even when they are pressed.
  /// - On Linux (GTK), the 4th button and the 5th button are not supported.
  /// - On Mac OS X 10.5 there is no platform API for implementing any advanced buttons.
  external factory DeviceButton(
      dynamic /*Pointer|SinglePad*/ parent, num butonCode);

  /// The buttoncode of this button if a Gamepad, or the DOM button event value if a Pointer.
  external num get buttonCode;
  external set buttonCode(num v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// The "down" state of the button.
  external bool get isDown;
  external set isDown(bool v);

  /// The "up" state of the button.
  /// Default: true
  external bool get isUp;
  external set isUp(bool v);

  /// This Signal is dispatched every time this DeviceButton is pressed down.
  /// It is only dispatched once (until the button is released again).
  /// When dispatched it sends 2 arguments: A reference to this DeviceButton and the value of the button.
  external Signal get onDown;
  external set onDown(Signal v);

  /// Gamepad only.
  /// This Signal is dispatched every time this DeviceButton changes floating value (between, but not exactly, 0 and 1).
  /// When dispatched it sends 2 arguments: A reference to this DeviceButton and the value of the button.
  external Signal get onFloat;
  external set onFloat(Signal v);

  /// This Signal is dispatched every time this DeviceButton is released from a down state.
  /// It is only dispatched once (until the button is pressed again).
  /// When dispatched it sends 2 arguments: A reference to this DeviceButton and the value of the button.
  external Signal get onUp;
  external set onUp(Signal v);
  external Gamepad get pad;
  external set pad(Gamepad v);

  /// Gamepad only.
  /// If a button is held down this holds down the number of times the button has 'repeated'.
  external num get repeats;
  external set repeats(num v);

  /// The timestamp when the button was last pressed down.
  external num get timeDown;
  external set timeDown(num v);

  /// The timestamp when the button was last released.
  external num get timeUp;
  external set timeUp(num v);

  /// Button value. Mainly useful for checking analog buttons (like shoulder triggers) on Gamepads.
  external num get value;
  external set value(num v);

  /// Destroys this DeviceButton, this disposes of the onDown, onUp and onFloat signals
  /// and clears the parent and game references.
  external void destroy();

  /// Returns the "just pressed" state of this button.
  /// Just pressed is considered true if the button was pressed down within the duration given (default 250ms).
  external bool justPressed([num duration]);

  /// Returns the "just released" state of this button.
  /// Just released is considered as being true if the button was released within the duration given (default 250ms).
  external bool justReleased([num duration]);
  external void processButtonDown(num value);
  external void processButtonFloat(num value);
  external void processButtonUp(num value);

  /// Resets this DeviceButton, changing it to an isUp state and resetting the duration and repeats counters.
  external void reset();
}

// Module Easing
@JS("Phaser.Easing.Default")
external Function get Default;
@JS("Phaser.Easing.Default")
external set Default(Function v);
@JS("Phaser.Easing.Power0")
external Function get Power0;
@JS("Phaser.Easing.Power0")
external set Power0(Function v);
@JS("Phaser.Easing.Power1")
external Function get Power1;
@JS("Phaser.Easing.Power1")
external set Power1(Function v);
@JS("Phaser.Easing.power2")
external Function get power2;
@JS("Phaser.Easing.power2")
external set power2(Function v);
@JS("Phaser.Easing.power3")
external Function get power3;
@JS("Phaser.Easing.power3")
external set power3(Function v);
@JS("Phaser.Easing.power4")
external Function get power4;
@JS("Phaser.Easing.power4")
external set power4(Function v);

/// Back easing.
@JS("Phaser.Easing.Back")
class Back {
  // @Ignore
  Back.fakeConstructor$();

  /// Back ease-in.
  external static num In(num k);

  /// Back ease-out.
  external static num Out(num k);

  /// Back ease-in/out.
  external static num InOut(num k);
}

/// Bounce easing.
@JS("Phaser.Easing.Bounce")
class Bounce {
  // @Ignore
  Bounce.fakeConstructor$();

  /// Bounce ease-in.
  external static num In(num k);

  /// Bounce ease-out.
  external static num Out(num k);

  /// Bounce ease-in/out.
  external static num InOut(num k);
}

/// Circular easing.
@JS("Phaser.Easing.Circular")
class Circular {
  // @Ignore
  Circular.fakeConstructor$();

  /// Circular ease-in.
  external static num In(num k);

  /// Circular ease-out.
  external static num Out(num k);

  /// Circular ease-in/out.
  external static num InOut(num k);
}

/// Cubic easing.
@JS("Phaser.Easing.Cubic")
class Cubic {
  // @Ignore
  Cubic.fakeConstructor$();

  /// Cubic ease-in.
  external static num In(num k);

  /// Cubic ease-out.
  external static num Out(num k);

  /// Cubic ease-in/out.
  external static num InOut(num k);
}

/// Elastic easing.
@JS("Phaser.Easing.Elastic")
class Elastic {
  // @Ignore
  Elastic.fakeConstructor$();

  /// Elastic ease-in.
  external static num In(num k);

  /// Elastic ease-out.
  external static num Out(num k);

  /// Elastic ease-in/out.
  external static num InOut(num k);
}

/// Exponential easing.
@JS("Phaser.Easing.Exponential")
class Exponential {
  // @Ignore
  Exponential.fakeConstructor$();

  /// Exponential ease-in.
  external static num In(num k);

  /// Exponential ease-out.
  external static num Out(num k);

  /// Exponential ease-in/out.
  external static num InOut(num k);
}

/// Linear easing.
@JS("Phaser.Easing.Linear")
class Linear {
  // @Ignore
  Linear.fakeConstructor$();

  /// Linear Easing (no variation).
  external static num None(num k);
}

/// Quadratic easing.
@JS("Phaser.Easing.Quadratic")
class Quadratic {
  // @Ignore
  Quadratic.fakeConstructor$();

  /// Ease-in.
  external static num In(num k);

  /// Ease-out.
  external static num Out(num k);

  /// Ease-in/out.
  external static num InOut(num k);
}

/// Quartic easing.
@JS("Phaser.Easing.Quartic")
class Quartic {
  // @Ignore
  Quartic.fakeConstructor$();

  /// Quartic ease-in.
  external static num In(num k);

  /// Quartic ease-out.
  external static num Out(num k);

  /// Quartic ease-in/out.
  external static num InOut(num k);
}

/// Quintic easing.
@JS("Phaser.Easing.Quintic")
class Quintic {
  // @Ignore
  Quintic.fakeConstructor$();

  /// Quintic ease-in.
  external static num In(num k);

  /// Quintic ease-out.
  external static num Out(num k);

  /// Quintic ease-in/out.
  external static num InOut(num k);
}

/// Sinusoidal easing.
@JS("Phaser.Easing.Sinusoidal")
class Sinusoidal {
  // @Ignore
  Sinusoidal.fakeConstructor$();

  /// Sinusoidal ease-in.
  external static num In(num k);

  /// Sinusoidal ease-out.
  external static num Out(num k);

  /// Sinusoidal ease-in/out.
  external static num InOut(num k);
}

// End module Easing
/// Creates a Ellipse object. A curve on a plane surrounding two focal points.
@JS("Phaser.Ellipse")
class Ellipse {
  // @Ignore
  Ellipse.fakeConstructor$();

  /// Creates a Ellipse object. A curve on a plane surrounding two focal points.
  external factory Ellipse([num x, num y, num width, num height]);

  /// The sum of the y and height properties. Changing the bottom property of an Ellipse doesn't adjust the y property, but does change the height. Gets or sets the bottom of the ellipse.
  external num get bottom;
  external set bottom(num v);

  /// Determines whether or not this Ellipse object is empty. Will return a value of true if the Ellipse objects dimensions are less than or equal to 0; otherwise false.
  /// If set to true it will reset all of the Ellipse objects properties to 0. An Ellipse object is empty if its width or height is less than or equal to 0. Gets or sets the empty state of the ellipse.
  external bool get empty;
  external set empty(bool v);

  /// The overall height of this ellipse.
  external num get height;
  external set height(num v);

  /// The left coordinate of the Ellipse. The same as the X coordinate.
  external num get left;
  external set left(num v);

  /// The x coordinate of the rightmost point of the Ellipse. Changing the right property of an Ellipse object has no effect on the x property, but does adjust the width. Gets or sets the value of the rightmost point of the ellipse.
  external num get right;
  external set right(num v);

  /// The top of the Ellipse. The same as its y property. Gets or sets the top of the ellipse.
  external num get top;
  external set top(num v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// The overall width of this ellipse.
  external num get width;
  external set width(num v);

  /// The X coordinate of the upper-left corner of the framing rectangle of this ellipse.
  external num get x;
  external set x(num v);

  /// The Y coordinate of the upper-left corner of the framing rectangle of this ellipse.
  external num get y;
  external set y(num v);
  external static bool constains(Ellipse a, num x, num y);

  /// Returns a new Ellipse object with the same values for the x, y, width, and height properties as this Ellipse object.
  external Ellipse clone(Ellipse output);

  /// Return true if the given x/y coordinates are within this Ellipse object.
  external bool contains(num x, num y);

  /// Copies the x, y, width and height properties from any given object to this Ellipse.
  external Ellipse copyFrom(dynamic source);

  /// Copies the x, y, width and height properties from this Ellipse to any given object.
  external dynamic copyTo(dynamic dest);

  /// Returns the framing rectangle of the ellipse as a Phaser.Rectangle object.
  external Rectangle getBounds();

  /// Returns a uniformly distributed random point from anywhere within this Ellipse.
  /// If no object is provided a new Phaser.Point object will be created. In high performance areas avoid this by re-using an existing object.
  external Point random([Point out]);

  /// Sets the members of the Ellipse to the specified values.
  external Ellipse setTo(num x, num y, num width, num height);

  /// Returns a string representation of this object.
  external String toString();
}

/// The Events component is a collection of events fired by the parent Game Object.
/// Phaser uses what are known as 'Signals' for all event handling. All of the events in
/// this class are signals you can subscribe to, much in the same way you'd "listen" for
/// an event.
/// For example to tell when a Sprite has been added to a new group, you can bind a function
/// to the [Phaser.Events#onAddedToGroup onAddedToGroup] signal:
/// `sprite.events.onAddedToGroup.add(yourFunction, this);`
/// Where `yourFunction` is the function you want called when this event occurs.
/// For more details about how signals work please see the [Phaser.Signal] class.
/// The Input-related events will only be dispatched if the Sprite has had [Phaser.Component.InputEnabled#inputEnabled inputEnabled] set to `true`
/// and the Animation-related events only apply to game objects with animations like [Phaser.Sprite].
@JS("Phaser.Events")
class Events {
  // @Ignore
  Events.fakeConstructor$();

  /// The Events component is a collection of events fired by the parent Game Object.
  /// Phaser uses what are known as 'Signals' for all event handling. All of the events in
  /// this class are signals you can subscribe to, much in the same way you'd "listen" for
  /// an event.
  /// For example to tell when a Sprite has been added to a new group, you can bind a function
  /// to the [Phaser.Events#onAddedToGroup onAddedToGroup] signal:
  /// `sprite.events.onAddedToGroup.add(yourFunction, this);`
  /// Where `yourFunction` is the function you want called when this event occurs.
  /// For more details about how signals work please see the [Phaser.Signal] class.
  /// The Input-related events will only be dispatched if the Sprite has had [Phaser.Component.InputEnabled#inputEnabled inputEnabled] set to `true`
  /// and the Animation-related events only apply to game objects with animations like [Phaser.Sprite].
  external factory Events(Sprite sprite);

  /// The Sprite that owns these events.
  external Sprite get parent;
  external set parent(Sprite v);

  /// This signal is dispatched when this Game Object is added to a new [Phaser.Group Group].
  /// It is sent two arguments:
  /// - {any} The Game Object that was added to the Group.
  /// - {Phaser.Group} The Group it was added to.
  external Signal get onAddedToGroup;
  external set onAddedToGroup(Signal v);

  /// This signal is dispatched when the Game Object is removed from a [Phaser.Group Group].
  /// It is sent two arguments:
  /// - {any} The Game Object that was removed from the Group.
  /// - {Phaser.Group} The Group it was removed from.
  external Signal get onRemovedFromGroup;
  external set onRemovedFromGroup(Signal v);
  external Signal get onRemovedFromWorld;
  external set onRemovedFromWorld(Signal v);

  /// This signal is dispatched when the Game Object is killed.
  /// This happens when [Phaser.Sprite#kill Sprite.kill()] is called.
  /// Please understand the difference between [Phaser.Sprite#kill kill] and [Phaser.Sprite#destroy destroy] by looking at their respective methods.
  /// It is sent one argument:
  /// - {any} The Game Object that was killed.
  external Signal get onKilled;
  external set onKilled(Signal v);

  /// This signal is dispatched when the Game Object is revived from a previously killed state.
  /// This happens when [Phaser.Sprite#revive Sprite.revive()] is called.
  /// It is sent one argument:
  /// - {any} The Game Object that was revived.
  external Signal get onRevived;
  external set onRevived(Signal v);

  /// This signal is dispatched when the Game Object leaves the Phaser.World [Phaser.World#bounds bounds].
  /// This signal is only if [Phaser.Sprite#checkWorldBounds Sprite.checkWorldBounds] is set to `true`.
  /// It is sent one argument:
  /// - {any} The Game Object that left the World bounds.
  external Signal get onOutOfBounds;
  external set onOutOfBounds(Signal v);

  /// This signal is dispatched when the Game Object returns within the Phaser.World [Phaser.World#bounds bounds], having previously been outside of them.
  /// This signal is only if [Phaser.Sprite#checkWorldBounds Sprite.checkWorldBounds] is set to `true`.
  /// It is sent one argument:
  /// - {any} The Game Object that entered the World bounds.
  external Signal get onEnterBounds;
  external set onEnterBounds(Signal v);

  /// This signal is dispatched if the Game Object has [Phaser.Component.InputEnabled#inputEnabled inputEnabled] set to `true`,
  /// and receives an over event from a [Phaser.Pointer].
  /// It is sent two arguments:
  /// - {any} The Game Object that received the event.
  /// - {Phaser.Pointer} The Phaser.Pointer object that caused the event.
  external Signal get onInputOver;
  external set onInputOver(Signal v);

  /// This signal is dispatched if the Game Object has [Phaser.Component.InputEnabled#inputEnabled inputEnabled] set to `true`,
  /// and receives an out event from a [Phaser.Pointer], which was previously over it.
  /// It is sent two arguments:
  /// - {any} The Game Object that received the event.
  /// - {Phaser.Pointer} The Phaser.Pointer object that caused the event.
  external Signal get onInputOut;
  external set onInputOut(Signal v);

  /// This signal is dispatched if the Game Object has [Phaser.Component.InputEnabled#inputEnabled inputEnabled] set to `true`,
  /// and receives a down event from a [Phaser.Pointer]. This effectively means the Pointer has been
  /// pressed down (but not yet released) on the Game Object.
  /// It is sent two arguments:
  /// - {any} The Game Object that received the event.
  /// - {Phaser.Pointer} The Phaser.Pointer object that caused the event.
  external Signal get onInputDown;
  external set onInputDown(Signal v);

  /// This signal is dispatched if the Game Object has [Phaser.Component.InputEnabled#inputEnabled inputEnabled] set to `true`,
  /// and receives an up event from a [Phaser.Pointer]. This effectively means the Pointer had been
  /// pressed down, and was then released on the Game Object.
  /// It is sent three arguments:
  /// - {any} The Game Object that received the event.
  /// - {Phaser.Pointer} The Phaser.Pointer object that caused the event.
  /// - {boolean} isOver - Is the Pointer still over the Game Object?
  external Signal get onInputUp;
  external set onInputUp(Signal v);

  /// This signal is dispatched when the Game Object is destroyed.
  /// This happens when [Phaser.Sprite#destroy Sprite.destroy()] is called, or [Phaser.Group#destroy Group.destroy()] with `destroyChildren` set to true.
  /// It is sent one argument:
  /// - {any} The Game Object that was destroyed.
  external Signal get onDestroy;
  external set onDestroy(Signal v);

  /// This signal is dispatched if the Game Object has been [Phaser.Component.InputEnabled#inputEnabled inputEnabled] and [Phaser.InputHandler#enableDrag enableDrag] has been set.
  /// It is sent when a [Phaser.Pointer] starts to drag the Game Object, taking into consideration the various
  /// drag limitations that may be set.
  /// It is sent four arguments:
  /// - {any} The Game Object that received the event.
  /// - {Phaser.Pointer} The Phaser.Pointer object that caused the event.
  /// - {number} The x coordinate that the drag started from.
  /// - {number} The y coordinate that the drag started from.
  external Signal get onDragStart;
  external set onDragStart(Signal v);

  /// This signal is dispatched if the Game Object has been [Phaser.Component.InputEnabled#inputEnabled inputEnabled] and [Phaser.InputHandler#enableDrag enableDrag] has been set.
  /// It is sent when a [Phaser.Pointer] stops dragging the Game Object.
  /// It is sent two arguments:
  /// - {any} The Game Object that received the event.
  /// - {Phaser.Pointer} The Phaser.Pointer object that caused the event.
  external Signal get onDragStop;
  external set onDragStop(Signal v);

  /// This signal is dispatched if the Game Object has been [Phaser.Component.InputEnabled#inputEnabled inputEnabled] and [Phaser.InputHandler#enableDrag enableDrag] has been set.
  /// It is sent when a [Phaser.Pointer] is actively dragging the Game Object.
  /// Be warned: This is a high volume Signal. Be careful what you bind to it.
  /// It is sent six arguments:
  /// - {any} The Game Object that received the event.
  /// - {Phaser.Pointer} The Phaser.Pointer object that caused the event.
  /// - {number} The new x coordinate of the Game Object.
  /// - {number} The new y coordinate of the Game Object.
  /// - {Phaser.Point} A Point object that contains the point the Game Object was snapped to, if `snapOnDrag` has been enabled.
  /// - {boolean} The `fromStart` boolean, indicates if this is the first update immediately after the drag has started.
  external Signal get onDragUpdate;
  external set onDragUpdate(Signal v);

  /// This signal is dispatched if the Game Object has the [Phaser.AnimationManager AnimationManager] component,
  /// and an Animation has been played.
  /// You can also listen to [Phaser.Animation#onStart] rather than via the Game Objects events.
  /// It is sent two arguments:
  /// - {any} The Game Object that received the event.
  /// - {Phaser.Animation} The Phaser.Animation that was started.
  external Signal get onAnimationStart;
  external set onAnimationStart(Signal v);

  /// This signal is dispatched if the Game Object has the [Phaser.AnimationManager AnimationManager] component,
  /// and an Animation has been stopped (via [Phaser.AnimationManager#stop animation.stop()] and the `dispatchComplete` argument has been set.
  /// You can also listen to [Phaser.Animation#onComplete] rather than via the Game Objects events.
  /// It is sent two arguments:
  /// - {any} The Game Object that received the event.
  /// - {Phaser.Animation} The Phaser.Animation that was stopped.
  external Signal get onAnimationComplete;
  external set onAnimationComplete(Signal v);

  /// This signal is dispatched if the Game Object has the [Phaser.AnimationManager AnimationManager] component,
  /// and an Animation has looped playback.
  /// You can also listen to [Phaser.Animation#onLoop] rather than via the Game Objects events.
  /// It is sent two arguments:
  /// - {any} The Game Object that received the event.
  /// - {Phaser.Animation} The Phaser.Animation that looped.
  external Signal get onAnimationLoop;
  external set onAnimationLoop(Signal v);

  /// Removes all events.
  external void destroy();
}

/// This is a base Filter class to use for any Phaser filter development.
/// If you want to make a custom filter, this should be your base class.
/// The default uniforms, types and values for all Filters are:
/// ```javascript
/// resolution: { type: '2f', value: { x: 256, y: 256 }}
/// time: { type: '1f', value: 0 }
/// mouse: { type: '2f', value: { x: 0.0, y: 0.0 } }
/// date: { type: '4fv', value: [ d.getFullYear(),  d.getMonth(),  d.getDate(), d.getHours() *60 * 60 + d.getMinutes() * 60 + d.getSeconds() ] }
/// sampleRate: { type: '1f', value: 44100.0 }
/// iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: true } }
/// iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: true } }
/// iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: true } }
/// iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: true } }
/// ```
/// The vast majority of filters (including all of those that ship with Phaser) use fragment shaders, and
/// therefore only work in WebGL and are not supported by Canvas at all.
@JS("Phaser.Filter")
class Filter extends AbstractFilter {
  // @Ignore
  Filter.fakeConstructor$() : super.fakeConstructor$();

  /// This is a base Filter class to use for any Phaser filter development.
  /// If you want to make a custom filter, this should be your base class.
  /// The default uniforms, types and values for all Filters are:
  /// ```javascript
  /// resolution: { type: '2f', value: { x: 256, y: 256 }}
  /// time: { type: '1f', value: 0 }
  /// mouse: { type: '2f', value: { x: 0.0, y: 0.0 } }
  /// date: { type: '4fv', value: [ d.getFullYear(),  d.getMonth(),  d.getDate(), d.getHours() *60 * 60 + d.getMinutes() * 60 + d.getSeconds() ] }
  /// sampleRate: { type: '1f', value: 44100.0 }
  /// iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: true } }
  /// iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: true } }
  /// iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: true } }
  /// iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: true } }
  /// ```
  /// The vast majority of filters (including all of those that ship with Phaser) use fragment shaders, and
  /// therefore only work in WebGL and are not supported by Canvas at all.
  external factory Filter(
      Game game, dynamic uniforms, dynamic /*String|List<String>*/ fragmentSrc);

  /// Internal PIXI var.
  /// Default: true
  external bool get dirty;
  external set dirty(bool v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// The height (resolution uniform)
  external num get height;
  external set height(num v);

  /// The fragment shader code.
  external dynamic /*String|List<String>*/ get fragmentSrc;
  external set fragmentSrc(dynamic /*String|List<String>*/ v);

  /// Internal PIXI var.
  external num get padding;
  external set padding(num v);

  /// The previous position of the pointer (we don't update the uniform if the same)
  external PhaserPoint get prevPoint;
  external set prevPoint(Point v);

  /// The const type of this object, either Phaser.WEBGL_FILTER or Phaser.CANVAS_FILTER.
  external num get type;
  external set type(num v);

  /// Default uniform mappings. Compatible with ShaderToy and GLSLSandbox.
  external dynamic get uniforms;
  external set uniforms(dynamic v);

  /// The width (resolution uniform)
  external num get width;
  external set width(num v);

  /// Creates a new Phaser.Image object using a blank texture and assigns
  /// this Filter to it. The image is then added to the world.
  /// If you don't provide width and height values then Filter.width and Filter.height are used.
  /// If you do provide width and height values then this filter will be resized to match those
  /// values.
  external Image addToWorld(
      [num x, num y, num width, num height, num anchorX, num anchorY]);
  external void apply(Framebuffer frameBuffer);

  /// Clear down this Filter and null out references to game.
  external void destroy();

  /* REMOVED BECAUSE IT CAUSES MANY ANALYSIS ERRORS
  /// This should be over-ridden. Will receive a variable number of arguments.
  external void init(
      [dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);
      */

  /// Set the resolution uniforms on the filter.
  external void setResolution(num width, num height);

  /// Syncs the uniforms between the class object and the shaders.
  external void syncUniforms();

  /// Updates the filter.
  external void update([Pointer pointer]);
}

// Module Filter
@JS("Phaser.Filter.BinarySerpents")
class BinarySerpents extends Filter {
  // @Ignore
  BinarySerpents.fakeConstructor$() : super.fakeConstructor$();
  external factory BinarySerpents(Game game, num width, num height,
      [num march, num maxDistance]);
  external num get fog;
  external set fog(num v);
}

@JS("Phaser.Filter.BlurX")
class BlurX extends Filter {
  // @Ignore
  BlurX.fakeConstructor$() : super.fakeConstructor$();
  external num get blur;
  external set blur(num v);
}

@JS("Phaser.Filter.BlurY")
class BlurY extends Filter {
  // @Ignore
  BlurY.fakeConstructor$() : super.fakeConstructor$();
  external num get blur;
  external set blur(num v);
}

@JS("Phaser.Filter.CausticLight")
class CausticLight extends Filter {
  // @Ignore
  CausticLight.fakeConstructor$() : super.fakeConstructor$();
  external factory CausticLight(Game game, num width, num height,
      [num divisor]);
  external void init(num width, num height, [num divisor]);
}

@JS("Phaser.Filter.CheckerWave")
class CheckerWave extends Filter {
  // @Ignore
  CheckerWave.fakeConstructor$() : super.fakeConstructor$();
  external factory CheckerWave(Game game, num width, num height);
  external num get alpha;
  external set alpha(num v);
  external num get cameraX;
  external set cameraX(num v);
  external num get cameraY;
  external set cameraY(num v);
  external num get cameraZ;
  external set cameraZ(num v);
  external void init(num width, num height);
  external void setColor1(num red, num green, num blue);
  external void setColor2(num red, num green, num blue);
}

@JS("Phaser.Filter.ColorBars")
class ColorBars extends Filter {
  // @Ignore
  ColorBars.fakeConstructor$() : super.fakeConstructor$();
  external factory ColorBars(Game game, num width, num height);
  external num get alpha;
  external set alpha(num v);
  external void init(num width, num height);
}

@JS("Phaser.Filter.Fire")
class Fire extends Filter {
  // @Ignore
  Fire.fakeConstructor$() : super.fakeConstructor$();
  external factory Fire(num width, num height, [num alpha, num shift]);
  external num get alpha;
  external set alpha(num v);
  external num get shift;
  external set shift(num v);
  external num get speed;
  external set speed(num v);
  external void init(num width, num height, [num alpha, num shift]);
}

@JS("Phaser.Filter.Gray")
class Gray extends Filter {
  // @Ignore
  Gray.fakeConstructor$() : super.fakeConstructor$();
  external num get gray;
  external set gray(num v);
}

@JS("Phaser.Filter.HueRotate")
class HueRotate extends Filter {
  // @Ignore
  HueRotate.fakeConstructor$() : super.fakeConstructor$();
  external factory HueRotate(Game game, num width, num height, dynamic texture);
  external num get alpha;
  external set alpha(num v);
  external void init(num width, num height, dynamic texture);
}

@JS("Phaser.Filter.LazerBeam")
class LazerBeam extends Filter {
  // @Ignore
  LazerBeam.fakeConstructor$() : super.fakeConstructor$();
  external void init(num width, num height, [num divisor]);
}

@JS("Phaser.Filter.LightBeam")
class LightBeam extends Filter {
  // @Ignore
  LightBeam.fakeConstructor$() : super.fakeConstructor$();
  external factory LightBeam(Game game, num width, num height);
  external num get alpha;
  external set alpha(num v);
  external num get blue;
  external set blue(num v);
  external num get green;
  external set green(num v);
  external num get red;
  external set red(num v);
  external num get thickness;
  external set thickness(num v);
  external num get speed;
  external set speed(num v);
  external void init(num width, num height);
}

@JS("Phaser.Filter.Marble")
class Marble extends Filter {
  // @Ignore
  Marble.fakeConstructor$() : super.fakeConstructor$();
  external factory Marble(Game game, num width, num height,
      [num speed, num intensity]);
  external num get alpha;
  external set alpha(num v);
  external num get intensity;
  external set intensity(num v);
  external num get speed;
  external set speed(num v);
  external void init(num width, num height, [num speed, num intensity]);
}

@JS("Phaser.Filter.Pixelate")
class Pixelate extends Filter {
  // @Ignore
  Pixelate.fakeConstructor$() : super.fakeConstructor$();
  external num get size;
  external set size(num v);
  external num get sizeX;
  external set sizeX(num v);
  external num get sizeY;
  external set sizeY(num v);
}

@JS("Phaser.Filter.Plasma")
class Plasma extends Filter {
  // @Ignore
  Plasma.fakeConstructor$() : super.fakeConstructor$();
  external factory Plasma(Game game, num width, num height,
      [num alpha, num size]);
  external num get alpha;
  external set alpha(num v);
  external num get blueShift;
  external set blueShift(num v);
  external num get greenShift;
  external set greenShift(num v);
  external num get redShift;
  external set redShift(num v);
  external num get size;
  external set size(num v);
  external void init(num width, num height, [num alpha, num size]);
}

@JS("Phaser.Filter.SampleFilter")
class SampleFilter extends Filter {
  // @Ignore
  SampleFilter.fakeConstructor$() : super.fakeConstructor$();
  external factory SampleFilter(Game game, num width, num height,
      [num divisor]);
  external void init(num width, num height, [num divisor]);
}

@JS("Phaser.Filter.Tunnel")
class Tunnel extends Filter {
  // @Ignore
  Tunnel.fakeConstructor$() : super.fakeConstructor$();
  external factory Tunnel(Game game, num width, num height, dynamic texture);
  external num get alpha;
  external set alpha(num v);
  external num get origin;
  external set origin(num v);
  external void init(num width, num height, dynamic texture);
}

// End module Filter
/// WARNING: This is an EXPERIMENTAL class. The API will change significantly in the coming versions and is incomplete.
/// Please try to avoid using in production games with a long time to build.
/// This is also why the documentation is incomplete.
/// FlexGrid is a a responsive grid manager that works in conjunction with the ScaleManager RESIZE scaling mode and FlexLayers
/// to provide for game object positioning in a responsive manner.
@JS("Phaser.FlexGrid")
class FlexGrid {
  // @Ignore
  FlexGrid.fakeConstructor$();

  /// WARNING: This is an EXPERIMENTAL class. The API will change significantly in the coming versions and is incomplete.
  /// Please try to avoid using in production games with a long time to build.
  /// This is also why the documentation is incomplete.
  /// FlexGrid is a a responsive grid manager that works in conjunction with the ScaleManager RESIZE scaling mode and FlexLayers
  /// to provide for game object positioning in a responsive manner.
  external factory FlexGrid(ScaleManager manager, num width, num height);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// A reference to the ScaleManager.
  external ScaleManager get manager;
  external set manager(ScaleManager v);
  external num get width;
  external set width(num v);
  external num get height;
  external set height(num v);
  external Rectangle get boundsCustom;
  external set boundsCustom(Rectangle v);
  external Rectangle get boundsFluid;
  external set boundsFluid(Rectangle v);
  external Rectangle get boundsFull;
  external set boundsFull(Rectangle v);
  external Rectangle get boundsNone;
  external set boundsNone(Rectangle v);
  external num get customWidth;
  external set customWidth(num v);
  external num get customHeight;
  external set customHeight(num v);
  external num get customOffsetX;
  external set customOffsetX(num v);
  external num get customOffsetY;
  external set customOffsetY(num v);

  /// -
  external PhaserPoint get positionCustom;
  external set positionCustom(Point v);
  external PhaserPoint get positionFluid;
  external set positionFluid(Point v);
  external PhaserPoint get positionFull;
  external set positionFull(Point v);
  external PhaserPoint get positionNone;
  external set positionNone(Point v);

  /// The scale factor based on the game dimensions vs. the scaled dimensions.
  external PhaserPoint get scaleCustom;
  external set scaleCustom(Point v);
  external PhaserPoint get scaleFluid;
  external set scaleFluid(Point v);
  external PhaserPoint get scaleFluidInversed;
  external set scaleFluidInversed(Point v);
  external PhaserPoint get scaleFull;
  external set scaleFull(Point v);
  external PhaserPoint get scaleNone;
  external set scaleNone(Point v);
  external num get ratioH;
  external set ratioH(num v);
  external num get ratioV;
  external set ratioV(num v);
  external num get multiplier;
  external set multiplier(num v);

  /// A custom layer is centered on the game and maintains its aspect ratio as it scales up and down.
  external FlexLayer createCustomLayer(num width, num height,
      [List<DisplayObject> children, bool addToWorld]);

  /// A fluid layer is centered on the game and maintains its aspect ratio as it scales up and down.
  external FlexLayer createFluidLayer(List<DisplayObject> children);

  /// A full layer is placed at 0,0 and extends to the full size of the game. Children are scaled according to the fluid ratios.
  external FlexLayer createFullLayer(List<DisplayObject> children);

  /// A fixed layer is centered on the game and is the size of the required dimensions and is never scaled.
  external FlexLayer createFixedLayer(List<DisplayObject> children);

  /// Call in the render function to output the bounds rects.
  external void debug();

  /// Fits a sprites width to the bounds.
  external void fitSprite(Sprite sprite);

  /// Called when the game container changes dimensions.
  external void onResize(num width, num height);

  /// Updates all internal vars such as the bounds and scale values.
  external void refresh();

  /// Resets the layer children references
  external void reset();

  /// Sets the core game size. This resets the w/h parameters and bounds.
  external void setSize(num width, num height);
}

/// WARNING: This is an EXPERIMENTAL class. The API will change significantly in the coming versions and is incomplete.
/// Please try to avoid using in production games with a long time to build.
/// This is also why the documentation is incomplete.
/// A responsive grid layer.
@JS("Phaser.FlexLayer")
class FlexLayer extends Group {
  // @Ignore
  FlexLayer.fakeConstructor$() : super.fakeConstructor$();

  /// WARNING: This is an EXPERIMENTAL class. The API will change significantly in the coming versions and is incomplete.
  /// Please try to avoid using in production games with a long time to build.
  /// This is also why the documentation is incomplete.
  /// A responsive grid layer.
  external factory FlexLayer(
      ScaleManager manager, Point position, Rectangle bounds, Point scale);

  /// A reference to the FlexGrid that owns this layer.
  external FlexGrid get grid;
  external set grid(FlexGrid v);

  /// A reference to the ScaleManager.
  external ScaleManager get manager;
  external set manager(ScaleManager v);
  external PhaserPoint get bottomLeft;
  external set bottomLeft(Point v);
  external PhaserPoint get bottomMiddle;
  external set bottomMiddle(Point v);
  external PhaserPoint get bottomRight;
  external set bottomRight(Point v);
  external Rectangle get bounds;
  external set bounds(Rectangle v);

  /// Should the FlexLayer remain through a State swap?
  external bool get persist;
  external set persist(bool v);
  external PhaserPoint get position;
  external set position(Point v);
  external PhaserPoint get scale;
  external set scale(Point v);
  external PhaserPoint get topLeft;
  external set topLeft(Point v);
  external PhaserPoint get topMiddle;
  external set topMiddle(Point v);
  external PhaserPoint get topRight;
  external set topRight(Point v);

  /// Debug.
  external void debug();

  /// Resize.
  external void resize();
}

/// A Frame is a single frame of an animation and is part of a FrameData collection.
@JS("Phaser.Frame")
class Frame {
  // @Ignore
  Frame.fakeConstructor$();

  /// A Frame is a single frame of an animation and is part of a FrameData collection.
  external factory Frame(
      num index, num x, num y, num width, num height, String name);

  /// The bottom of the frame (y + height).
  external num get bottom;
  external set bottom(num v);

  /// Center X position within the image to cut from.
  external num get centerX;
  external set centerX(num v);

  /// Center Y position within the image to cut from.
  external num get centerY;
  external set centerY(num v);

  /// The distance from the top left to the bottom-right of this Frame.
  external num get distance;
  external set distance(num v);

  /// Height of the frame.
  external num get height;
  external set height(num v);

  /// The index of this Frame within the FrameData set it is being added to.
  external num get index;
  external set index(num v);

  /// Useful for Texture Atlas files (is set to the filename value).
  external String get name;
  external set name(String v);

  /// The right of the Frame (x + width).
  external num get right;
  external set right(num v);

  /// Is the frame rotated in the source texture?
  external bool get rotated;
  external set rotated(bool v);

  /// Height of the original sprite before it was trimmed.
  external num get sourceSizeH;
  external set sourceSizeH(num v);

  /// Width of the original sprite before it was trimmed.
  external num get sourceSizeW;
  external set sourceSizeW(num v);

  /// Height of the trimmed sprite.
  external num get spriteSourceSizeH;
  external set spriteSourceSizeH(num v);

  /// Width of the trimmed sprite.
  external num get spriteSourceSizeW;
  external set spriteSourceSizeW(num v);

  /// X position of the trimmed sprite inside original sprite.
  external num get spriteSourceSizeX;
  external set spriteSourceSizeX(num v);

  /// Y position of the trimmed sprite inside original sprite.
  external num get spriteSourceSizeY;
  external set spriteSourceSizeY(num v);

  /// Was it trimmed when packed?
  external bool get trimmed;
  external set trimmed(bool v);
  external String get uuid;
  external set uuid(String v);

  /// Width of the frame.
  external num get width;
  external set width(num v);

  /// X position within the image to cut from.
  external num get x;
  external set x(num v);

  /// Y position within the image to cut from.
  external num get y;
  external set y(num v);

  /// Clones this Frame into a new Phaser.Frame object and returns it.
  /// Note that all properties are cloned, including the name and index.
  external Frame clone();

  /// Returns a Rectangle set to the dimensions of this Frame.
  external Rectangle getRect([Rectangle out]);

  /// If the frame was trimmed when added to the Texture Atlas this records the trim and source data.
  external void setTrim(bool trimmed, num actualWidth, num actualHeight,
      num destX, num destY, num destWidth, num destHeight);

  /// Adjusts of all the Frame properties based on the given width and height values.
  external void resize(num width, num height);
}

/// FrameData is a container for Frame objects, which are the internal representation of animation data in Phaser.
@JS("Phaser.FrameData")
class FrameData {
  // @Ignore
  FrameData.fakeConstructor$();

  /// The total number of frames in this FrameData set.
  external num get total;
  external set total(num v);

  /// Adds a new Frame to this FrameData collection. Typically called by the Animation.Parser and not directly.
  external Frame addFrame(Frame frame);

  /// Check if there is a Frame with the given name.
  external bool checkFrameName(String name);

  /// Makes a copy of this FrameData including copies (not references) to all of the Frames it contains.
  external FrameData clone();

  /// Get a Frame by its numerical index.
  external Frame getFrame(num index);

  /// Get a Frame by its frame name.
  external Frame getFrameByName(String name);

  /// Returns all of the Frame indexes in this FrameData set.
  /// The frames indexes are returned in the output array, or if none is provided in a new Array object.
  external List<num> getFrameIndexes(
      [List<num> frames, bool useNumericIndex, List<num> output]);

  /// Returns a range of frames based on the given start and end frame indexes and returns them in an Array.
  external List<Frame> getFrameRange(num start, num end, List<Frame> output);

  /// Returns all of the Frames in this FrameData set where the frame index is found in the input array.
  /// The frames are returned in the output array, or if none is provided in a new Array object.
  external List<Frame> getFrames(
      [List<num> frames, bool useNumericIndex, List<Frame> output]);
}

@anonymous
@JS()
abstract class IGameConfig {
  external String get backgroundColor;
  external set backgroundColor(String v);
  external CanvasElement get canvas;
  external set canvas(CanvasElement v);
  external String get canvasId;
  external set canvasId(String v);
  external String get canvasStyle;
  external set canvasStyle(String v);
  external bool get disableVisibilityChange;
  external set disableVisibilityChange(bool v);
  external num get fullScreenScaleMode;
  external set fullScreenScaleMode(num v);
  external bool get antialias;
  external set antialias(bool v);
  external bool get enableDebug;
  external set enableDebug(bool v);
  external bool get forceSetTimeOut;
  external set forceSetTimeOut(bool v);
  external dynamic /*num|String*/ get height;
  external set height(dynamic /*num|String*/ v);
  external bool get multiTexture;
  external set multiTexture(bool v);
  external dynamic /*HtmlElement|String*/ get parent;
  external set parent(dynamic /*HtmlElement|String*/ v);
  external dynamic get physicsConfig;
  external set physicsConfig(dynamic v);
  external bool get preserveDrawingBuffer;
  external set preserveDrawingBuffer(bool v);
  external num get renderer;
  external set renderer(num v);
  external num get resolution;
  external set resolution(num v);
  external num get scaleMode;
  external set scaleMode(num v);
  external num get seed;
  external set seed(num v);
  external dynamic get state;
  external set state(dynamic v);
  external bool get transparent;
  external set transparent(bool v);
  external dynamic /*num|String*/ get width;
  external set width(dynamic /*num|String*/ v);
  external factory IGameConfig(
      {String backgroundColor,
      CanvasElement canvas,
      String canvasId,
      String canvasStyle,
      bool disableVisibilityChange,
      num fullScreenScaleMode,
      bool antialias,
      bool enableDebug,
      bool forceSetTimeOut,
      dynamic /*num|String*/ height,
      bool multiTexture,
      dynamic /*HtmlElement|String*/ parent,
      dynamic physicsConfig,
      bool preserveDrawingBuffer,
      num renderer,
      num resolution,
      num scaleMode,
      num seed,
      dynamic state,
      bool transparent,
      dynamic /*num|String*/ width});
}

/// The Phaser.Game object is the main controller for the entire Phaser game. It is responsible
/// for handling the boot process, parsing the configuration values, creating the renderer,
/// and setting-up all of the Phaser systems, such as physics, sound and input.
/// Once that is complete it will start the default State, and then begin the main game loop.
/// You can access lots of the Phaser systems via the properties on the `game` object. For
/// example `game.renderer` is the Renderer, `game.sound` is the Sound Manager, and so on.
/// Anywhere you can access the `game` property, you can access all of these core systems.
/// For example a Sprite has a `game` property, allowing you to talk to the various parts
/// of Phaser directly, without having to look after your own references.
/// In it's most simplest form, a Phaser game can be created by providing the arguments
/// to the constructor:
/// ```javascript
/// var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create });
/// ```
/// In the example above it is passing in a State object directly. You can also use the State
/// Manager to do this:
/// ```javascript
/// var game = new Phaser.Game(800, 600, Phaser.AUTO);
/// game.state.add('Boot', BasicGame.Boot);
/// game.state.add('Preloader', BasicGame.Preloader);
/// game.state.add('MainMenu', BasicGame.MainMenu);
/// game.state.add('Game', BasicGame.Game);
/// game.state.start('Boot');
/// ```
/// In the example above, 4 States are added to the State Manager, and Phaser is told to
/// start running the `Boot` state when it has finished initializing. There are example
/// project templates you can use in the Phaser GitHub repo, inside the `resources` folder.
/// Instead of specifying arguments you can also pass [GameConfig a single object] instead:
/// ```javascript
/// var config = {
/// width: 800,
/// height: 600,
/// renderer: Phaser.AUTO,
/// antialias: true,
/// multiTexture: true,
/// state: {
/// preload: preload,
/// create: create,
/// update: update
/// }
/// }
/// var game = new Phaser.Game(config);
/// ```
@JS("Phaser.Game")
class Game {
  // @Ignore
  Game.fakeConstructor$();

  /// The Phaser.Game object is the main controller for the entire Phaser game. It is responsible
  /// for handling the boot process, parsing the configuration values, creating the renderer,
  /// and setting-up all of the Phaser systems, such as physics, sound and input.
  /// Once that is complete it will start the default State, and then begin the main game loop.
  /// You can access lots of the Phaser systems via the properties on the `game` object. For
  /// example `game.renderer` is the Renderer, `game.sound` is the Sound Manager, and so on.
  /// Anywhere you can access the `game` property, you can access all of these core systems.
  /// For example a Sprite has a `game` property, allowing you to talk to the various parts
  /// of Phaser directly, without having to look after your own references.
  /// In it's most simplest form, a Phaser game can be created by providing the arguments
  /// to the constructor:
  /// ```javascript
  /// var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create });
  /// ```
  /// In the example above it is passing in a State object directly. You can also use the State
  /// Manager to do this:
  /// ```javascript
  /// var game = new Phaser.Game(800, 600, Phaser.AUTO);
  /// game.state.add('Boot', BasicGame.Boot);
  /// game.state.add('Preloader', BasicGame.Preloader);
  /// game.state.add('MainMenu', BasicGame.MainMenu);
  /// game.state.add('Game', BasicGame.Game);
  /// game.state.start('Boot');
  /// ```
  /// In the example above, 4 States are added to the State Manager, and Phaser is told to
  /// start running the `Boot` state when it has finished initializing. There are example
  /// project templates you can use in the Phaser GitHub repo, inside the `resources` folder.
  /// Instead of specifying arguments you can also pass [GameConfig a single object] instead:
  /// ```javascript
  /// var config = {
  /// width: 800,
  /// height: 600,
  /// renderer: Phaser.AUTO,
  /// antialias: true,
  /// multiTexture: true,
  /// state: {
  /// preload: preload,
  /// create: create,
  /// update: update
  /// }
  /// }
  /// var game = new Phaser.Game(config);
  /// ```
  /*external factory Game([num|String width, num|String height, num renderer, dynamic parent, dynamic state, bool transparent, bool antialias, dynamic physicsConfig]);*/
  /// The Phaser.Game object is the main controller for the entire Phaser game. It is responsible
  /// for handling the boot process, parsing the configuration values, creating the renderer,
  /// and setting-up all of the Phaser systems, such as physics, sound and input.
  /// Once that is complete it will start the default State, and then begin the main game loop.
  /// You can access lots of the Phaser systems via the properties on the `game` object. For
  /// example `game.renderer` is the Renderer, `game.sound` is the Sound Manager, and so on.
  /// Anywhere you can access the `game` property, you can access all of these core systems.
  /// For example a Sprite has a `game` property, allowing you to talk to the various parts
  /// of Phaser directly, without having to look after your own references.
  /// In it's most simplest form, a Phaser game can be created by providing the arguments
  /// to the constructor:
  /// ```javascript
  /// var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create });
  /// ```
  /// In the example above it is passing in a State object directly. You can also use the State
  /// Manager to do this:
  /// ```javascript
  /// var game = new Phaser.Game(800, 600, Phaser.AUTO);
  /// game.state.add('Boot', BasicGame.Boot);
  /// game.state.add('Preloader', BasicGame.Preloader);
  /// game.state.add('MainMenu', BasicGame.MainMenu);
  /// game.state.add('Game', BasicGame.Game);
  /// game.state.start('Boot');
  /// ```
  /// In the example above, 4 States are added to the State Manager, and Phaser is told to
  /// start running the `Boot` state when it has finished initializing. There are example
  /// project templates you can use in the Phaser GitHub repo, inside the `resources` folder.
  /// Instead of specifying arguments you can also pass [GameConfig a single object] instead:
  /// ```javascript
  /// var config = {
  /// width: 800,
  /// height: 600,
  /// renderer: Phaser.AUTO,
  /// antialias: true,
  /// multiTexture: true,
  /// state: {
  /// preload: preload,
  /// create: create,
  /// update: update
  /// }
  /// }
  /// var game = new Phaser.Game(config);
  /// ```
  /*external factory Game(IGameConfig config);*/
  external factory Game(
      [dynamic /*num|String|IGameConfig*/ width_config,
      dynamic /*num|String*/ height,
      num renderer,
      dynamic parent,
      dynamic state,
      bool transparent,
      bool antialias,
      dynamic physicsConfig]);

  /// Reference to the Phaser.GameObjectFactory.
  external GameObjectFactory get add;
  external set add(GameObjectFactory v);

  /// Anti-alias graphics (as set when the Game is created). By default scaled and rotated images are smoothed in Canvas and WebGL; set `antialias` to false to disable this globally. After the game boots, use `game.stage.smoothed` instead.
  /// Default: true
  external bool get antialias;
  external set antialias(bool v);

  /// Reference to the assets cache.
  external Cache get cache;
  external set cache(Cache v);

  /// A handy reference to world.camera.
  external Camera get camera;
  external set camera(Camera v);

  /// A handy reference to renderer.view, the canvas that the game is being rendered in to.
  external CanvasElement get canvas;
  external set canvas(CanvasElement v);

  /// Clear the Canvas each frame before rendering the display list.
  /// You can set this to `false` to gain some performance if your game always contains a background that completely fills the display.
  /// This must be `true` to show any [Phaser.Stage#backgroundColor] set on the Stage.
  /// Default: true
  external bool get clearBeforeRender;
  external set clearBeforeRender(bool v);

  /// The Phaser.Game configuration object.
  external IGameConfig get config;
  external set config(IGameConfig v);

  /// A handy reference to renderer.context (only set for CANVAS games, not WebGL)
  external CanvasRenderingContext2D get context;
  external set context(CanvasRenderingContext2D v);
  external num get count;
  external set count(num v);

  /// The Asset Generator.
  external Create get create;
  external set create(Create v);

  /// A set of useful debug utilities.
  external Debug get debug;
  external set debug(Debug v);

  /// Contains device information and capabilities.
  external Device get device;
  external set device(Device v);

  /// Should the game loop force a logic update, regardless of the delta timer? You can toggle it on the fly.
  external bool get forceSingleUpdate;
  external set forceSingleUpdate(bool v);

  /// If the game is struggling to maintain the desired FPS, this signal will be dispatched.
  /// The desired/chosen FPS should probably be closer to the [Phaser.Time#suggestedFps] value.
  external Signal get fpsProblemNotifier;
  external set fpsProblemNotifier(Signal v);

  /// The current Game Height in pixels.
  /// _Do not modify this property directly:_ use [Phaser.ScaleManager#setGameSize] - e.g. `game.scale.setGameSize(width, height)` - instead.
  /// Default: 600
  external num get height;
  external set height(num v);

  /// Phaser Game ID
  external num get id;
  external set id(num v);

  /// Reference to the input manager
  external Input get input;
  external set input(Input v);

  /// Whether the game engine is booted, aka available.
  external bool get isBooted;
  external set isBooted(bool v);

  /// Is game running or paused?
  external bool get isRunning;
  external set isRunning(bool v);

  /// Reference to the assets loader.
  external Loader get load;
  external set load(Loader v);

  /// If `false` Phaser will automatically render the display list every update. If `true` the render loop will be skipped.
  /// You can toggle this value at run-time to gain exact control over when Phaser renders. This can be useful in certain types of game or application.
  /// Please note that if you don't render the display list then none of the game object transforms will be updated, so use this value carefully.
  external bool get lockRender;
  external set lockRender(bool v);

  /// Reference to the GameObject Creator.
  external GameObjectCreator get make;
  external set make(GameObjectCreator v);

  /// Reference to the math helper.
  external Math get math;
  external set math(Math v);

  /// Reference to the network class.
  external Net get net;
  external set net(Net v);

  /// This event is fired when the game no longer has focus (typically on page hide).
  external Signal get onBlur;
  external set onBlur(Signal v);

  /// This event is fired when the game has focus (typically on page show).
  external Signal get onFocus;
  external set onFocus(Signal v);

  /// This event is fired when the game pauses.
  external Signal get onPause;
  external set onPause(Signal v);

  /// This event is fired when the game resumes from a paused state.
  external Signal get onResume;
  external set onResume(Signal v);

  /// The Game's DOM parent (or name thereof), if any, as set when the game was created. The actual parent can be found in `game.canvas.parentNode`. Setting this has no effect after [Phaser.ScaleManager] is booted.
  external HtmlElement get parent;
  external set parent(HtmlElement v);

  /// The Particle Manager.
  external Particles get particles;
  external set particles(Particles v);

  /// The paused state of the Game. A paused game doesn't update any of its subsystems.
  /// When a game is paused the onPause event is dispatched. When it is resumed the onResume event is dispatched. Gets and sets the paused state of the Game.
  external bool get paused;
  external set paused(bool v);

  /// An internal property used by enableStep, but also useful to query from your own game objects.
  external bool get pendingStep;
  external set pendingStep(bool v);

  /// Reference to the physics manager.
  external Physics get physics;
  external set physics(Physics v);

  /// The Phaser.Physics.World configuration object.
  external dynamic get physicsConfig;
  external set physicsConfig(dynamic v);

  /// Reference to the plugin manager.
  external PluginManager get plugins;
  external set plugins(PluginManager v);

  /// The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.
  external bool get preserveDrawingBuffer;
  external set preserveDrawingBuffer(bool v);

  /// Automatically handles the core game loop via requestAnimationFrame or setTimeout
  external RequestAnimationFrame get raf;
  external set raf(RequestAnimationFrame v);

  /// The Pixi Renderer.
  external dynamic /*CanvasRenderer|WebGLRenderer*/ get renderer;
  external set renderer(dynamic /*CanvasRenderer|WebGLRenderer*/ v);

  /// The Renderer this game will use. Either Phaser.AUTO, Phaser.CANVAS, Phaser.WEBGL, Phaser.WEBGL_MULTI or Phaser.HEADLESS. After the game boots, renderType reflects the renderer in use: AUTO changes to CANVAS or WEBGL and WEBGL_MULTI changes to WEBGL. HEADLESS skips `render` hooks but not `preRender` or `postRender`; set [lockRender] to skip those as well.
  external num get renderType;
  external set renderType(num v);

  /// The resolution of your game, as a ratio of canvas pixels to game pixels. This value is read only, but can be changed at start time it via a game configuration object.
  /// Default: 1
  external num get resolution;
  external set resolution(num v);

  /// Instance of repeatable random data generator helper.
  external RandomDataGenerator get rnd;
  external set rnd(RandomDataGenerator v);

  /// The game scale manager.
  external ScaleManager get scale;
  external set scale(ScaleManager v);
  external BitmapData get scratch;
  external set scratch(BitmapData v);

  /// Reference to the sound manager.
  external SoundManager get sound;
  external set sound(SoundManager v);

  /// Reference to the stage.
  external Stage get stage;
  external set stage(Stage v);

  /// The StateManager.
  external StateManager get state;
  external set state(StateManager v);

  /// When stepping is enabled this contains the current step cycle.
  external num get stepCount;
  external set stepCount(num v);

  /// Enable core loop stepping with Game.enableStep().
  external bool get stepping;
  external set stepping(bool v);

  /// Reference to the core game clock.
  external Time get time;
  external set time(Time v);

  /// Use a transparent canvas background or not.
  external bool get transparent;
  external set transparent(bool v);

  /// Reference to the tween manager.
  external TweenManager get tweens;
  external set tweens(TweenManager v);

  /// The ID of the current/last logic update applied this render frame, starting from 0.
  /// The first update is `currentUpdateID === 0` and the last update is `currentUpdateID === updatesThisFrame.`
  external num get currentUpdateID;
  external set currentUpdateID(num v);

  /// Number of logic updates expected to occur this render frame; will be 1 unless there are catch-ups required (and allowed).
  external num get updatesThisFrame;
  external set updatesThisFrame(num v);

  /// The current Game Width in pixels.
  /// _Do not modify this property directly:_ use [Phaser.ScaleManager#setGameSize] - e.g. `game.scale.setGameSize(width, height)` - instead.
  /// Default: 800
  external num get width;
  external set width(num v);

  /// Reference to the world.
  external World get world;
  external set world(World v);

  /// Initialize engine sub modules and start the game.
  external void boot();

  /// Nukes the entire game from orbit.
  /// Calls destroy on Game.state, Game.sound, Game.scale, Game.stage, Game.input, Game.physics and Game.plugins.
  /// Then sets all of those local handlers to null, destroys the renderer, removes the canvas from the DOM
  /// and resets the PIXI default renderer.
  external void destroy();

  /// Disables core game loop stepping.
  external void disableStep();

  /// Enable core game loop stepping. When enabled you must call game.step() directly (perhaps via a DOM button?)
  /// Calling step will advance the game loop by one frame. This is extremely useful for hard to track down errors!
  external void enableStep();

  /// Called by the Stage visibility handler.
  external void focusGain(dynamic event);

  /// Called by the Stage visibility handler.
  external void focusLoss(dynamic event);

  /// Called by the Stage visibility handler.
  external void gamePaused(dynamic event);

  /// Called by the Stage visibility handler.
  external void gameResumed(dynamic event);

  /// Parses a Game configuration object.
  external void parseConfig(dynamic config);
  external void removeFromDOM(CanvasElement canvas);

  /// Checks if the device is capable of using the requested renderer and sets it up or an alternative if not.
  external void setUpRenderer();

  /// Displays a Phaser version debug header in the console.
  external void showDebugHeader();

  /// When stepping is enabled you must call this function directly (perhaps via a DOM button?) to advance the game loop by one frame.
  /// This is extremely useful to hard to track down errors! Use the internal stepCount property to monitor progress.
  external void step();

  /// The core game loop.
  external void update(num time);

  /// Updates all logic subsystems in Phaser. Called automatically by Game.update.
  external void updateLogic(num timeStep);

  /// Runs the Render cycle.
  /// It starts by calling State.preRender. In here you can do any last minute adjustments of display objects as required.
  /// It then calls the renderer, which renders the entire display list, starting from the Stage object and working down.
  /// It then calls plugin.render on any loaded plugins, in the order in which they were enabled.
  /// After this State.render is called. Any rendering that happens here will take place on-top of the display list.
  /// Finally plugin.postRender is called on any loaded plugins, in the order in which they were enabled.
  /// This method is called automatically by Game.update, you don't need to call it directly.
  /// Should you wish to have fine-grained control over when Phaser renders then use the `Game.lockRender` boolean.
  /// Phaser will only render when this boolean is `false`.
  external void updateRender(num timeStep);
}

/// The GameObjectCreator is a quick way to create common game objects _without_ adding them to the game world.
/// The object creator can be accessed with {@linkcode Phaser.Game#make `game.make`}.
@JS("Phaser.GameObjectCreator")
class GameObjectCreator {
  // @Ignore
  GameObjectCreator.fakeConstructor$();

  /// The GameObjectCreator is a quick way to create common game objects _without_ adding them to the game world.
  /// The object creator can be accessed with {@linkcode Phaser.Game#make `game.make`}.
  external factory GameObjectCreator(Game game);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// A reference to the game world.
  external World get world;
  external set world(World v);

  /// Creates a new Sound object.
  external Sound audio(String key, [num volume, bool loop, bool connect]);

  /// Creates a new AudioSprite object.
  external AudioSprite audioSprite(String key);

  /// Create a BitmpaData object.
  /// A BitmapData object can be manipulated and drawn to like a traditional Canvas object and used to texture Sprites.
  external BitmapData bitmapData(
      [num width, num height, String key, bool addToCache]);

  /// Create a new BitmapText object.
  /// BitmapText objects work by taking a texture file and an XML file that describes the font structure.
  /// It then generates a new Sprite object for each letter of the text, proportionally spaced out and aligned to
  /// match the font structure.
  /// BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
  /// to use Web Fonts. However you trade this flexibility for pure rendering speed. You can also create visually compelling BitmapTexts by
  /// processing the font texture in an image editor first, applying fills and any other effects required.
  /// To create multi-line text insert \r, \n or \r\n escape codes into the text string.
  /// To create a BitmapText data files you can use:
  /// BMFont (Windows, free): http://www.angelcode.com/products/bmfont/
  /// Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner
  /// Littera (Web-based, free): http://kvazars.com/littera/
  external BitmapText bitmapText(num x, num y, String font,
      [String text, num size, String align]);

  /// Creates a new Button object.
  external Button button(
      [num x,
      num y,
      String key,
      Function callback,
      dynamic callbackContext,
      dynamic overFrame,
      dynamic outFrame,
      dynamic downFrame,
      dynamic upFrame]);

  /// Creat a new Emitter.
  /// An Emitter is a lightweight particle emitter. It can be used for one-time explosions or for
  /// continuous effects like rain and fire. All it really does is launch Particle objects out
  /// at set intervals, and fixes their positions and velocities accorindgly.
  external Emitter emitter([num x, num y, num maxParticles]);

  /// A WebGL shader/filter that can be applied to Sprites.
  external Filter filter(dynamic filter,
      [dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Creates a new Graphics object.
  external Graphics graphics([num x, num y]);

  /// A Group is a container for display objects that allows for fast pooling, recycling and collision checks.
  external Group group(
      [dynamic parent,
      String name,
      bool addToStage,
      bool enableBody,
      num physicsBodyType]);

  /// Create a new Image object.
  /// An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
  /// It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
  external Image image(num x, num y, [dynamic key, dynamic frame]);

  /// A dynamic initially blank canvas to which images can be drawn.
  external PhaserRenderTexture renderTexture(
      [num width, num height, dynamic key, bool addToCache]);

  /// Create a new RetroFont object.
  /// A RetroFont can be used as a texture for an Image or Sprite and optionally add it to the Cache.
  /// A RetroFont uses a bitmap which contains fixed with characters for the font set. You use character spacing to define the set.
  /// If you need variable width character support then use a BitmapText object instead. The main difference between a RetroFont and a BitmapText
  /// is that a RetroFont creates a single texture that you can apply to a game object, where-as a BitmapText creates one Sprite object per letter of text.
  /// The texture can be asssigned or one or multiple images/sprites, but note that the text the RetroFont uses will be shared across them all,
  /// i.e. if you need each Image to have different text in it, then you need to create multiple RetroFont objects.
  external RetroFont retroFont(String font, num characterWidth,
      num characterHeight, String chars, num charsPerRow,
      [num xSpacing, num ySpacing, num xOffset, num yOffset]);

  /// Creates a new Rope object.
  external Rope rope(num x, num y, dynamic key,
      [dynamic frame, List<Point> points]);

  /// Creates a new Sound object.
  external Sound sound(String key, [num volume, bool loop, bool connect]);

  /// Create a new Sprite with specific position and sprite sheet key.
  external Sprite sprite(num x, num y, [dynamic key, dynamic frame]);

  /// Create a new SpriteBatch.
  external SpriteBatch spriteBatch(dynamic parent,
      [String name, bool addToStage]);

  /// Creates a new Text object.
  external Text text(num x, num y, [String text, PhaserTextStyle style]);

  /// Creates a new Phaser.Tilemap object.
  /// The map can either be populated with data from a Tiled JSON file or from a CSV file.
  /// To do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.
  /// When using CSV data you must provide the key and the tileWidth and tileHeight parameters.
  /// If creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.
  /// Note that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.
  external Tilemap tilemap(String key,
      [num tileWidth, num tileHeight, num width, num height]);

  /// Creates a new TileSprite object.
  external TileSprite tileSprite(
      num x, num y, num width, num height, dynamic key, dynamic frame);

  /// Create a tween object for a specific object.
  /// The object can be any JavaScript object or Phaser object such as Sprite.
  external Tween tween(dynamic obj);
}

/// The GameObjectFactory is a quick way to create many common game objects
/// using {@linkcode Phaser.Game#add `game.add`}.
/// Created objects are _automatically added_ to the appropriate Manager, World, or manually specified parent Group.
@JS("Phaser.GameObjectFactory")
class GameObjectFactory {
  // @Ignore
  GameObjectFactory.fakeConstructor$();

  /// The GameObjectFactory is a quick way to create many common game objects
  /// using {@linkcode Phaser.Game#add `game.add`}.
  /// Created objects are _automatically added_ to the appropriate Manager, World, or manually specified parent Group.
  external factory GameObjectFactory(Game game);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// A reference to the game world.
  external World get world;
  external set world(World v);

  /// Creates a new Sound object.
  external Sound audio(String key, [num volume, bool loop, bool connect]);

  /// Creates a new AudioSprite object.
  external AudioSprite audioSprite(String key);

  /// Create a BitmapData object.
  /// A BitmapData object can be manipulated and drawn to like a traditional Canvas object and used to texture Sprites.
  external BitmapData bitmapData(
      [num width, num height, String key, bool addToCache]);

  /// Create a new BitmapText object.
  /// BitmapText objects work by taking a texture file and an XML file that describes the font structure.
  /// It then generates a new Sprite object for each letter of the text, proportionally spaced out and aligned to
  /// match the font structure.
  /// BitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability
  /// to use Web Fonts. However you trade this flexibility for pure rendering speed. You can also create visually compelling BitmapTexts by
  /// processing the font texture in an image editor first, applying fills and any other effects required.
  /// To create multi-line text insert \r, \n or \r\n escape codes into the text string.
  /// To create a BitmapText data files you can use:
  /// BMFont (Windows, free): http://www.angelcode.com/products/bmfont/
  /// Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner
  /// Littera (Web-based, free): http://kvazars.com/littera/
  external BitmapText bitmapText(num x, num y, String font,
      [String text, num size, dynamic /*Group|Stage*/ group]);

  /// Creates a new Button object.
  external Button button(
      [num x,
      num y,
      String key,
      Function callback,
      dynamic callbackContext,
      dynamic overFrame,
      dynamic outFrame,
      dynamic downFrame,
      dynamic upFrame,
      dynamic /*Group|Stage*/ group]);

  /// Create a new Emitter.
  /// A particle emitter can be used for one-time explosions or for
  /// continuous effects like rain and fire. All it really does is launch Particle objects out
  /// at set intervals, and fixes their positions and velocities accordingly.
  external Emitter emitter([num x, num y, num maxParticles]);

  /// Adds an existing display object to the game world.
  external dynamic existing(dynamic object);

  /// A WebGL shader/filter that can be applied to Sprites.
  external Filter filter(String filter,
      [dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Creates a new Graphics object.
  external Graphics graphics([num x, num y, dynamic /*Group|Stage*/ group]);

  /// A Group is a container for display objects that allows for fast pooling, recycling and collision checks.
  external Group group(
      [dynamic parent,
      String name,
      bool addToStage,
      bool enableBody,
      num physicsBodyType]);

  /// Create a new `Image` object.
  /// An Image is a light-weight object you can use to display anything that doesn't need physics or animation.
  /// It can still rotate, scale, crop and receive input events.
  /// This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
  external Image image(
      [num x,
      num y,
      dynamic key,
      dynamic frame,
      dynamic /*Group|Stage*/ group]);

  /// A Group is a container for display objects that allows for fast pooling, recycling and collision checks.
  /// A Physics Group is the same as an ordinary Group except that is has enableBody turned on by default, so any Sprites it creates
  /// are automatically given a physics body.
  external Group physicsGroup(
      [num physicsBodyType, dynamic parent, String name, bool addToStage]);

  /// Add a new Plugin into the PluginManager.
  /// The Plugin must have 2 properties: `game` and `parent`. Plugin.game is set to the game reference the PluginManager uses, and parent is set to the PluginManager.
  external Plugin plugin(Plugin plugin,
      [dynamic parameter1,
      dynamic parameter2,
      dynamic parameter3,
      dynamic parameter4,
      dynamic parameter5]);

  /// A dynamic initially blank canvas to which images can be drawn.
  external PhaserRenderTexture renderTexture(
      [num width, num height, String key, bool addToCache]);

  /// Create a new RetroFont object.
  /// A RetroFont can be used as a texture for an Image or Sprite and optionally add it to the Cache.
  /// A RetroFont uses a bitmap which contains fixed with characters for the font set. You use character spacing to define the set.
  /// If you need variable width character support then use a BitmapText object instead. The main difference between a RetroFont and a BitmapText
  /// is that a RetroFont creates a single texture that you can apply to a game object, where-as a BitmapText creates one Sprite object per letter of text.
  /// The texture can be asssigned or one or multiple images/sprites, but note that the text the RetroFont uses will be shared across them all,
  /// i.e. if you need each Image to have different text in it, then you need to create multiple RetroFont objects.
  external RetroFont retroFont(String font, num characterWidth,
      num characterHeight, String chars, num charsPerRow,
      [num xSpacing, num ySpacing, num xOffset, num yOffset]);

  /// Creates a new Rope object.
  /// Example usage: https://github.com/codevinsky/phaser-rope-demo/blob/master/dist/demo.js
  external Rope rope(
      [num x, num y, dynamic key, dynamic frame, List<Point> points]);

  /// Creates a new Sound object.
  external Sound sound(String key, [num volume, bool loop, bool connect]);

  /// Create a new Sprite with specific position and sprite sheet key.
  /// At its most basic a Sprite consists of a set of coordinates and a texture that is used when rendered.
  /// They also contain additional properties allowing for physics motion (via Sprite.body), input handling (via Sprite.input),
  /// events (via Sprite.events), animation (via Sprite.animations), camera culling and more. Please see the Examples for use cases.
  external Sprite sprite(
      [num x,
      num y,
      dynamic key,
      dynamic frame,
      dynamic /*Group|Stage*/ group]);

  /// A SpriteBatch is a really fast version of a Phaser Group built solely for speed.
  /// Use when you need a lot of sprites or particles all sharing the same texture.
  /// The speed gains are specifically for WebGL. In Canvas mode you won't see any real difference.
  external dynamic /*Group|Stage*/ spriteBatch(dynamic parent,
      [String name, bool addToStage]);

  /// Creates a new Text object.
  external Text text(
      [num x,
      num y,
      String text,
      PhaserTextStyle style,
      dynamic /*Group|Stage*/ group]);

  /// Creates a new Phaser.Tilemap object.
  /// The map can either be populated with data from a Tiled JSON file or from a CSV file.
  /// To do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.
  /// When using CSV data you must provide the key and the tileWidth and tileHeight parameters.
  /// If creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.
  /// Note that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.
  external Tilemap tilemap(
      [String key, num tileWidth, num tileHeight, num width, num height]);

  /// Creates a new TileSprite object.
  external TileSprite tileSprite(num x, num y, num width, num height,
      [dynamic key, dynamic frame, dynamic /*Group|Stage*/ group]);

  /// Create a tween on a specific object.
  /// The object can be any JavaScript object or Phaser object such as Sprite.
  external Tween tween(dynamic obj);

  /// Weapons provide the ability to easily create a bullet pool and manager.
  /// Weapons fire Phaser.Bullet objects, which are essentially Sprites with a few extra properties.
  /// The Bullets are enabled for Arcade Physics. They do not currently work with P2 Physics.
  /// The Bullets are created inside of `Weapon.bullets`, which is a Phaser.Group instance. Anything you
  /// can usually do with a Group, such as move it around the display list, iterate it, etc can be done
  /// to the bullets Group too.
  /// Bullets can have textures and even animations. You can control the speed at which they are fired,
  /// the firing rate, the firing angle, and even set things like gravity for them.
  external Weapon weapon(
      [num quantity,
      dynamic key,
      dynamic frame,
      Group group,
      Bullet bulletClass]);

  /// Create a Video object.
  /// This will return a Phaser.Video object which you can pass to a Sprite to be used as a texture.
  external Video video([String key, String url]);
}

/// The Gamepad class handles gamepad input and dispatches gamepad events.
/// Remember to call `gamepad.start()`.
/// HTML5 GAMEPAD API SUPPORT IS AT AN EXPERIMENTAL STAGE!
/// At moment of writing this (end of 2013) only Chrome supports parts of it out of the box. Firefox supports it
/// via prefs flags (about:config, search gamepad). The browsers map the same controllers differently.
/// This class has constants for Windows 7 Chrome mapping of XBOX 360 controller.
@JS("Phaser.Gamepad")
class Gamepad {
  // @Ignore
  Gamepad.fakeConstructor$();

  /// The Gamepad class handles gamepad input and dispatches gamepad events.
  /// Remember to call `gamepad.start()`.
  /// HTML5 GAMEPAD API SUPPORT IS AT AN EXPERIMENTAL STAGE!
  /// At moment of writing this (end of 2013) only Chrome supports parts of it out of the box. Firefox supports it
  /// via prefs flags (about:config, search gamepad). The browsers map the same controllers differently.
  /// This class has constants for Windows 7 Chrome mapping of XBOX 360 controller.
  external factory Gamepad(Game game);
  external static num get BUTTON_0;
  external static set BUTTON_0(num v);
  external static num get BUTTON_1;
  external static set BUTTON_1(num v);
  external static num get BUTTON_2;
  external static set BUTTON_2(num v);
  external static num get BUTTON_3;
  external static set BUTTON_3(num v);
  external static num get BUTTON_4;
  external static set BUTTON_4(num v);
  external static num get BUTTON_5;
  external static set BUTTON_5(num v);
  external static num get BUTTON_6;
  external static set BUTTON_6(num v);
  external static num get BUTTON_7;
  external static set BUTTON_7(num v);
  external static num get BUTTON_8;
  external static set BUTTON_8(num v);
  external static num get BUTTON_9;
  external static set BUTTON_9(num v);
  external static num get BUTTON_10;
  external static set BUTTON_10(num v);
  external static num get BUTTON_11;
  external static set BUTTON_11(num v);
  external static num get BUTTON_12;
  external static set BUTTON_12(num v);
  external static num get BUTTON_13;
  external static set BUTTON_13(num v);
  external static num get BUTTON_14;
  external static set BUTTON_14(num v);
  external static num get BUTTON_15;
  external static set BUTTON_15(num v);
  external static num get AXIS_0;
  external static set AXIS_0(num v);
  external static num get AXIS_1;
  external static set AXIS_1(num v);
  external static num get AXIS_2;
  external static set AXIS_2(num v);
  external static num get AXIS_3;
  external static set AXIS_3(num v);
  external static num get AXIS_4;
  external static set AXIS_4(num v);
  external static num get AXIS_5;
  external static set AXIS_5(num v);
  external static num get AXIS_6;
  external static set AXIS_6(num v);
  external static num get AXIS_7;
  external static set AXIS_7(num v);
  external static num get AXIS_8;
  external static set AXIS_8(num v);
  external static num get AXIS_9;
  external static set AXIS_9(num v);
  external static num get XBOX360_A;
  external static set XBOX360_A(num v);
  external static num get XBOX360_B;
  external static set XBOX360_B(num v);
  external static num get XBOX360_X;
  external static set XBOX360_X(num v);
  external static num get XBOX360_Y;
  external static set XBOX360_Y(num v);
  external static num get XBOX360_LEFT_BUMPER;
  external static set XBOX360_LEFT_BUMPER(num v);
  external static num get XBOX360_RIGHT_BUMPER;
  external static set XBOX360_RIGHT_BUMPER(num v);
  external static num get XBOX360_LEFT_TRIGGER;
  external static set XBOX360_LEFT_TRIGGER(num v);
  external static num get XBOX360_RIGHT_TRIGGER;
  external static set XBOX360_RIGHT_TRIGGER(num v);
  external static num get XBOX360_BACK;
  external static set XBOX360_BACK(num v);
  external static num get XBOX360_START;
  external static set XBOX360_START(num v);
  external static num get XBOX360_STICK_LEFT_BUTTON;
  external static set XBOX360_STICK_LEFT_BUTTON(num v);
  external static num get XBOX360_STICK_RIGHT_BUTTON;
  external static set XBOX360_STICK_RIGHT_BUTTON(num v);
  external static num get XBOX360_DPAD_LEFT;
  external static set XBOX360_DPAD_LEFT(num v);
  external static num get XBOX360_DPAD_RIGHT;
  external static set XBOX360_DPAD_RIGHT(num v);
  external static num get XBOX360_DPAD_UP;
  external static set XBOX360_DPAD_UP(num v);
  external static num get XBOX360_DPAD_DOWN;
  external static set XBOX360_DPAD_DOWN(num v);
  external static num get XBOX360_STICK_LEFT_X;
  external static set XBOX360_STICK_LEFT_X(num v);
  external static num get XBOX360_STICK_LEFT_Y;
  external static set XBOX360_STICK_LEFT_Y(num v);
  external static num get XBOX360_STICK_RIGHT_X;
  external static set XBOX360_STICK_RIGHT_X(num v);
  external static num get XBOX360_STICK_RIGHT_Y;
  external static set XBOX360_STICK_RIGHT_Y(num v);
  external static num get PS3XC_X;
  external static set PS3XC_X(num v);
  external static num get PS3XC_CIRCLE;
  external static set PS3XC_CIRCLE(num v);
  external static num get PS3XC_SQUARE;
  external static set PS3XC_SQUARE(num v);
  external static num get PS3XC_TRIANGLE;
  external static set PS3XC_TRIANGLE(num v);
  external static num get PS3XC_L1;
  external static set PS3XC_L1(num v);
  external static num get PS3XC_R1;
  external static set PS3XC_R1(num v);
  external static num get PS3XC_L2;
  external static set PS3XC_L2(num v);
  external static num get PS3XC_R2;
  external static set PS3XC_R2(num v);
  external static num get PS3XC_SELECT;
  external static set PS3XC_SELECT(num v);
  external static num get PS3XC_START;
  external static set PS3XC_START(num v);
  external static num get PS3XC_STICK_LEFT_BUTTON;
  external static set PS3XC_STICK_LEFT_BUTTON(num v);
  external static num get PS3XC_STICK_RIGHT_BUTTON;
  external static set PS3XC_STICK_RIGHT_BUTTON(num v);
  external static num get PS3XC_DPAD_UP;
  external static set PS3XC_DPAD_UP(num v);
  external static num get PS3XC_DPAD_DOWN;
  external static set PS3XC_DPAD_DOWN(num v);
  external static num get PS3XC_DPAD_LEFT;
  external static set PS3XC_DPAD_LEFT(num v);
  external static num get PS3XC_DPAD_RIGHT;
  external static set PS3XC_DPAD_RIGHT(num v);
  external static num get PS3XC_STICK_LEFT_X;
  external static set PS3XC_STICK_LEFT_X(num v);
  external static num get PS3XC_STICK_LEFT_Y;
  external static set PS3XC_STICK_LEFT_Y(num v);
  external static num get PS3XC_STICK_RIGHT_X;
  external static set PS3XC_STICK_RIGHT_X(num v);
  external static num get PS3XC_STICK_RIGHT_Y;
  external static set PS3XC_STICK_RIGHT_Y(num v);

  /// If the gamepad input is active or not - if not active it should not be updated from Input.js
  external bool get active;
  external set active(bool v);

  /// The context under which the callbacks are run.
  external dynamic get callbackContext;
  external set callbackContext(dynamic v);

  /// Gamepad input will only be processed if enabled.
  /// Default: true
  external bool get enabled;
  external set enabled(bool v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);
  external Function get onAxisCallBack;
  external set onAxisCallBack(Function v);

  /// This callback is invoked every time any gamepad is connected
  external Function get onConnectCallback;
  external set onConnectCallback(Function v);

  /// This callback is invoked every time any gamepad is disconnected
  external Function get onDisconnectCallback;
  external set onDisconnectCallback(Function v);

  /// This callback is invoked every time any gamepad button is pressed down.
  external Function get onDownCallback;
  external set onDownCallback(Function v);

  /// This callback is invoked every time any gamepad button is changed to a value where value > 0 and value < 1.
  external Function get onFloatCallback;
  external set onFloatCallback(Function v);

  /// This callback is invoked every time any gamepad button is released.
  external Function get onUpCallback;
  external set onUpCallback(Function v);

  /// Gamepad #1
  external SinglePad get pad1;
  external set pad1(SinglePad v);

  /// Gamepad #2
  external SinglePad get pad2;
  external set pad2(SinglePad v);

  /// Gamepad #3
  external SinglePad get pad3;
  external set pad3(SinglePad v);

  /// Gamepad #4
  external SinglePad get pad4;
  external set pad4(SinglePad v);

  /// How many live gamepads are currently connected.
  external num get padsConnected;
  external set padsConnected(num v);

  /// Whether or not gamepads are supported in current browser.
  external bool get supported;
  external set supported(bool v);

  /// Add callbacks to the main Gamepad handler to handle connect/disconnect/button down/button up/axis change/float value buttons.
  /// onConnectCallback, onDisconnectCallback, onDownCallback, onUpCallback, onAxisCallback, onFloatCallback
  external void addCallbacks(dynamic context, dynamic callbacks);

  /// Returns true if the button is currently pressed down, on ANY gamepad.
  external bool isDown(num buttonCode);

  /// Returns the "just pressed" state of a button from ANY gamepad connected. Just pressed is considered true if the button was pressed down within the duration given (default 250ms).
  external bool justPressed(num buttonCode, [num duration]);
  external bool justReleased(num buttonCode, [num duration]);

  /// Reset all buttons/axes of all gamepads
  external void reset();

  /// Sets the deadZone variable for all four gamepads
  external void setDeadZones(dynamic value);

  /// Starts the Gamepad event handling.
  /// This MUST be called manually before Phaser will start polling the Gamepad API.
  external void start();

  /// Stops the Gamepad event handling.
  external void stop();

  /// Main gamepad update loop. Should not be called manually.
  external void update();
}

/// A Graphics object is a way to draw primitives to your game. Primitives include forms of geometry, such as Rectangles,
/// Circles and Polygons. They also include lines, arcs and curves. When you initially create a Graphics object it will
/// be empty. To 'draw' to it you first specify a lineStyle or fillStyle (or both), and then draw a shape. For example:
/// ```javascript
/// graphics.beginFill(0xff0000);
/// graphics.drawCircle(50, 50, 100);
/// graphics.endFill();
/// ```
/// This will draw a circle shape to the Graphics object, with a diameter of 100, located at x: 50, y: 50.
/// When a Graphics object is rendered it will render differently based on if the game is running under Canvas or
/// WebGL. Under Canvas it will use the HTML Canvas context drawing operations to draw the path. Under WebGL the
/// graphics data is decomposed into polygons. Both of these are expensive processes, especially with complex shapes.
/// If your Graphics object doesn't change much (or at all) once you've drawn your shape to it, then you will help
/// performance by calling `Graphics.generateTexture`. This will 'bake' the Graphics object into a Texture, and return it.
/// You can then use this Texture for Sprites or other display objects. If your Graphics object updates frequently then
/// you should avoid doing this, as it will constantly generate new textures, which will consume memory.
/// As you can tell, Graphics objects are a bit of a trade-off. While they are extremely useful, you need to be careful
/// in their complexity and quantity of them in your game.
@JS("Phaser.Graphics")
class Graphics extends DisplayObjectContainer {
  // @Ignore
  Graphics.fakeConstructor$() : super.fakeConstructor$();

  /// A Graphics object is a way to draw primitives to your game. Primitives include forms of geometry, such as Rectangles,
  /// Circles and Polygons. They also include lines, arcs and curves. When you initially create a Graphics object it will
  /// be empty. To 'draw' to it you first specify a lineStyle or fillStyle (or both), and then draw a shape. For example:
  /// ```javascript
  /// graphics.beginFill(0xff0000);
  /// graphics.drawCircle(50, 50, 100);
  /// graphics.endFill();
  /// ```
  /// This will draw a circle shape to the Graphics object, with a diameter of 100, located at x: 50, y: 50.
  /// When a Graphics object is rendered it will render differently based on if the game is running under Canvas or
  /// WebGL. Under Canvas it will use the HTML Canvas context drawing operations to draw the path. Under WebGL the
  /// graphics data is decomposed into polygons. Both of these are expensive processes, especially with complex shapes.
  /// If your Graphics object doesn't change much (or at all) once you've drawn your shape to it, then you will help
  /// performance by calling `Graphics.generateTexture`. This will 'bake' the Graphics object into a Texture, and return it.
  /// You can then use this Texture for Sprites or other display objects. If your Graphics object updates frequently then
  /// you should avoid doing this, as it will constantly generate new textures, which will consume memory.
  /// As you can tell, Graphics objects are a bit of a trade-off. While they are extremely useful, you need to be careful
  /// in their complexity and quantity of them in your game.
  external factory Graphics(Game game, [num x, num y]);

  /// A useful flag to control if the Game Object is alive or dead.
  /// This is set automatically by the Health components `damage` method should the object run out of health.
  /// Or you can toggle it via your game code.
  /// This property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.
  /// However you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.
  /// Default: true
  external bool get alive;
  external set alive(bool v);

  /// The angle property is the rotation of the Game Object in *degrees* from its original orientation.
  /// Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.
  /// Values outside this range are added to or subtracted from 360 to obtain a value within the range.
  /// For example, the statement player.angle = 450 is the same as player.angle = 90.
  /// If you wish to work in radians instead of degrees you can use the property `rotation` instead.
  /// Working in radians is slightly faster as it doesn't have to perform any calculations.
  external num get angle;
  external set angle(num v);

  /// If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.
  /// Through it you can create, play, pause and stop animations.
  external AnimationManager get animations;
  external set animations(AnimationManager v);

  /// A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.
  /// If it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.
  /// This keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.
  /// This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,
  /// or you have tested performance and find it acceptable.
  external bool get autoCull;
  external set autoCull(bool v);

  /// The blend mode to be applied to the graphic shape. Apply a value of PIXI.blendModes.NORMAL to reset the blend mode.
  /// Default: PIXI.blendModes.NORMAL;
  external num /*enum Phaser.blendModes*/ get blendMode;
  external set blendMode(num /*enum Phaser.blendModes*/ v);

  /// `body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated
  /// properties and methods via it.
  /// By default Game Objects won't add themselves to any physics system and their `body` property will be `null`.
  /// To enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object
  /// and `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.
  /// You can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.
  /// Important: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5,
  /// so the physics body is centered on the Game Object.
  /// If you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.
  external dynamic /*Body|P2_Body|Ninja_Body|dynamic*/ get body;
  external set body(dynamic /*Body|P2_Body|Ninja_Body|dynamic*/ v);

  /// The sum of the y and height properties.
  /// This is the same as `y + height - offsetY`.
  external num get bottom;
  external set bottom(num v);

  /// The bounds' padding used for bounds calculation.
  external num get boundsPadding;
  external set boundsPadding(num v);

  /// The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.
  /// The values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.
  external PhaserPoint get cameraOffset;
  external set cameraOffset(Point v);

  /// The local center x coordinate of the Game Object.
  /// This is the same as `(x - offsetX) + (width / 2)`.
  external num get centerX;
  external set centerX(num v);

  /// The local center y coordinate of the Game Object.
  /// This is the same as `(y - offsetY) + (height / 2)`.
  external num get centerY;
  external set centerY(num v);

  /// If this is set to `true` the Game Object checks if it is within the World bounds each frame.
  /// When it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.
  /// If it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.
  /// It also optionally kills the Game Object if `outOfBoundsKill` is `true`.
  /// When `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.
  /// This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,
  /// or you have tested performance and find it acceptable.
  external bool get checkWorldBounds;
  external set checkWorldBounds(bool v);

  /// The components this Game Object has installed.
  external dynamic get components;
  external set components(dynamic v);

  /// An empty Object that belongs to this Game Object.
  /// This value isn't ever used internally by Phaser, but may be used by your own code, or
  /// by Phaser Plugins, to store data that needs to be associated with the Game Object,
  /// without polluting the Game Object directly.
  /// Default: {}
  external dynamic get data;
  external set data(dynamic v);

  /// A debug flag designed for use with `Game.enableStep`.
  external bool get debug;
  external set debug(bool v);

  /// As a Game Object runs through its destroy method this flag is set to true,
  /// and can be checked in any sub-systems or plugins it is being destroyed from.
  external bool get destroyPhase;
  external set destroyPhase(bool v);

  /// All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this
  /// Game Object, or any of its components.
  external Events get events;
  external set events(Events v);

  /// Controls if this Game Object is processed by the core game loop.
  /// If this Game Object has a physics body it also controls if its physics body is updated or not.
  /// When `exists` is set to `false` it will remove its physics body from the physics world if it has one.
  /// It also toggles the `visible` property to false as well.
  /// Setting `exists` to true will add its physics body back in to the physics world, if it has one.
  /// It will also set the `visible` property to `true`.
  external bool get exists;
  external set exists(bool v);

  /// The alpha value used when filling the Graphics object.
  external num get fillAlpha;
  external set fillAlpha(num v);

  /// A Game Object that is "fixed" to the camera is rendered at a given x/y offsets from the top left of the camera. The offsets
  /// are stored in the `cameraOffset` property, which is initialized with the current object coordinates.
  /// The values are adjusted at the rendering stage, overriding the Game Objects actual world position.
  /// The end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world
  /// the camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times
  /// regardless where in the world the camera is.
  /// Note that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.
  /// Be careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.
  external bool get fixedToCamera;
  external set fixedToCamera(bool v);

  /// A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.
  /// This property is mostly used internally by the physics systems, but is exposed for the use of plugins.
  external bool get fresh;
  external set fresh(bool v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);
  external num get height;
  external set height(num v);

  /// Checks if the Game Objects bounds intersect with the Game Camera bounds.
  /// Returns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.
  external bool get inCamera;
  external set inCamera(bool v);

  /// Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.
  external bool get inWorld;
  external set inWorld(bool v);

  /// The Input Handler for this Game Object.
  /// By default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.
  /// After you have done this, this property will be a reference to the Phaser InputHandler.
  external InputHandler get input;
  external set input(InputHandler v);

  /// By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created
  /// for this Game Object and it will then start to process click / touch events and more.
  /// You can then access the Input Handler via `this.input`.
  /// Note that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.
  /// If you set this property to false it will stop the Input Handler from processing any more input events.
  /// If you want to _temporarily_ disable input for a Game Object, then it's better to set
  /// `input.enabled = false`, as it won't reset any of the Input Handlers internal properties.
  /// You can then toggle this back on as needed.
  external bool get inputEnabled;
  external set inputEnabled(bool v);

  /// Whether this shape is being used as a mask.
  external bool get isMask;
  external set isMask(bool v);

  /// The key of the image or texture used by this Game Object during rendering.
  /// If it is a string it's the string used to retrieve the texture from the Phaser Image Cache.
  /// It can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
  /// If a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.
  /// If a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.
  external dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ get key;
  external set key(dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ v);

  /// The left coordinate of the Game Object.
  /// This is the same as `x - offsetX`.
  external num get left;
  external set left(num v);

  /// The lifespan allows you to give a Game Object a lifespan in milliseconds.
  /// Once the Game Object is 'born' you can set this to a positive value.
  /// It is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.
  /// When it reaches zero it will call the `kill` method.
  /// Very handy for particles, bullets, collectibles, or any other short-lived entity.
  external num get lifespan;
  external set lifespan(num v);

  /// The color of any lines drawn.
  /// Default: 0
  external num get lineColor;
  external set lineColor(num v);

  /// The width (thickness) of any lines drawn.
  external num get lineWidth;
  external set lineWidth(num v);

  /// A user defined name given to this Game Object.
  /// This value isn't ever used internally by Phaser, it is meant as a game level property.
  external String get name;
  external set name(String v);

  /// The amount the Game Object is visually offset from its x coordinate.
  /// This is the same as `width * anchor.x`.
  /// It will only be > 0 if anchor.x is not equal to zero.
  external num get offsetX;
  external set offsetX(num v);

  /// The amount the Game Object is visually offset from its y coordinate.
  /// This is the same as `height * anchor.y`.
  /// It will only be > 0 if anchor.y is not equal to zero.
  external num get offsetY;
  external set offsetY(num v);

  /// If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.
  external bool get outOfBoundsKill;
  external set outOfBoundsKill(bool v);

  /// A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.
  /// You can set it directly to allow you to flag an object to be destroyed on its next update.
  /// This is extremely useful if you wish to destroy an object from within one of its own callbacks
  /// such as with Buttons or other Input events.
  external bool get pendingDestroy;
  external set pendingDestroy(bool v);

  /// The const physics body type of this object.
  external num get physicsType;
  external set physicsType(num v);

  /// The coordinates, in pixels, of this DisplayObject, relative to its parent container.
  /// The value of this property does not reflect any positioning happening further up the display list.
  /// To obtain that value please see the `worldPosition` property.
  external PhaserPoint get position;
  external set position(Point v);

  /// The position the Game Object was located in the previous frame.
  external PhaserPoint get previousPosition;
  external set previousPosition(Point v);

  /// The rotation the Game Object was in set to in the previous frame. Value is in radians.
  external num get previousRotation;
  external set previousRotation(num v);

  /// The render order ID is used internally by the renderer and Input Manager and should not be modified.
  /// This property is mostly used internally by the renderers, but is exposed for the use of plugins.
  external num get renderOrderID;
  external set renderOrderID(num v);

  /// The right coordinate of the Game Object.
  /// This is the same as `x + width - offsetX`.
  external num get right;
  external set right(num v);

  /// The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.
  /// Default: 0xFFFFFF
  external num get tint;
  external set tint(num v);

  /// The y coordinate of the Game Object.
  /// This is the same as `y - offsetY`.
  external num get top;
  external set top(num v);

  /// The const type of this object.
  external num get type;
  external set type(num v);
  external num get width;
  external set width(num v);

  /// The world coordinates of this Game Object in pixels.
  /// Depending on where in the display list this Game Object is placed this value can differ from `position`,
  /// which contains the x/y coordinates relative to the Game Objects parent.
  external PhaserPoint get world;
  external set world(Point v);

  /// The multiplied alpha value of this DisplayObject. A value of 1 is fully opaque. A value of 0 is transparent.
  /// This value is the calculated total, based on the alpha values of all parents of this DisplayObjects
  /// in the display list.
  /// To obtain, and set, the local alpha value, see the `alpha` property.
  /// Note: This property is only updated at the end of the `updateTransform` call, once per render. Until
  /// that happens this property will contain values based on the previous frame. Be mindful of this if
  /// accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.
  external num get worldAlpha;
  external set worldAlpha(num v);

  /// The z depth of this Game Object within its parent Group.
  /// No two objects in a Group can have the same z value.
  /// This value is adjusted automatically whenever the Group hierarchy changes.
  /// If you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.
  external num get z;
  external set z(num v);

  /// Aligns this Game Object within another Game Object, or Rectangle, known as the
  /// 'container', to one of 9 possible positions.
  /// The container must be a Game Object, or Phaser.Rectangle object. This can include properties
  /// such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world
  /// and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,
  /// TileSprites or Buttons.
  /// Please note that aligning a Sprite to another Game Object does **not** make it a child of
  /// the container. It simply modifies its position coordinates so it aligns with it.
  /// The position constants you can use are:
  /// `Phaser.TOP_LEFT`, `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`,
  /// `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`,
  /// `Phaser.BOTTOM_CENTER` and `Phaser.BOTTOM_RIGHT`.
  /// The Game Objects are placed in such a way that their _bounds_ align with the
  /// container, taking into consideration rotation, scale and the anchor property.
  /// This allows you to neatly align Game Objects, irrespective of their position value.
  /// The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final
  /// aligned position of the Game Object. For example:
  /// `sprite.alignIn(background, Phaser.BOTTOM_RIGHT, -20, -20)`
  /// Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.
  /// Think of the offsets as applying an adjustment to the containers bounds before the alignment takes place.
  /// So providing a negative offset will 'shrink' the container bounds by that amount, and providing a positive
  /// one expands it.
  external dynamic alignIn(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// Aligns this Game Object to the side of another Game Object, or Rectangle, known as the
  /// 'parent', in one of 11 possible positions.
  /// The parent must be a Game Object, or Phaser.Rectangle object. This can include properties
  /// such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world
  /// and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,
  /// TileSprites or Buttons.
  /// Please note that aligning a Sprite to another Game Object does **not** make it a child of
  /// the parent. It simply modifies its position coordinates so it aligns with it.
  /// The position constants you can use are:
  /// `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_TOP`,
  /// `Phaser.LEFT_CENTER`, `Phaser.LEFT_BOTTOM`, `Phaser.RIGHT_TOP`, `Phaser.RIGHT_CENTER`,
  /// `Phaser.RIGHT_BOTTOM`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER`
  /// and `Phaser.BOTTOM_RIGHT`.
  /// The Game Objects are placed in such a way that their _bounds_ align with the
  /// parent, taking into consideration rotation, scale and the anchor property.
  /// This allows you to neatly align Game Objects, irrespective of their position value.
  /// The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final
  /// aligned position of the Game Object. For example:
  /// `sprite.alignTo(background, Phaser.BOTTOM_RIGHT, -20, -20)`
  /// Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.
  /// Think of the offsets as applying an adjustment to the parents bounds before the alignment takes place.
  /// So providing a negative offset will 'shrink' the parent bounds by that amount, and providing a positive
  /// one expands it.
  external dynamic alignTo(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// The arc method creates an arc/curve (used to create circles, or parts of circles).
  external Graphics arc(num cx, num cy, num radius, num startAngle,
      num endAngle, bool anticlockwise);

  /// The arcTo() method creates an arc/curve between two tangents on the canvas.
  /// "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
  external Graphics arcTo(num x1, num y1, num x2, num y2, num radius);

  /// Specifies a simple one-color fill that subsequent calls to other Graphics methods
  /// (such as lineTo() or drawCircle()) use when drawing.
  external Graphics beginFill([num color, num alpha]);

  /// Calculate the points for a bezier curve and then draws it.
  external Graphics bezierCurveTo(
      num cpX, num cpY, num cpX2, num cpY2, num toX, num toY);

  /// Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
  external Graphics clear();

  /// Destroy this Graphics instance.
  external void destroy([bool destroyChildren]);

  /// Destroys a previous cached sprite.
  external void destroyCachedSprite();

  /// Draws a circle.
  external Graphics drawCircle(num x, num y, num diameter);

  /// Draws an ellipse.
  external Graphics drawEllipse(num x, num y, num width, num height);

  /// Draws a polygon using the given path.
  external Graphics drawPolygon(
      [dynamic path1,
      dynamic path2,
      dynamic path3,
      dynamic path4,
      dynamic path5]);
  external Graphics drawRect(num x, num y, num width, num height);
  external Graphics drawRoundedRect(
      num x, num y, num width, num height, num radius);

  /// Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
  /*external GraphicsData drawShape(Circle shape);*/
  /// Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
  /*external GraphicsData drawShape(Ellipse shape);*/
  /// Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
  /*external GraphicsData drawShape(Polygon shape);*/
  /// Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
  /*external GraphicsData drawShape(Rectangle shape);*/
  external GraphicsData drawShape(
      dynamic /*Circle|Ellipse|Polygon|Rectangle*/ shape);

  /// Draws a single [Phaser.Polygon] triangle from a [Phaser.Point] array
  external void drawTriangle(List<Point> points, [bool cull]);

  /// Draws [Phaser.Polygon] triangles
  external void drawTriangles(List<dynamic> /*List<Point>|List<num>*/ vertices,
      [List<num> indices, bool cull]);

  /// Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
  external Graphics endFill();

  /// Useful function that returns a texture of the graphics object that can then be used to create sprites
  /// This can be quite useful if your geometry is complicated and needs to be reused multiple times.
  /// Transparent areas adjoining the edges may be removed ([https://github.com/photonstorm/phaser-ce/issues/283 #283]).
  external PhaserRenderTexture generateTexture(
      [num resolution, num /*enum Phaser.scaleModes*/ scaleMode, @checked num padding]);

  /// Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.
  /// It will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.
  /// Note that killing a Game Object is a way for you to quickly recycle it in an object pool,
  /// it doesn't destroy the object or free it up from memory.
  /// If you don't need this Game Object any more you should call `destroy` instead.
  external Graphics kill();

  /// Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.
  external Graphics lineStyle([num lineWidth, num color, num alpha]);

  /// Draws a line using the current line style from the current drawing position to (x, y);
  /// The current drawing position is then set to (x, y).
  external Graphics lineTo(num x, num y);

  /// Moves the current drawing position to x, y.
  external Graphics moveTo(num x, num y);

  /// Automatically called by World
  external void postUpdate();

  /// Automatically called by World.preUpdate.
  external void preUpdate();

  /// Calculate the points for a quadratic bezier curve and then draws it.
  /// Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
  external Graphics quadraticCurveTo(num cpX, num cpY, num toX, num toY);

  /// Resets the Game Object.
  /// This moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`,
  /// `visible` and `renderable` to true.
  /// If this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.
  /// If this Game Object has a Physics Body it will reset the Body.
  external Graphics reset(num x, num y, [num health]);

  /// Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.
  /// A resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.
  /// It will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.
  external Graphics revive([num health]);

  /// Override this method in your own custom objects to handle any update requirements.
  /// It is called immediately after `preUpdate` and before `postUpdate`.
  /// Remember if this Game Object has any children you should call update on those too.
  external void update();
}

@JS("Phaser.GraphicsData")
class GraphicsData {
  // @Ignore
  GraphicsData.fakeConstructor$();
  external factory GraphicsData(
      [num lineWidth,
      num lineColor,
      num lineAlpha,
      num fillColor,
      num fillAlpha,
      bool fill,
      dynamic shape]);
  external num get lineWidth;
  external set lineWidth(num v);
  external num get lineColor;
  external set lineColor(num v);
  external num get lineAlpha;
  external set lineAlpha(num v);
  external num get fillColor;
  external set fillColor(num v);
  external num get fillAlpha;
  external set fillAlpha(num v);
  external bool get fill;
  external set fill(bool v);
  external dynamic get shape;
  external set shape(dynamic v);
  external num get type;
  external set type(num v);
}

/// A Group is a container for [DisplayObject display objects] including [Phaser.Sprite Sprites] and [Phaser.Image Images].
/// Groups form the logical tree structure of the display/scene graph where local transformations are applied to children.
/// For instance, all children are also moved/rotated/scaled when the group is moved/rotated/scaled.
/// In addition, Groups provides support for fast pooling and object recycling.
/// Groups are also display objects and can be nested as children within other Groups.
@JS("Phaser.Group")
class Group extends DisplayObjectContainer {
  // @Ignore
  Group.fakeConstructor$() : super.fakeConstructor$();

  /// A Group is a container for [DisplayObject display objects] including [Phaser.Sprite Sprites] and [Phaser.Image Images].
  /// Groups form the logical tree structure of the display/scene graph where local transformations are applied to children.
  /// For instance, all children are also moved/rotated/scaled when the group is moved/rotated/scaled.
  /// In addition, Groups provides support for fast pooling and object recycling.
  /// Groups are also display objects and can be nested as children within other Groups.
  /// If undefined/unspecified the Group will be added to the [Phaser.Game#world Game World]; if null the Group will not be added to any parent. - Default: (game world)
  external factory Group(Game game,
      [DisplayObjectContainer parent,
      String name,
      bool addToStage,
      bool enableBody,
      num physicsBodyType]);

  /// A returnType value, as specified in [Phaser.Group#iterate iterate] eg.
  external static num get RETURN_CHILD;
  external static set RETURN_CHILD(num v);

  /// A returnType value, as specified in [Phaser.Group#iterate iterate] eg.
  external static num get RETURN_NONE;
  external static set RETURN_NONE(num v);

  /// A returnType value, as specified in [Phaser.Group#iterate iterate] eg.
  external static num get RETURN_TOTAL;
  external static set RETURN_TOTAL(num v);

  /// A returnType value, as specified in [Phaser.Group#iterate iterate] eg.
  external static num get RETURN_ALL;
  external static set RETURN_ALL(num v);

  /// A sort ordering value, as specified in [Phaser.Group#sort sort] eg.
  external static num get SORT_ASCENDING;
  external static set SORT_ASCENDING(num v);

  /// A sort ordering value, as specified in [Phaser.Group#sort sort] eg.
  external static num get SORT_DESCENDING;
  external static set SORT_DESCENDING(num v);
  external num get alpha;
  external set alpha(num v);

  /// The angle of rotation of the group container, in degrees.
  /// This adjusts the group itself by modifying its local rotation transform.
  /// This has no impact on the rotation/angle properties of the children, but it will update their worldTransform
  /// and on-screen orientation and position.
  external num get angle;
  external set angle(num v);

  /// The alive property is useful for Groups that are children of other Groups and need to be included/excluded in checks like forEachAlive.
  /// Default: true
  external bool get alive;
  external set alive(bool v);

  /// The bottom coordinate of this Group.
  /// It is derived by calling `getBounds`, calculating the Groups dimensions based on its
  /// visible children.
  external num get bottom;
  external set bottom(num v);

  /// If this object is [Phaser.Group#fixedToCamera fixedToCamera] then this stores the x/y position offset relative to the top-left of the camera view.
  /// If the parent of this Group is also `fixedToCamera` then the offset here is in addition to that and should typically be disabled.
  external PhaserPoint get cameraOffset;
  external set cameraOffset(Point v);

  /// The center x coordinate of this Group.
  /// It is derived by calling `getBounds`, calculating the Groups dimensions based on its
  /// visible children.
  external num get centerX;
  external set centerX(num v);

  /// The center y coordinate of this Group.
  /// It is derived by calling `getBounds`, calculating the Groups dimensions based on its
  /// visible children.
  external num get centerY;
  external set centerY(num v);

  /// The type of objects that will be created when using [Phaser.Group#create create] or [Phaser.Group#createMultiple createMultiple].
  /// It should extend either Sprite or Image and accept the same constructor arguments: `(game, x, y, key, frame)`.
  /// Default: [Phaser.Sprite]
  external dynamic get classType;
  external set classType(dynamic v);

  /// The current display object that the group cursor is pointing to, if any. (Can be set manually.)
  /// The cursor is a way to iterate through the children in a Group using [Phaser.Group#next next] and [Phaser.Group#previous previous].
  external dynamic get cursor;
  external set cursor(dynamic v);

  /// The current index of the Group cursor. Advance it with Group.next.
  external num get cursorIndex;
  external set cursorIndex(num v);

  /// If true all Sprites created by, or added to this group, will have a physics body enabled on them.
  /// If there are children already in the Group at the time you set this property, they are not changed.
  /// The default body type is controlled with [Phaser.Group#physicsBodyType physicsBodyType].
  external bool get enableBody;
  external set enableBody(bool v);

  /// If true when a physics body is created (via [Phaser.Group#enableBody enableBody]) it will create a physics debug object as well.
  /// This only works for P2 bodies.
  external bool get enableBodyDebug;
  external set enableBodyDebug(bool v);

  /// If exists is false the group will be excluded from collision checks and filters such as [Phaser.Group#forEachExists forEachExists]. The group will not call `preUpdate` and `postUpdate` on its children and the children will not receive physics updates or camera/world boundary checks. The group will still be [Phaser.Group#visible visible] and will still call `update` on its children (unless [Phaser.Group#updateOnlyExistingChildren updateOnlyExistingChildren] is true).
  /// Default: true
  external bool get exists;
  external set exists(bool v);

  /// A Group that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Group.cameraOffset.
  /// Note that the cameraOffset values are in addition to any parent in the display list.
  /// So if this Group was in a Group that has x: 200, then this will be added to the cameraOffset.x
  external bool get fixedToCamera;
  external set fixedToCamera(bool v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// The hash array is an array belonging to this Group into which you can add any of its children via Group.addToHash and Group.removeFromHash.
  /// Only children of this Group can be added to and removed from the hash.
  /// This hash is used automatically by Phaser Arcade Physics in order to perform non z-index based destructive sorting.
  /// However if you don't use Arcade Physics, or this isn't a physics enabled Group, then you can use the hash to perform your own
  /// sorting and filtering of Group children without touching their z-index (and therefore display draw order)
  external List<DisplayObject> get hash;
  external set hash(List<DisplayObject> v);

  /// A group with `ignoreDestroy` set to `true` ignores all calls to its `destroy` method.
  external bool get ignoreDestroy;
  external set ignoreDestroy(bool v);

  /// A Group with `inputEnableChildren` set to `true` will automatically call `inputEnabled = true`
  /// on any children _added_ to, or _created by_, this Group.
  /// If there are children already in the Group at the time you set this property, they are not changed.
  external bool get inputEnableChildren;
  external set inputEnableChildren(bool v);

  /// The left coordinate of this Group.
  /// It is derived by calling `getBounds`, calculating the Groups dimensions based on its
  /// visible children.
  external num get left;
  external set left(num v);

  /// Total number of children in this group, regardless of exists/alive status.
  external num get length;
  external set length(num v);

  /// A name for this group. Not used internally but useful for debugging.
  external String get name;
  external set name(String v);

  /// This Signal is dispatched whenever a child of this Group emits an onInputDown signal as a result
  /// of having been interacted with by a Pointer. You can bind functions to this Signal instead of to
  /// every child Sprite.
  /// This Signal is sent 2 arguments: A reference to the Sprite that triggered the signal, and
  /// a reference to the Pointer that caused it.
  external Signal get onChildInputDown;
  external set onChildInputDown(Signal v);

  /// This Signal is dispatched whenever a child of this Group emits an onInputUp signal as a result
  /// of having been interacted with by a Pointer. You can bind functions to this Signal instead of to
  /// every child Sprite.
  /// This Signal is sent 3 arguments: A reference to the Sprite that triggered the signal,
  /// a reference to the Pointer that caused it, and a boolean value `isOver` that tells you if the Pointer
  /// is still over the Sprite or not.
  external Signal get onChildInputUp;
  external set onChildInputUp(Signal v);

  /// This Signal is dispatched whenever a child of this Group emits an onInputOver signal as a result
  /// of having been interacted with by a Pointer. You can bind functions to this Signal instead of to
  /// every child Sprite.
  /// This Signal is sent 2 arguments: A reference to the Sprite that triggered the signal, and
  /// a reference to the Pointer that caused it.
  external Signal get onChildInputOver;
  external set onChildInputOver(Signal v);

  /// This Signal is dispatched whenever a child of this Group emits an onInputOut signal as a result
  /// of having been interacted with by a Pointer. You can bind functions to this Signal instead of to
  /// every child Sprite.
  /// This Signal is sent 2 arguments: A reference to the Sprite that triggered the signal, and
  /// a reference to the Pointer that caused it.
  external Signal get onChildInputOut;
  external set onChildInputOut(Signal v);

  /// This signal is dispatched when the group is destroyed.
  external Signal get onDestroy;
  external set onDestroy(Signal v);

  /// A Group is that has `pendingDestroy` set to `true` is flagged to have its destroy method
  /// called on the next logic update.
  /// You can set it directly to flag the Group to be destroyed on its next update.
  /// This is extremely useful if you wish to destroy a Group from within one of its own callbacks
  /// or a callback of one of its children.
  external bool get pendingDestroy;
  external set pendingDestroy(bool v);

  /// If [Phaser.Group#enableBody enableBody] is true this is the type of physics body that is created on new Sprites.
  /// The valid values are [Phaser.Physics.ARCADE], [Phaser.Physics.P2JS], [Phaser.Physics.NINJA], etc.
  external num get physicsBodyType;
  external set physicsBodyType(num v);

  /// The const physics body type of this object.
  external num get physicsType;
  external set physicsType(num v);

  /// If this Group contains Arcade Physics Sprites you can set a custom sort direction via this property.
  /// It should be set to one of the Phaser.Physics.Arcade sort direction constants:
  /// Phaser.Physics.Arcade.SORT_NONE
  /// Phaser.Physics.Arcade.LEFT_RIGHT
  /// Phaser.Physics.Arcade.RIGHT_LEFT
  /// Phaser.Physics.Arcade.TOP_BOTTOM
  /// Phaser.Physics.Arcade.BOTTOM_TOP
  /// If set to `null` the Group will use whatever Phaser.Physics.Arcade.sortDirection is set to. This is the default behavior.
  external num get physicsSortDirection;
  external set physicsSortDirection(num v);

  /// The coordinates, in pixels, of this DisplayObject, relative to its parent container.
  /// The value of this property does not reflect any positioning happening further up the display list.
  /// To obtain that value please see the `worldPosition` property.
  external PhaserPoint get position;
  external set position(Point v);

  /// The right coordinate of this Group.
  /// It is derived by calling `getBounds`, calculating the Groups dimensions based on its
  /// visible children.
  external num get right;
  external set right(num v);
  external num get rotation;
  external set rotation(num v);

  /// The scale of this DisplayObject. A scale of 1:1 represents the DisplayObject
  /// at its default size. A value of 0.5 would scale this DisplayObject by half, and so on.
  /// The value of this property does not reflect any scaling happening further up the display list.
  /// To obtain that value please see the `worldScale` property.
  external PhaserPoint get scale;
  external set scale(Point v);

  /// The top coordinate of this Group.
  /// It is derived by calling `getBounds`, calculating the Groups dimensions based on its
  /// visible children.
  external num get top;
  external set top(num v);

  /// Total number of existing children in the group.
  external num get total;
  external set total(num v);

  /// Internal Phaser Type value.
  external num get type;
  external set type(num v);

  /// Skip children with `exists = false` in [Phaser.Group#update update].
  external bool get updateOnlyExistingChildren;
  external set updateOnlyExistingChildren(bool v);
  external bool get visible;
  external set visible(bool v);

  /// The z-depth value of this object within its parent container/Group - the World is a Group as well.
  /// This value must be unique for each child in a Group.
  external num get z;
  external set z(num v);

  /// Adds an existing object as the top child in this group.
  /// The child is automatically added to the top of the group, and is displayed above every previous child.
  /// Or if the _optional_ index is specified, the child is added at the location specified by the index value,
  /// this allows you to control child ordering.
  /// If the child was already in this Group, it is simply returned, and nothing else happens to it.
  /// If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.
  /// If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.
  /// Use [Phaser.Group#create create] to create and add a new child.
  external dynamic add(dynamic child, [bool silent, num index]);

  /// Adds the amount to the given property on all children in this group.
  /// `Group.addAll('x', 10)` will add 10 to the child.x value for each child.
  external void addAll(String property, num amount,
      [bool checkAlive, bool checkVisible]);

  /// Adds an existing object to this group.
  /// The child is added to the group at the location specified by the index value, this allows you to control child ordering.
  /// If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.
  /// If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.
  external dynamic addAt(dynamic child, num index, [bool silent]);

  /// Adds an array of existing Display Objects to this Group.
  /// The Display Objects are automatically added to the top of this Group, and will render on-top of everything already in this Group.
  /// As well as an array you can also pass another Group as the first argument. In this case all of the children from that
  /// Group will be removed from it and added into this Group.
  /// If `Group.enableBody` is set, then a physics body will be created on the objects, so long as one does not already exist.
  /// If `Group.inputEnableChildren` is set, then an Input Handler will be created on the objects, so long as one does not already exist.
  external List<dynamic> addMultiple(List<dynamic> children, [bool silent]);

  /// Adds a child of this Group into the hash array.
  /// This call will return false if the child is not a child of this Group, or is already in the hash.
  external bool addToHash(DisplayObject child);

  /// This method iterates through all children in the Group (regardless if they are visible or exist)
  /// and then changes their position so they are arranged in a Grid formation. Children must have
  /// the `alignTo` method in order to be positioned by this call. All default Phaser Game Objects have
  /// this.
  /// The grid dimensions are determined by the first four arguments. The `width` and `height` arguments
  /// relate to the width and height of the grid respectively.
  /// For example if the Group had 100 children in it:
  /// `Group.align(10, 10, 32, 32)`
  /// This will align all of the children into a grid formation of 10x10, using 32 pixels per
  /// grid cell. If you want a wider grid, you could do:
  /// `Group.align(25, 4, 32, 32)`
  /// This will align the children into a grid of 25x4, again using 32 pixels per grid cell.
  /// You can choose to set _either_ the `width` or `height` value to -1. Doing so tells the method
  /// to keep on aligning children until there are no children left. For example if this Group had
  /// 48 children in it, the following:
  /// `Group.align(-1, 8, 32, 32)`
  /// ... will align the children so that there are 8 children vertically (the second argument),
  /// and each row will contain 6 sprites, except the last one, which will contain 5 (totaling 48)
  /// You can also do:
  /// `Group.align(10, -1, 32, 32)`
  /// In this case it will create a grid 10 wide, and as tall as it needs to be in order to fit
  /// all of the children in.
  /// The `position` property allows you to control where in each grid cell the child is positioned.
  /// This is a constant and can be one of `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`,
  /// `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`, `Phaser.CENTER`, `Phaser.RIGHT_CENTER`,
  /// `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER` or `Phaser.BOTTOM_RIGHT`.
  /// The final argument; `offset` lets you start the alignment from a specific child index.
  external bool align(num width, num height, num cellWidth, num cellHeight,
      [num position, num offset]);
  external Group alignIn(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);
  external Group alignTo(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// Brings the given child to the top of this group so it renders above all other children.
  external dynamic bringToTop(dynamic child);

  /// Calls a function, specified by name, on all on children.
  /// The function is called for all children regardless if they are dead or alive (see callAllExists for different options).
  /// After the method parameter and context you can add as many extra parameters as you like, which will all be passed to the child.
  external void callAll(String method, dynamic context,
      [dynamic parameters1,
      dynamic parameters2,
      dynamic parameters3,
      dynamic parameters4,
      dynamic parameters5]);

  /// Calls a function, specified by name, on all children in the group who exist (or do not exist).
  /// After the existsValue parameter you can add as many parameters as you like, which will all be passed to the child callback.
  external void callAllExists(String callback, bool existsValue,
      [dynamic parameters1,
      dynamic parameters2,
      dynamic parameters3,
      dynamic parameters4,
      dynamic parameters5]);

  /// Returns a reference to a function that exists on a child of the group based on the given callback array.
  external void callbackFromArray(dynamic child, Function callback, num length);

  /// Test that the same property across all children of this group is equal to the given value.
  /// This call doesn't descend down children, so if you have a Group inside of this group, the property will be checked on the group but not its children.
  external bool checkAll(String key, dynamic value,
      [bool checkAlive, bool checkVisible, bool force]);

  /// Test that at least one child of this group has the given property value.
  /// This call doesn't descend down children, so if you have a Group inside of this group, the property will be checked on the group but not its children.
  external bool checkAny(String key, dynamic value,
      [bool checkAlive, bool checkVisible]);

  /// Checks a property for the given value on the child.
  external bool checkProperty(dynamic child, String key, dynamic value,
      [bool force]);

  /// Get the number of children with the given property name and value.
  external num count(String key, dynamic value);

  /// Get the number of dead children in this group.
  external num countDead();

  /// Get the number of living children in this group.
  external num countLiving();

  /// Creates a new Phaser.Sprite object and adds it to the top of this group.
  /// Use [Phaser.Group#classType classType] to change the type of object created.
  /// The child is automatically added to the top of the group, and is displayed above every previous child.
  /// Or if the _optional_ index is specified, the child is added at the location specified by the index value,
  /// this allows you to control child ordering.
  /// If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.
  /// If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.
  external dynamic create(num x, num y,
      [dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ key,
      dynamic /*String|num*/ frame,
      bool exists,
      num index]);

  /// Creates multiple Phaser.Sprite objects and adds them to the top of this Group.
  /// This method is useful if you need to quickly generate a pool of sprites, such as bullets.
  /// Use [Phaser.Group#classType classType] to change the type of object created.
  /// You can provide an array as the `key` and / or `frame` arguments. When you do this
  /// it will create `quantity` Sprites for every key (and frame) in the arrays.
  /// For example:
  /// `createMultiple(25, ['ball', 'carrot'])`
  /// In the above code there are 2 keys (ball and carrot) which means that 50 sprites will be
  /// created in total, 25 of each. You can also have the `frame` as an array:
  /// `createMultiple(5, 'bricks', [0, 1, 2, 3])`
  /// In the above there is one key (bricks), which is a sprite sheet. The frames array tells
  /// this method to use frames 0, 1, 2 and 3. So in total it will create 20 sprites, because
  /// the quantity was set to 5, so that is 5 brick sprites of frame 0, 5 brick sprites with
  /// frame 1, and so on.
  /// If you set both the key and frame arguments to be arrays then understand it will create
  /// a total quantity of sprites equal to the size of both arrays times each other. I.e.:
  /// `createMultiple(20, ['diamonds', 'balls'], [0, 1, 2])`
  /// The above will create 20 'diamonds' of frame 0, 20 with frame 1 and 20 with frame 2.
  /// It will then create 20 'balls' of frame 0, 20 with frame 1 and 20 with frame 2.
  /// In total it will have created 120 sprites.
  /// By default the Sprites will have their `exists` property set to `false`, and they will be
  /// positioned at 0x0, relative to the `Group.x / y` values.
  /// If `Group.enableBody` is set, then a physics body will be created on the objects, so long as one does not already exist.
  /// If `Group.inputEnableChildren` is set, then an Input Handler will be created on the objects, so long as one does not already exist.
  external List<dynamic> createMultiple(
      num quantity, dynamic /*String|List<String>*/ key,
      [dynamic /*dynamic|List<dynamic>*/ frame,
      bool exists,
      Function callback,
      dynamic callbackContext]);

  /// Sort the children in the group according to custom sort function.
  /// The `sortHandler` is provided the two parameters: the two children involved in the comparison (a and b).
  /// It should return -1 if `a > b`, 1 if `a < b` or 0 if `a === b`.
  external void customSort(Function sortHandler, [dynamic context]);

  /// Destroys this group.
  /// Removes all children, then removes this group from its parent and nulls references.
  external void destroy([bool destroyChildren, bool soft]);

  /// Divides the given property by the amount on all children in this group.
  /// `Group.divideAll('x', 2)` will half the child.x value for each child.
  external void divideAll(String property, num amount,
      [bool checkAlive, bool checkVisible]);

  /// Call a function on each child in this group.
  /// Additional arguments for the callback can be specified after the `checkExists` parameter. For example,
  /// Group.forEach(awardBonusGold, this, true, 100, 500)
  /// would invoke `awardBonusGold` function with the parameters `(child, 100, 500)`.
  /// Note: This check will skip any children which are Groups themselves.
  external void forEach(Function callback, dynamic callbackContext,
      [bool checkExists,
      dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Call a function on each alive child in this group.
  /// See [Phaser.Group#forEach forEach] for details.
  external void forEachAlive(Function callback,
      [dynamic callbackContext,
      dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Call a function on each dead child in this group.
  /// See [Phaser.Group#forEach forEach] for details.
  external void forEachDead(Function callback,
      [dynamic callbackContext,
      dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Call a function on each existing child in this group.
  /// See [Phaser.Group#forEach forEach] for details.
  external void forEachExists(Function callback, [dynamic callbackContext]);

  /// Find children matching a certain predicate.
  /// For example:
  /// var healthyList = Group.filter(function(child, index, children) {
  /// return child.health > 10 ? true : false;
  /// }, true);
  /// healthyList.callAll('attack');
  /// Note: Currently this will skip any children which are Groups themselves.
  external ArraySet filter(Function predicate, [bool checkExists]);

  /// Returns all children in this Group.
  /// You can optionally specify a matching criteria using the `property` and `value` arguments.
  /// For example: `getAll('exists', true)` would return only children that have an `exists` property equal to `true`.
  /// Optionally you can specify a start and end index. For example if this Group had 100 children,
  /// and you set `startIndex` to 0 and `endIndex` to 50, it would return the first 50 children in the Group.
  /// If `property` and `value` are also specified, only children within the given index range are searched.
  external List<dynamic> getAll(
      [String property, dynamic value, num startIndex, num endIndex]);

  /// Returns the child found at the given index within this group.
  external dynamic /*DisplayObject|num*/ getAt(num index);

  /// Returns the child at the bottom of this group.
  /// The bottom child the child being displayed (rendered) below every other child.
  external dynamic getBottom();

  /// Searches the Group for the first instance of a child with the `name`
  /// property matching the given argument. Should more than one child have
  /// the same name only the first instance is returned.
  external dynamic getByName(String name);

  /// Get the closest child to given Object, with optional callback to filter children.
  /// This can be a Sprite, Group, Image or any object with public x and y properties.
  /// 'close' is determined by the distance from the objects `x` and `y` properties compared to the childs `x` and `y` properties.
  /// You can use the optional `callback` argument to apply your own filter to the distance checks.
  /// If the child is closer then the previous child, it will be sent to `callback` as the first argument,
  /// with the distance as the second. The callback should return `true` if it passes your
  /// filtering criteria, otherwise it should return `false`.
  external dynamic getClosestTo(dynamic object,
      [Function callback, dynamic callbackContext]);

  /// Get the first display object with the given property name and value.
  external dynamic getFirst(String key, dynamic value);

  /// Get the first child that is alive (`child.alive === true`).
  /// This is handy for choosing a squad leader, etc.
  /// You can use the optional argument `createIfNull` to create a new Game Object if no alive ones were found in this Group.
  /// It works by calling `Group.create` passing it the parameters given to this method, and returning the new child.
  /// If a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child
  /// will be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.
  external dynamic getFirstAlive(
      [bool createIfNull,
      num x,
      num y,
      dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ key,
      dynamic /*String|num*/ frame]);

  /// Get the first child that is dead (`child.alive === false`).
  /// This is handy for checking if everything has been wiped out and adding to the pool as needed.
  /// You can use the optional argument `createIfNull` to create a new Game Object if no dead ones were found in this Group.
  /// It works by calling `Group.create` passing it the parameters given to this method, and returning the new child.
  /// If a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child
  /// will be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.
  external dynamic getFirstDead(
      [bool createIfNull,
      num x,
      num y,
      dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ key,
      dynamic /*String|num*/ frame]);

  /// Get the first display object that exists, or doesn't exist.
  /// You can use the optional argument `createIfNull` to create a new Game Object if none matching your exists argument were found in this Group.
  /// It works by calling `Group.create` passing it the parameters given to this method, and returning the new child.
  /// If a child *was* found , `createIfNull` is `false` and you provided the additional arguments then the child
  /// will be reset and/or have a new texture loaded on it. This is handled by `Group.resetChild`.
  external dynamic getFirstExists(bool exists,
      [bool createIfNull,
      num x,
      num y,
      dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ key,
      dynamic /*String|num*/ frame]);

  /// Get the child furthest away from the given Object, with optional callback to filter children.
  /// This can be a Sprite, Group, Image or any object with public x and y properties.
  /// 'furthest away' is determined by the distance from the objects `x` and `y` properties compared to the childs `x` and `y` properties.
  /// You can use the optional `callback` argument to apply your own filter to the distance checks.
  /// If the child is closer then the previous child, it will be sent to `callback` as the first argument,
  /// with the distance as the second. The callback should return `true` if it passes your
  /// filtering criteria, otherwise it should return `false`.
  external dynamic getFurthestFrom(dynamic object,
      [Function callback, dynamic callbackContext]);

  /// Get the index position of the given child in this group, which should match the child's `z` property.
  external num getIndex(dynamic child);

  /// Returns a random child from the group.
  external dynamic getRandom([num startIndex, num length]);

  /// Return the child at the top of this group.
  /// The top child is the child displayed (rendered) above every other child.
  external dynamic getTop();

  /// Checks if the child has the given property.
  /// Will scan up to 4 levels deep only.
  external bool hasProperty(dynamic child, List<String> key);

  /// Iterates over the children of the group performing one of several actions for matched children.
  /// A child is considered a match when it has a property, named `key`, whose value is equal to `value`
  /// according to a strict equality comparison.
  /// The result depends on the `returnType`:
  /// - [Phaser.Group.RETURN_TOTAL RETURN_TOTAL]:
  /// The callback, if any, is applied to all matching children. The number of matched children is returned.
  /// - [Phaser.Group.RETURN_NONE RETURN_NONE]:
  /// The callback, if any, is applied to all matching children. No value is returned.
  /// - [Phaser.Group.RETURN_CHILD RETURN_CHILD]:
  /// The callback, if any, is applied to the *first* matching child and the *first* matched child is returned.
  /// If there is no matching child then null is returned.
  /// If `args` is specified it must be an array. The matched child will be assigned to the first
  /// element and the entire array will be applied to the callback function.
  external dynamic iterate(String key, dynamic value, num returnType,
      [Function callback,
      dynamic callbackContext,
      dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Sets [Phaser.Group#alive alive], [Phaser.Group#exists exists], and [Phaser.Group#visible visible] to false.
  external void kill();

  /// Kills all children having exists=true.
  external void killAll();

  /// Moves all children from this Group to the Group given.
  external Group moveAll(Group group, [bool silent]);

  /// Moves the given child down one place in this group unless it's already at the bottom.
  external dynamic moveDown(dynamic child);

  /// Moves the given child up one place in this group unless it's already at the top.
  external dynamic moveUp(dynamic child);

  /// Multiplies the given property by the amount on all children in this group.
  /// `Group.multiplyAll('x', 2)` will x2 the child.x value for each child.
  external void multiplyAll(
      String property, num amount, bool checkAlive, bool checkVisible);

  /// Advances the group cursor to the next (higher) object in the group.
  /// If the cursor is at the end of the group (top child) it is moved the start of the group (bottom child).
  external dynamic next();

  /// The core postUpdate - as called by World.
  external void postUpdate();

  /// The core preUpdate - as called by World.
  external void preUpdate();

  /// Moves the group cursor to the previous (lower) child in the group.
  /// If the cursor is at the start of the group (bottom child) it is moved to the end (top child).
  external dynamic previous();

  /// Removes the given child from this group.
  /// This will dispatch an `onRemovedFromGroup` event from the child (if it has one), and optionally destroy the child.
  /// If the group cursor was referring to the removed child it is updated to refer to the next child.
  external bool remove(dynamic child, [bool destroy, bool silent]);

  /// Removes all children from this Group, but does not remove the group from its parent.
  /// The children can be optionally destroyed as they are removed.
  /// You can also optionally also destroy the BaseTexture the Child is using. Be careful if you've
  /// more than one Game Object sharing the same BaseTexture.
  external void removeAll([bool destroy, bool silent, bool destroyTexture]);

  /// Removes all children from this group whose index falls beteen the given startIndex and endIndex values.
  external void removeBetween(num startIndex,
      [num endIndex, bool destroy, bool silent]);

  /// Removes a child of this Group from the hash array.
  /// This call will return false if the child is not in the hash.
  external bool removeFromHash(DisplayObject child);

  /// Replaces a child of this Group with the given newChild. The newChild cannot be a member of this Group.
  /// If `Group.enableBody` is set, then a physics body will be created on the object, so long as one does not already exist.
  /// If `Group.inputEnableChildren` is set, then an Input Handler will be created on the object, so long as one does not already exist.
  external dynamic replace(dynamic oldChild, dynamic newChild);

  /// Calls [Phaser.Group#resetChild resetChild] on each child (or each existing child).
  external void resetAll(
      [num x,
      num y,
      dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ key,
      dynamic /*String|num*/ frame,
      bool checkExists]);

  /// Takes a child and if the `x` and `y` arguments are given it calls `child.reset(x, y)` on it.
  /// If the `key` and optionally the `frame` arguments are given, it calls `child.loadTexture(key, frame)` on it.
  /// The two operations are separate. For example if you just wish to load a new texture then pass `null` as the x and y values.
  external dynamic resetChild(dynamic child,
      [num x,
      num y,
      dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ key,
      dynamic /*String|num*/ frame]);

  /// Sets the group cursor to the first child in the group.
  /// If the optional index parameter is given it sets the cursor to the object at that index instead.
  external dynamic resetCursor([num index]);

  /// Reverses all children in this group.
  /// This operation applies only to immediate children and does not propagate to subgroups.
  external void reverse();

  /// Sets [Phaser.Group#alive alive], [Phaser.Group#exists exists], and [Phaser.Group#visible visible] to true.
  external void revive();

  /// Revives all children having exists=false.
  external void reviveAll();

  /// Places each child at a random position within the given Rectangle (or the [Phaser.World#bounds World bounds]).
  external void scatter([Rectangle rect, bool checkExists]);

  /// Sends the given child to the bottom of this group so it renders below all other children.
  external dynamic sendToBack(dynamic child);

  /// Quickly set a property on a single child of this group to a new value.
  /// The operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.
  external bool JS$set(dynamic child, List<String> key, dynamic value,
      [num operation, bool force]);

  /// Quickly set the same property across all children of this group to a new value.
  /// This call doesn't descend down children, so if you have a Group inside of this group, the property will be set on the group but not its children.
  /// If you need that ability please see `Group.setAllChildren`.
  /// The operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.
  external void setAll(String key, dynamic value,
      [bool checkAlive, bool checkVisible, num operation, bool force]);

  /// Quickly set the same property across all children of this group, and any child Groups, to a new value.
  /// If this group contains other Groups then the same property is set across their children as well, iterating down until it reaches the bottom.
  /// Unlike with `setAll` the property is NOT set on child Groups itself.
  /// The operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.
  external void setAllChildren(String key, dynamic value,
      [bool checkAlive, bool checkVisible, num operation, bool force]);

  /// Sets a property to the given value on the child. The operation parameter controls how the value is set.
  /// The operations are:
  /// - 0: set the existing value to the given value; if force is `true` a new property will be created if needed
  /// - 1: will add the given value to the value already present.
  /// - 2: will subtract the given value from the value already present.
  /// - 3: will multiply the value already present by the given value.
  /// - 4: will divide the value already present by the given value.
  external bool setProperty(dynamic child, List<String> key, dynamic value,
      [num operation, bool force]);

  /// Orders this Group's children randomly.
  /// This can be more efficient than calling [Phaser.Group#getRandom getRandom] repeatedly.
  external void shuffle();

  /// Sort the children in the group according to a particular key and ordering.
  /// Call this function to sort the group according to a particular key value and order.
  /// For example to depth sort Sprites for Zelda-style game you might call `group.sort('y', Phaser.Group.SORT_ASCENDING)` at the bottom of your `State.update()`.
  /// Internally this uses a standard JavaScript Array sort, so everything that applies there also applies here, including
  /// alphabetical sorting, mixing strings and numbers, and Unicode sorting. See MDN for more details.
  external void sort([String key, num order]);

  /// Subtracts the amount from the given property on all children in this group.
  /// `Group.subAll('x', 10)` will minus 10 from the child.x value for each child.
  external void subAll(
      String property, num amount, bool checkAlive, bool checkVisible);

  /// Swaps the position of two children in this group.
  /// Both children must be in this group, a child cannot be swapped with itself, and unparented children cannot be swapped.
  external bool swap(dynamic child1, dynamic child2);

  /// The core update - as called by World.
  /// Children with `exists = false` are updated unless [Phaser.Group#updateOnlyExistingChildren updateOnlyExistingChildren] is true.
  external void update();

  /// Internal method that re-applies all of the children's Z values.
  /// This must be called whenever children ordering is altered so that their `z` indices are correctly updated.
  external void updateZ();

  /// Positions the child found at the given index within this group to the given x and y coordinates.
  external void xy(num index, num x, num y);
}

/// An Image is a light-weight object you can use to display anything that doesn't need health, physics, or complex position monitoring.
/// It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
@JS("Phaser.Image")
class Image extends Sprite {
  // @Ignore
  Image.fakeConstructor$() : super.fakeConstructor$();

  /// An Image is a light-weight object you can use to display anything that doesn't need health, physics, or complex position monitoring.
  /// It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.
  external factory Image(Game game, num x, num y,
      dynamic /*String|RenderTexture|BitmapData|Texture*/ key,
      [dynamic /*String|num*/ frame]);

  /// A useful flag to control if the Game Object is alive or dead.
  /// This is set automatically by the Health components `damage` method should the object run out of health.
  /// Or you can toggle it via your game code.
  /// This property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.
  /// However you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.
  /// Default: true
  external bool get alive;
  external set alive(bool v);

  /// The angle property is the rotation of the Game Object in *degrees* from its original orientation.
  /// Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.
  /// Values outside this range are added to or subtracted from 360 to obtain a value within the range.
  /// For example, the statement player.angle = 450 is the same as player.angle = 90.
  /// If you wish to work in radians instead of degrees you can use the property `rotation` instead.
  /// Working in radians is slightly faster as it doesn't have to perform any calculations.
  external num get angle;
  external set angle(num v);

  /// The anchor sets the origin point of the texture.
  /// The default (0, 0) is the top left.
  /// (0.5, 0.5) is the center.
  /// (1, 1) is the bottom right.
  /// You can modify the default values in PIXI.Sprite.defaultAnchor.
  external PhaserPoint get anchor;
  external set anchor(Point v);

  /// If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.
  /// Through it you can create, play, pause and stop animations.
  external AnimationManager get animations;
  external set animations(AnimationManager v);

  /// A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.
  /// If it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.
  /// This keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.
  /// This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,
  /// or you have tested performance and find it acceptable.
  external bool get autoCull;
  external set autoCull(bool v);

  /// The sum of the y and height properties.
  /// This is the same as `y + height - offsetY`.
  external num get bottom;
  external set bottom(num v);

  /// The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.
  /// The values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.
  external PhaserPoint get cameraOffset;
  external set cameraOffset(Point v);

  /// The local center x coordinate of the Game Object.
  /// This is the same as `(x - offsetX) + (width / 2)`.
  external num get centerX;
  external set centerX(num v);

  /// The local center y coordinate of the Game Object.
  /// This is the same as `(y - offsetY) + (height / 2)`.
  external num get centerY;
  external set centerY(num v);

  /// The components this Game Object has installed.
  external dynamic get components;
  external set components(dynamic v);

  /// The Rectangle used to crop the texture this Game Object uses.
  /// Set this property via `crop`.
  /// If you modify this property directly you must call `updateCrop` in order to have the change take effect.
  external Rectangle get cropRect;
  external set cropRect(Rectangle v);

  /// Does this texture require a custom render call? (as set by BitmapData, Video, etc)
  external bool get customRender;
  external set customRender(bool v);

  /// An empty Object that belongs to this Game Object.
  /// This value isn't ever used internally by Phaser, but may be used by your own code, or
  /// by Phaser Plugins, to store data that needs to be associated with the Game Object,
  /// without polluting the Game Object directly.
  /// Default: {}
  external dynamic get data;
  external set data(dynamic v);

  /// A debug flag designed for use with `Game.enableStep`.
  external bool get debug;
  external set debug(bool v);
  external num get deltaX;
  external set deltaX(num v);
  external num get deltaY;
  external set deltaY(num v);
  external num get deltaZ;
  external set deltaZ(num v);

  /// As a Game Object runs through its destroy method this flag is set to true,
  /// and can be checked in any sub-systems or plugins it is being destroyed from.
  external bool get destroyPhase;
  external set destroyPhase(bool v);

  /// All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this
  /// Game Object, or any of its components.
  external Events get events;
  external set events(Events v);

  /// Controls if this Sprite is processed by the core Phaser game loops and Group loops (except [Phaser.Group#update]).
  /// Default: true
  external bool get exists;
  external set exists(bool v);

  /// A Game Object that is "fixed" to the camera is rendered at a given x/y offsets from the top left of the camera. The offsets
  /// are stored in the `cameraOffset` property, which is initialized with the current object coordinates.
  /// The values are adjusted at the rendering stage, overriding the Game Objects actual world position.
  /// The end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world
  /// the camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times
  /// regardless where in the world the camera is.
  /// Note that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.
  /// Be careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.
  external bool get fixedToCamera;
  external set fixedToCamera(bool v);

  /// Gets or sets the current frame index of the texture being used to render this Game Object.
  /// To change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,
  /// for example: `player.frame = 4`.
  /// If the frame index given doesn't exist it will revert to the first frame found in the texture.
  /// If you are using a texture atlas then you should use the `frameName` property instead.
  /// If you wish to fully replace the texture being used see `loadTexture`.
  external dynamic /*String|num*/ get frame;
  external set frame(dynamic /*String|num*/ v);

  /// Gets or sets the current frame name of the texture being used to render this Game Object.
  /// To change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use,
  /// for example: `player.frameName = "idle"`.
  /// If the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.
  /// If you are using a sprite sheet then you should use the `frame` property instead.
  /// If you wish to fully replace the texture being used see `loadTexture`.
  external String get frameName;
  external set frameName(String v);

  /// A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.
  /// This property is mostly used internally by the physics systems, but is exposed for the use of plugins.
  external bool get fresh;
  external set fresh(bool v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// Checks if the Game Objects bounds intersect with the Game Camera bounds.
  /// Returns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.
  external bool get inCamera;
  external set inCamera(bool v);

  /// The Input Handler for this Game Object.
  /// By default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.
  /// After you have done this, this property will be a reference to the Phaser InputHandler.
  external InputHandler get input;
  external set input(InputHandler v);

  /// By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created
  /// for this Game Object and it will then start to process click / touch events and more.
  /// You can then access the Input Handler via `this.input`.
  /// Note that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.
  /// If you set this property to false it will stop the Input Handler from processing any more input events.
  /// If you want to _temporarily_ disable input for a Game Object, then it's better to set
  /// `input.enabled = false`, as it won't reset any of the Input Handlers internal properties.
  /// You can then toggle this back on as needed.
  external bool get inputEnabled;
  external set inputEnabled(bool v);
  external bool get inWorld;
  external set inWorld(bool v);

  /// The key of the image or texture used by this Game Object during rendering.
  /// If it is a string it's the string used to retrieve the texture from the Phaser Image Cache.
  /// It can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
  /// If a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.
  /// If a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.
  external dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ get key;
  external set key(dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ v);

  /// The lifespan allows you to give a Game Object a lifespan in milliseconds.
  /// Once the Game Object is 'born' you can set this to a positive value.
  /// It is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.
  /// When it reaches zero it will call the `kill` method.
  /// Very handy for particles, bullets, collectibles, or any other short-lived entity.
  external num get lifespan;
  external set lifespan(num v);

  /// The left coordinate of the Game Object.
  /// This is the same as `x - offsetX`.
  external num get left;
  external set left(num v);

  /// A user defined name given to this Game Object.
  /// This value isn't ever used internally by Phaser, it is meant as a game level property.
  external String get name;
  external set name(String v);

  /// The amount the Game Object is visually offset from its x coordinate.
  /// This is the same as `width * anchor.x`.
  /// It will only be > 0 if anchor.x is not equal to zero.
  external num get offsetX;
  external set offsetX(num v);

  /// The amount the Game Object is visually offset from its y coordinate.
  /// This is the same as `height * anchor.y`.
  /// It will only be > 0 if anchor.y is not equal to zero.
  external num get offsetY;
  external set offsetY(num v);

  /// A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.
  /// You can set it directly to allow you to flag an object to be destroyed on its next update.
  /// This is extremely useful if you wish to destroy an object from within one of its own callbacks
  /// such as with Buttons or other Input events.
  external bool get pendingDestroy;
  external set pendingDestroy(bool v);

  /// The coordinates, in pixels, of this DisplayObject, relative to its parent container.
  /// The value of this property does not reflect any positioning happening further up the display list.
  /// To obtain that value please see the `worldPosition` property.
  external PhaserPoint get position;
  external set position(Point v);

  /// The position the Game Object was located in the previous frame.
  external PhaserPoint get previousPosition;
  external set previousPosition(Point v);

  /// The rotation the Game Object was in set to in the previous frame. Value is in radians.
  external num get previousRotation;
  external set previousRotation(num v);

  /// The render order ID is used internally by the renderer and Input Manager and should not be modified.
  /// This property is mostly used internally by the renderers, but is exposed for the use of plugins.
  external num get renderOrderID;
  external set renderOrderID(num v);

  /// The right coordinate of the Game Object.
  /// This is the same as `x + width - offsetX`.
  external num get right;
  external set right(num v);

  /// The scale of this DisplayObject. A scale of 1:1 represents the DisplayObject
  /// at its default size. A value of 0.5 would scale this DisplayObject by half, and so on.
  /// The value of this property does not reflect any scaling happening further up the display list.
  /// To obtain that value please see the `worldScale` property.
  external PhaserPoint get scale;
  external set scale(Point v);

  /// Enable or disable texture smoothing for this Game Object.
  /// It only takes effect if the Game Object is using an image based texture.
  /// Smoothing is enabled by default.
  external bool get smoothed;
  external set smoothed(bool v);

  /// The y coordinate of the Game Object.
  /// This is the same as `y - offsetY`.
  external num get top;
  external set top(num v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// The world coordinates of this Game Object in pixels.
  /// Depending on where in the display list this Game Object is placed this value can differ from `position`,
  /// which contains the x/y coordinates relative to the Game Objects parent.
  external PhaserPoint get world;
  external set world(Point v);

  /// The z depth of this Game Object within its parent Group.
  /// No two objects in a Group can have the same z value.
  /// This value is adjusted automatically whenever the Group hierarchy changes.
  /// If you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.
  external num get z;
  external set z(num v);

  /// Aligns this Game Object within another Game Object, or Rectangle, known as the
  /// 'container', to one of 9 possible positions.
  /// The container must be a Game Object, or Phaser.Rectangle object. This can include properties
  /// such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world
  /// and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,
  /// TileSprites or Buttons.
  /// Please note that aligning a Sprite to another Game Object does **not** make it a child of
  /// the container. It simply modifies its position coordinates so it aligns with it.
  /// The position constants you can use are:
  /// `Phaser.TOP_LEFT`, `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`,
  /// `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`,
  /// `Phaser.BOTTOM_CENTER` and `Phaser.BOTTOM_RIGHT`.
  /// The Game Objects are placed in such a way that their _bounds_ align with the
  /// container, taking into consideration rotation, scale and the anchor property.
  /// This allows you to neatly align Game Objects, irrespective of their position value.
  /// The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final
  /// aligned position of the Game Object. For example:
  /// `sprite.alignIn(background, Phaser.BOTTOM_RIGHT, -20, -20)`
  /// Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.
  /// Think of the offsets as applying an adjustment to the containers bounds before the alignment takes place.
  /// So providing a negative offset will 'shrink' the container bounds by that amount, and providing a positive
  /// one expands it.
  external dynamic alignIn(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// Aligns this Game Object to the side of another Game Object, or Rectangle, known as the
  /// 'parent', in one of 11 possible positions.
  /// The parent must be a Game Object, or Phaser.Rectangle object. This can include properties
  /// such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world
  /// and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,
  /// TileSprites or Buttons.
  /// Please note that aligning a Sprite to another Game Object does **not** make it a child of
  /// the parent. It simply modifies its position coordinates so it aligns with it.
  /// The position constants you can use are:
  /// `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_TOP`,
  /// `Phaser.LEFT_CENTER`, `Phaser.LEFT_BOTTOM`, `Phaser.RIGHT_TOP`, `Phaser.RIGHT_CENTER`,
  /// `Phaser.RIGHT_BOTTOM`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER`
  /// and `Phaser.BOTTOM_RIGHT`.
  /// The Game Objects are placed in such a way that their _bounds_ align with the
  /// parent, taking into consideration rotation, scale and the anchor property.
  /// This allows you to neatly align Game Objects, irrespective of their position value.
  /// The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final
  /// aligned position of the Game Object. For example:
  /// `sprite.alignTo(background, Phaser.BOTTOM_RIGHT, -20, -20)`
  /// Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.
  /// Think of the offsets as applying an adjustment to the parents bounds before the alignment takes place.
  /// So providing a negative offset will 'shrink' the parent bounds by that amount, and providing a positive
  /// one expands it.
  external dynamic alignTo(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// Brings this Game Object to the top of its parents display list.
  /// Visually this means it will render over the top of any old child in the same Group.
  /// If this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World,
  /// because the World is the root Group from which all Game Objects descend.
  external Image bringToTop();

  /// Crop allows you to crop the texture being used to display this Game Object.
  /// Setting a crop rectangle modifies the core texture frame. The Game Object width and height properties will be adjusted accordingly.
  /// Cropping takes place from the top-left and can be modified in real-time either by providing an updated rectangle object to this method,
  /// or by modifying `cropRect` property directly and then calling `updateCrop`.
  /// The rectangle object given to this method can be either a `Phaser.Rectangle` or any other object
  /// so long as it has public `x`, `y`, `width`, `height`, `right` and `bottom` properties.
  /// A reference to the rectangle is stored in `cropRect` unless the `copy` parameter is `true`,
  /// in which case the values are duplicated to a local object.
  external void crop(Rectangle rect, [bool copy]);

  /// Destroy this DisplayObject.
  /// Removes any cached sprites, sets renderable flag to false, and nulls filters, bounds and mask.
  /// Also iteratively calls `destroy` on any children.
  external void destroy([bool destroyChildren]);

  /// Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.
  /// It will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.
  /// Note that killing a Game Object is a way for you to quickly recycle it in an object pool,
  /// it doesn't destroy the object or free it up from memory.
  /// If you don't need this Game Object any more you should call `destroy` instead.
  external Image kill();

  /// Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.
  /// If your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.
  /// You should only use `loadTexture` if you want to replace the base texture entirely.
  /// Calling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.
  /// You can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite.
  /// Doing this then sets the key to be the `frame` argument (the frame is set to zero).
  /// This allows you to create sprites using `load.image` during development, and then change them
  /// to use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS'
  /// and swapping it to be the key of the atlas data.
  /// Note: You cannot use a RenderTexture as a texture for a TileSprite.
  external void loadTexture(
      dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ key,
      [dynamic /*String|num*/ frame,
      bool stopAnimation]);

  /// Resizes the Frame dimensions that the Game Object uses for rendering.
  /// You shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData
  /// it can be useful to adjust the dimensions directly in this way.
  external void resizeFrame(dynamic parent, num width, num height);

  /// Moves this Game Object down one place in its parents display list.
  /// This call has no effect if the Game Object is already at the bottom of the display list.
  /// If this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World,
  /// because the World is the root Group from which all Game Objects descend.
  external Image moveDown();

  /// Moves this Game Object up one place in its parents display list.
  /// This call has no effect if the Game Object is already at the top of the display list.
  /// If this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World,
  /// because the World is the root Group from which all Game Objects descend.
  external Image moveUp();

  /// Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object,
  /// which can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.
  /// This check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.
  /// Therefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.
  /// It should be fine for low-volume testing where physics isn't required.
  external bool overlap(
      dynamic /*Sprite|Image|TileSprite|Button|DisplayObject*/ displayObject);

  /// Plays an Animation.
  /// The animation should have previously been created via `animations.add`.
  /// If the animation is already playing calling this again won't do anything.
  /// If you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.
  external Animation play(String name,
      [num frameRate, bool loop, bool killOnComplete]);

  /// Internal method called by the World postUpdate cycle.
  external void postUpdate();

  /// Automatically called by World.preUpdate.
  external void preUpdate();

  /// Resets the Game Object.
  /// This moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`,
  /// `visible` and `renderable` to true.
  /// If this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.
  /// If this Game Object has a Physics Body it will reset the Body.
  external Image reset(num x, num y, [num health]);

  /// Resets the texture frame dimensions that the Game Object uses for rendering.
  external void resetFrame();

  /// Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.
  /// A resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.
  /// It will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.
  external Image revive([num health]);

  /// Sends this Game Object to the bottom of its parents display list.
  /// Visually this means it will render below all other children in the same Group.
  /// If this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World,
  /// because the World is the root Group from which all Game Objects descend.
  external Image sendToBack();

  /// Sets the texture frame the Game Object uses for rendering.
  /// This is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.
  external void setFrame(Frame frame);

  /// Override this method in your own custom objects to handle any update requirements.
  /// It is called immediately after `preUpdate` and before `postUpdate`.
  /// Remember if this Game Object has any children you should call update on those too.
  external void update();

  /// If you have set a crop rectangle on this Game Object via `crop` and since modified the `cropRect` property,
  /// or the rectangle it references, then you need to update the crop frame by calling this method.
  external void updateCrop();
}

/// An Image Collection is a special tileset containing mulitple images, with no slicing into each image.
/// Image Collections are normally created automatically when Tiled data is loaded.
@JS("Phaser.ImageCollection")
class ImageCollection {
  // @Ignore
  ImageCollection.fakeConstructor$();

  /// An Image Collection is a special tileset containing mulitple images, with no slicing into each image.
  /// Image Collections are normally created automatically when Tiled data is loaded.
  external factory ImageCollection(String name, num firstgid,
      [num width, num height, num margin, num spacing, dynamic properties]);

  /// The name of the Image Collection.
  external String get name;
  external set name(String v);

  /// The Tiled firstgid value.
  /// This is the starting index of the first image index this Image Collection contains.
  external num get firstgid;
  external set firstgid(num v);

  /// The width of the widest image (in pixels).
  external num get imageWidth;
  external set imageWidth(num v);

  /// The height of the tallest image (in pixels).
  external num get imageHeight;
  external set imageHeight(num v);

  /// The margin around the images in the collection (in pixels).
  /// Use `setSpacing` to change.
  external num get imageMargin;
  external set imageMargin(num v);

  /// The spacing between each image in the collection (in pixels).
  /// Use `setSpacing` to change.
  external num get imageSpacing;
  external set imageSpacing(num v);

  /// Image Collection-specific properties that are typically defined in the Tiled editor.
  external dynamic get properties;
  external set properties(dynamic v);

  /// The cached images that are a part of this collection.
  external List<dynamic> get images;
  external set images(List<dynamic> v);

  /// The total number of images in the image collection.
  external num get total;
  external set total(num v);

  /// Add an image to this Image Collection.
  external void addImage(num gid, String image);

  /// Returns true if and only if this image collection contains the given image index.
  external bool containsImageIndex(num imageIndex);
}

/// Phaser.Input is the Input Manager for all types of Input across Phaser, including mouse, keyboard, touch and MSPointer.
/// The Input manager is updated automatically by the core game loop.
@JS("Phaser.Input")
class Input {
  // @Ignore
  Input.fakeConstructor$();

  /// Phaser.Input is the Input Manager for all types of Input across Phaser, including mouse, keyboard, touch and MSPointer.
  /// The Input manager is updated automatically by the core game loop.
  external factory Input(Game game);

  /// The maximum number of pointers that can be added. This excludes the mouse pointer.
  external static num get MAX_POINTERS;
  external static set MAX_POINTERS(num v);
  external static num get MOUSE_OVERRIDES_TOUCH;
  external static set MOUSE_OVERRIDES_TOUCH(num v);
  external static num get MOUSE_TOUCH_COMBINE;
  external static set MOUSE_TOUCH_COMBINE(num v);
  external static num get TOUCH_OVERRIDES_MOUSE;
  external static set TOUCH_OVERRIDES_MOUSE(num v);

  /// The most recently active Pointer object.
  /// When you've limited max pointers to 1 this will accurately be either the first finger touched or mouse.
  external Pointer get activePointer;
  external set activePointer(Pointer v);

  /// A Circle object centered on the x/y screen coordinates of the Input.
  /// Default size of 44px (Apples recommended "finger tip" size) but can be changed to anything.
  external Circle get circle;
  external set circle(Circle v);

  /// When enabled, input (eg. Keyboard, Mouse, Touch) will be processed - as long as the individual sources are enabled themselves.
  /// When not enabled, _all_ input sources are ignored. To disable just one type of input; for example, the Mouse, use `input.mouse.enabled = false`.
  /// Default: true
  external bool get enabled;
  external set enabled(bool v);

  /// The number of milliseconds between taps of the same Pointer for it to be considered a double tap / click.
  /// Default: 300
  external num get doubleTapRate;
  external set doubleTapRate(num v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// The Gamepad Input manager.
  external Gamepad get gamepad;
  external set gamepad(Gamepad v);

  /// The canvas to which single pixels are drawn in order to perform pixel-perfect hit detection.
  external CanvasElement get hitCanvas;
  external set hitCanvas(CanvasElement v);

  /// The context of the pixel perfect hit canvas.
  external CanvasRenderingContext2D get hitContext;
  external set hitContext(CanvasRenderingContext2D v);

  /// The number of milliseconds that the Pointer has to be pressed down for it to fire a onHold event.
  /// Default: 2000
  external num get holdRate;
  external set holdRate(num v);

  /// A list of interactive objects. The InputHandler components add and remove themselves from this list.
  external ArraySet get interactiveItems;
  external set interactiveItems(ArraySet v);

  /// The number of milliseconds below which the Pointer is considered justPressed.
  /// Default: 200
  external num get justPressedRate;
  external set justPressedRate(num v);

  /// The number of milliseconds below which the Pointer is considered justReleased .
  /// Default: 200
  external num get justReleasedRate;
  external set justReleasedRate(num v);

  /// The Keyboard Input manager.
  external Keyboard get keyboard;
  external set keyboard(Keyboard v);

  /// The maximum number of Pointers allowed to be active at any one time. A value of -1 is only limited by the total number of pointers. For lots of games it's useful to set this to 1.
  /// Default: -1 (Limited by total pointers.)
  external num get maxPointers;
  external set maxPointers(num v);

  /// You can tell all Pointers to ignore any Game Object with a `priorityID` lower than this value.
  /// This is useful when stacking UI layers. Set to zero to disable.
  external num get minPriorityID;
  external set minPriorityID(num v);

  /// The Mouse Input manager.
  /// You should not usually access this manager directly, but instead use Input.mousePointer or Input.activePointer
  /// which normalizes all the input values for you, regardless of browser.
  external Mouse get mouse;
  external set mouse(Mouse v);

  /// The mouse has its own unique Phaser.Pointer object which you can use if making a desktop specific game.
  external Pointer get mousePointer;
  external set mousePointer(Pointer v);

  /// An array of callbacks that will be fired every time the activePointer receives a move event from the DOM.
  /// To add a callback to this array please use `Input.addMoveCallback`.
  external Func3<Pointer, num, num, List<Null>> get moveCallbacks;
  external set moveCallbacks(Func3<Pointer, num, num, List<Null>> v);

  /// The MSPointer Input manager.
  /// You should not usually access this manager directly, but instead use Input.activePointer
  /// which normalizes all the input values for you, regardless of browser.
  external MSPointer get mspointer;
  external set mspointer(MSPointer v);

  /// Controls the expected behavior when using a mouse and touch together on a multi-input device.
  external num get multiInputOverride;
  external set multiInputOverride(num v);

  /// A Signal that is dispatched each time a [Phaser.Pointer pointer] is pressed down.
  /// It is sent two arguments:
  /// - {Phaser.Pointer} The pointer that caused the event.
  /// - {Event} The original DOM event.
  external Signal get onDown;
  external set onDown(Signal v);

  /// A Signal that is dispatched each time a [Phaser.Pointer pointer] is held down.
  /// It is sent one argument:
  /// - {Phaser.Pointer} The pointer that caused the event.
  external Signal get onHold;
  external set onHold(Signal v);

  /// A Signal that is dispatched each time a [Phaser.Pointer pointer] is tapped.
  /// It is sent two arguments:
  /// - {Phaser.Pointer} The pointer that caused the event.
  /// - {boolean} True if this was a double tap.
  external Signal get onTap;
  external set onTap(Signal v);

  /// A Signal that is dispatched each time a [Phaser.Pointer pointer] is released.
  /// It is sent two arguments:
  /// - {Phaser.Pointer} The pointer that caused the event.
  /// - {Event} The original DOM event.
  external Signal get onUp;
  external set onUp(Signal v);

  /// A Pointer object.
  external Pointer get pointer1;
  external set pointer1(Pointer v);

  /// A Pointer object.
  external Pointer get pointer2;
  external set pointer2(Pointer v);

  /// A Pointer object.
  external Pointer get pointer3;
  external set pointer3(Pointer v);

  /// A Pointer object.
  external Pointer get pointer4;
  external set pointer4(Pointer v);

  /// A Pointer object.
  external Pointer get pointer5;
  external set pointer5(Pointer v);

  /// A Pointer object.
  external Pointer get pointer6;
  external set pointer6(Pointer v);

  /// A Pointer object.
  external Pointer get pointer7;
  external set pointer7(Pointer v);

  /// A Pointer object.
  external Pointer get pointer8;
  external set pointer8(Pointer v);

  /// A Pointer object.
  external Pointer get pointer9;
  external set pointer9(Pointer v);

  /// A Pointer object.
  external Pointer get pointer10;
  external set pointer10(Pointer v);

  /// True if the Input is currently poll rate locked.
  external bool get pollLocked;
  external set pollLocked(bool v);

  /// How often should the input pointers be checked for updates? A value of 0 means every single frame (60fps); a value of 1 means every other frame (30fps) and so on.
  external num get pollRate;
  external set pollRate(num v);

  /// A point object representing the current position of the Pointer.
  external PhaserPoint get position;
  external set position(Point v);
  external List<Pointer> get pointer;
  external set pointer(List<Pointer> v);

  /// The total number of entries that can be recorded into the Pointer objects tracking history.
  /// If the Pointer is tracking one event every 100ms; then a trackLimit of 100 would store the last 10 seconds worth of history.
  /// Default: 100
  external num get recordLimit;
  external set recordLimit(num v);

  /// Sets if the Pointer objects should record a history of x/y coordinates they have passed through.
  /// The history is cleared each time the Pointer is pressed down.
  /// The history is updated at the rate specified in Input.pollRate
  external bool get recordPointerHistory;
  external set recordPointerHistory(bool v);

  /// The rate in milliseconds at which the Pointer objects should update their tracking history.
  /// Default: 100
  external num get recordRate;
  external set recordRate(num v);

  /// If the Input Manager has been reset locked then all calls made to InputManager.reset,
  /// such as from a State change, are ignored.
  external bool get resetLocked;
  external set resetLocked(bool v);

  /// The scale by which all input coordinates are multiplied; calculated by the ScaleManager. In an un-scaled game the values will be x = 1 and y = 1.
  external PhaserPoint get scale;
  external set scale(Point v);

  /// A point object representing the speed of the Pointer. Only really useful in single Pointer games; otherwise see the Pointer objects directly.
  external PhaserPoint get speed;
  external set speed(Point v);

  /// The number of milliseconds that the Pointer has to be pressed down and then released to be considered a tap or click.
  /// Default: 200
  external num get tapRate;
  external set tapRate(num v);

  /// The total number of active Pointers, not counting the mouse pointer.
  external num get totalActivePointers;
  external set totalActivePointers(num v);

  /// The total number of inactive Pointers.
  external num get totalInactivePointers;
  external set totalInactivePointers(num v);

  /// The Touch Input manager.
  /// You should not usually access this manager directly, but instead use Input.activePointer
  /// which normalizes all the input values for you, regardless of browser.
  external Touch get touch;
  external set touch(Touch v);

  /// The world X coordinate of the most recently active pointer.
  external num get worldX;
  external set worldX(num v);

  /// The world Y coordinate of the most recently active pointer.
  external num get worldY;
  external set worldY(num v);

  /// The X coordinate of the most recently active pointer.
  /// This value takes game scaling into account automatically. See Pointer.screenX/clientX for source values.
  external num get x;
  external set x(num v);

  /// The Y coordinate of the most recently active pointer.
  /// This value takes game scaling into account automatically. See Pointer.screenY/clientY for source values.
  external num get y;
  external set y(num v);

  /// Add a new Pointer object to the Input Manager.
  /// By default Input creates 3 pointer objects: `mousePointer` (not include in part of general pointer pool), `pointer1` and `pointer2`.
  /// This method adds an additional pointer, up to a maximum of Phaser.Input.MAX_POINTERS (default of 10).
  external Pointer addPointer();

  /// Adds a callback that is fired every time the activePointer receives a DOM move event such as a mousemove or touchmove.
  /// The callback will be sent 4 parameters:
  /// A reference to the Phaser.Pointer object that moved,
  /// The x position of the pointer,
  /// The y position,
  /// A boolean indicating if the movement was the result of a 'click' event (such as a mouse click or touch down).
  /// It will be called every time the activePointer moves, which in a multi-touch game can be a lot of times, so this is best
  /// to only use if you've limited input to a single pointer (i.e. mouse or touch).
  /// The callback is added to the Phaser.Input.moveCallbacks array and should be removed with Phaser.Input.deleteMoveCallback.
  external num addMoveCallback(Function callback, dynamic context);

  /// Starts the Input Manager running.
  external void boot();
  external num countActivePointers([num limit]);

  /// Removes the callback from the Phaser.Input.moveCallbacks array.
  external void deleteMoveCallback(Function callback, [dynamic context]);

  /// Stops all of the Input Managers from running.
  external void destroy();

  /// This will return the local coordinates of the specified displayObject based on the given Pointer.
  external PhaserPoint getLocalPosition(dynamic displayObject, Pointer pointer);

  /// Get the first Pointer with the given active state.
  external Pointer getPointer([bool isActive]);

  /// Get the Pointer object whos `pointerId` property matches the given value.
  /// The pointerId property is not set until the Pointer has been used at least once, as its populated by the DOM event.
  /// Also it can change every time you press the pointer down if the browser recycles it.
  external Pointer getPointerFromId(num pointerID);

  /// Get the Pointer object whos `identifier` property matches the given identifier value.
  /// The identifier property is not set until the Pointer has been used at least once, as its populated by the DOM event.
  /// Also it can change every time you press the pointer down, and is not fixed once set.
  /// Note: Not all browsers set the identifier property and it's not part of the W3C spec, so you may need getPointerFromId instead.
  external Pointer getPointerFromIdentifier(num identifier);

  /// Tests if the pointer hits the given object.
  external void hitTest(
      DisplayObject displayObject, Pointer pointer, Point localPoint);

  /// Reset all of the Pointers and Input states.
  /// The optional `hard` parameter will reset any events or callbacks that may be bound.
  /// Input.reset is called automatically during a State change or if a game loses focus / visibility.
  /// To control control the reset manually set [Phaser.InputManager.resetLocked] to `true`.
  external void reset([bool hard]);

  /// Resets the speed and old position properties.
  external void resetSpeed(num x, num y);

  /// Adds a callback that is fired every time `Pointer.processInteractiveObjects` is called.
  /// The purpose of `processInteractiveObjects` is to work out which Game Object the Pointer is going to
  /// interact with. It works by polling all of the valid game objects, and then slowly discounting those
  /// that don't meet the criteria (i.e. they aren't under the Pointer, are disabled, invisible, etc).
  /// Eventually a short-list of 'candidates' is created. These are all of the Game Objects which are valid
  /// for input and overlap with the Pointer. If you need fine-grained control over which of the items is
  /// selected then you can use this callback to do so.
  /// The callback will be sent 3 parameters:
  /// 1) A reference to the Phaser.Pointer object that is processing the Items.
  /// 2) An array containing all potential interactive candidates. This is an array of `InputHandler` objects, not Sprites.
  /// 3) The current 'favorite' candidate, based on its priorityID and position in the display list.
  /// Your callback MUST return one of the candidates sent to it.
  external void setInteractiveCandidateHandler(Function callback,
      [dynamic context]);

  /// Find the first free Pointer object and start it, passing in the event data.
  /// This is called automatically by Phaser.Touch and Phaser.MSPointer.
  external Pointer startPointer(dynamic event);

  /// Stops the matching Pointer object, passing in the event data.
  external Pointer stopPointer(dynamic event);

  /// Updates the Input Manager. Called by the core Game loop.
  external void update();

  /// Updates the matching Pointer object, passing in the event data.
  /// This is called automatically and should not normally need to be invoked.
  external Pointer updatePointer(dynamic event);
}

/// The Input Handler is bound to a specific Sprite and is responsible for managing all Input events on that Sprite.
@JS("Phaser.InputHandler")
class InputHandler {
  // @Ignore
  InputHandler.fakeConstructor$();

  /// The Input Handler is bound to a specific Sprite and is responsible for managing all Input events on that Sprite.
  external factory InputHandler(Sprite sprite);

  /// Controls if the Sprite is allowed to be dragged horizontally.
  /// Default: true
  external bool get allowHorizontalDrag;
  external set allowHorizontalDrag(bool v);

  /// Controls if the Sprite is allowed to be dragged vertically.
  /// Default: true
  external bool get allowVerticalDrag;
  external set allowVerticalDrag(bool v);

  /// A region of the game world within which the sprite is restricted during drag.
  external Rectangle get boundsRect;
  external set boundsRect(Rectangle v);

  /// A Sprite the bounds of which this sprite is restricted during drag.
  external Sprite get boundsSprite;
  external set boundsSprite(Sprite v);

  /// If true when this Sprite is clicked or dragged it will automatically be bought to the top of the Group it is within.
  external bool get bringToTop;
  external set bringToTop(bool v);

  /// A Point object containing the coordinates of the Pointer when it was first pressed down onto this Sprite.
  external PhaserPoint get downPoint;
  external set downPoint(Point v);

  /// The distance, in pixels, the pointer has to move while being held down, before the Sprite thinks it is being dragged.
  external num get dragDistanceThreshold;
  external set dragDistanceThreshold(num v);

  /// The offset from the Sprites position that dragging takes place from.
  external PhaserPoint get dragOffset;
  external set dragOffset(Point v);

  /// Is the Sprite dragged from its center, or the point at which the Pointer was pressed down upon it?
  external bool get dragFromCenter;
  external set dragFromCenter(bool v);

  /// Is this sprite allowed to be dragged by the mouse? true = yes, false = no
  external bool get draggable;
  external set draggable(bool v);

  /// The Point from which the most recent drag started from. Useful if you need to return an object to its starting position.
  external PhaserPoint get dragStartPoint;
  external set dragStartPoint(Point v);

  /// If enabled, when the Sprite stops being dragged, it will only dispatch the `onDragStop` event, and not the `onInputUp` event. If set to `false` it will dispatch both events.
  external bool get dragStopBlocksInputUp;
  external set dragStopBlocksInputUp(bool v);

  /// The amount of time, in ms, the pointer has to be held down over the Sprite before it thinks it is being dragged.
  external num get dragTimeThreshold;
  external set dragTimeThreshold(num v);

  /// If enabled the Input Handler will process input requests and monitor pointer activity.
  external bool get enabled;
  external set enabled(bool v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// Warning: EXPERIMENTAL
  external num globalToLocalX(num x);

  /// Warning: EXPERIMENTAL
  external num globalToLocalY(num y);

  /// true if the Sprite is being currently dragged.
  external bool get isDragged;
  external set isDragged(bool v);

  /// The alpha tolerance threshold. If the alpha value of the pixel matches or is above this value, it's considered a hit.
  /// Default: 255
  external num get pixelPerfectAlpha;
  external set pixelPerfectAlpha(num v);

  /// Set to true to use pixel perfect hit detection when checking if the pointer is over this Sprite when it's clicked or touched.
  /// The x/y coordinates of the pointer are tested against the image in combination with the InputHandler.pixelPerfectAlpha value.
  /// This feature only works for display objects with image based textures such as Sprites. It won't work on BitmapText or Rope.
  /// Warning: This is expensive so only enable if you really need it. Use a pixel perfect check when testing for clicks or touches on the Sprite.
  external bool get pixelPerfectClick;
  external set pixelPerfectClick(bool v);

  /// Set to true to use pixel perfect hit detection when checking if the pointer is over this Sprite.
  /// The x/y coordinates of the pointer are tested against the image in combination with the InputHandler.pixelPerfectAlpha value.
  /// This feature only works for display objects with image based textures such as Sprites. It won't work on BitmapText or Rope.
  /// Warning: This is expensive, especially on mobile (where it's not even needed!) so only enable if required. Also see the less-expensive InputHandler.pixelPerfectClick. Use a pixel perfect check when testing for pointer over.
  external bool get pixelPerfectOver;
  external set pixelPerfectOver(bool v);

  /// The priorityID is used to determine which game objects should get priority when input events occur. For example if you have
  /// several Sprites that overlap, by default the one at the top of the display list is given priority for input events. You can
  /// stop this from happening by controlling the priorityID value. The higher the value, the more important they are considered to the Input events.
  external num get priorityID;
  external set priorityID(num v);

  /// EXPERIMENTAL: Please do not use this property unless you know what it does. Likely to change in the future.
  external bool get scaleLayer;
  external set scaleLayer(bool v);

  /// A Point object that contains by how far the Sprite snap is offset.
  external PhaserPoint get snapOffset;
  external set snapOffset(Point v);

  /// This defines the top-left X coordinate of the snap grid.
  external num get snapOffsetX;
  external set snapOffsetX(num v);

  /// This defines the top-left Y coordinate of the snap grid..
  external num get snapOffsetY;
  external set snapOffsetY(num v);

  /// When the Sprite is dragged this controls if the center of the Sprite will snap to the pointer on drag or not.
  external bool get snapOnDrag;
  external set snapOnDrag(bool v);

  /// When the Sprite is dragged this controls if the Sprite will be snapped on release.
  external bool get snapOnRelease;
  external set snapOnRelease(bool v);

  /// If the sprite is set to snap while dragging this holds the point of the most recent 'snap' event.
  external PhaserPoint get snapPoint;
  external set snapPoint(Point v);

  /// When a Sprite has snapping enabled this holds the width of the snap grid.
  external num get snapX;
  external set snapX(num v);

  /// When a Sprite has snapping enabled this holds the height of the snap grid.
  external num get snapY;
  external set snapY(num v);

  /// The Sprite object to which this Input Handler belongs.
  external Sprite get sprite;
  external set sprite(Sprite v);

  /// On a desktop browser you can set the 'hand' cursor to appear when moving over the Sprite.
  external bool get useHandCursor;
  external set useHandCursor(bool v);

  /// Bounds Rect check for the sprite drag
  external void checkBoundsRect();

  /// Parent Sprite Bounds check for the sprite drag.
  external void checkBoundsSprite();

  /// Runs a pixel perfect check against the given x/y coordinates of the Sprite this InputHandler is bound to.
  /// It compares the alpha value of the pixel and if >= InputHandler.pixelPerfectAlpha it returns true.
  external bool checkPixel(num x, num y, [Pointer pointer]);

  /// Checks if the given pointer is both down and over the Sprite this InputHandler belongs to.
  /// Use the `fastTest` flag is to quickly check just the bounding hit area even if `InputHandler.pixelPerfectOver` is `true`.
  external bool checkPointerDown(Pointer pointer, [bool fastTest]);

  /// Checks if the given pointer is over the Sprite this InputHandler belongs to.
  /// Use the `fastTest` flag is to quickly check just the bounding hit area even if `InputHandler.pixelPerfectOver` is `true`.
  external bool checkPointerOver(Pointer pointer, [bool fastTest]);

  /// Clean up memory.
  external void destroy();

  /// Stops this sprite from being able to be dragged.
  /// If it is currently the target of an active drag it will be stopped immediately; also disables any set callbacks.
  external void disableDrag();

  /// Stops the sprite from snapping to a grid during drag or release.
  external void disableSnap();

  /// If the pointer is currently over this Sprite this returns how long it has been there for in milliseconds.
  external num downDuration([num pointerId]);

  /// Allow this Sprite to be dragged by any valid pointer.
  /// When the drag begins the Sprite.events.onDragStart event will be dispatched.
  /// When the drag completes by way of the user letting go of the pointer that was dragging the sprite, the Sprite.events.onDragStop event is dispatched.
  /// You can control the thresholds over when a drag starts via the properties:
  /// `Pointer.dragDistanceThreshold` the distance, in pixels, that the pointer has to move
  /// before the drag will start.
  /// `Pointer.dragTimeThreshold` the time, in ms, that the pointer must be held down on
  /// the Sprite before the drag will start.
  /// You can set either (or both) of these properties after enabling a Sprite for drag.
  /// For the duration of the drag the Sprite.events.onDragUpdate event is dispatched. This event is only dispatched when the pointer actually
  /// changes position and moves. The event sends 5 parameters: `sprite`, `pointer`, `dragX`, `dragY` and `snapPoint`.
  external void enableDrag(
      [bool lockCenter,
      bool bringToTop,
      bool pixelPerfect,
      num alphaThreshold,
      Rectangle boundsRect,
      Sprite boundsSprite]);

  /// Make this Sprite snap to the given grid either during drag or when it's released.
  /// For example 16x16 as the snapX and snapY would make the sprite snap to every 16 pixels.
  external void enableSnap(num snapX, num snapY,
      [bool onDrag, bool onRelease, num snapOffsetX, num snapOffsetY]);

  /// Is this object using pixel perfect checking?
  external bool isPixelPerfect();

  /// Returns true if the pointer has left the Sprite within the specified delay time (defaults to 500ms, half a second)
  external bool justOut([num pointerId, num delay]);

  /// Returns true if the pointer has entered the Sprite within the specified delay time (defaults to 500ms, half a second)
  external bool justOver([num pointerId, num delay]);

  /// Returns true if the pointer has touched or clicked on the Sprite within the specified delay time (defaults to 500ms, half a second)
  external bool justPressed([num pointerId, num delay]);

  /// Returns true if the pointer was touching this Sprite, but has been released within the specified delay time (defaults to 500ms, half a second)
  external bool justReleased([num pointerId, num delay]);

  /// If the pointer is currently over this Sprite this returns how long it has been there for in milliseconds.
  external num overDuration([num pointerId]);

  /// If the Pointer is down this returns true.
  /// This *only* checks if the Pointer is down, not if it's down over any specific Sprite.
  external bool pointerDown([num pointerId]);

  /// Is this sprite being dragged by the mouse or not?
  external bool pointerDragged([num pointerId]);

  /// Is the Pointer outside of this Sprite?
  external bool pointerOut([num pointerId]);

  /// Is the Pointer over this Sprite?
  external bool pointerOver([num pointerId]);

  /// A timestamp representing when the Pointer first touched the touchscreen.
  external num pointerTimeDown([num pointerId]);

  /// A timestamp representing when the Pointer left the touchscreen.
  external num pointerTimeOut([num pointerId]);

  /// A timestamp representing when the Pointer first touched the touchscreen.
  external num pointerTimeOver([num pointerId]);

  /// A timestamp representing when the Pointer left the touchscreen.
  external num pointerTimeUp([num pointerId]);

  /// If the Pointer is up this returns true.
  /// This *only* checks if the Pointer is up, not if it's up over any specific Sprite.
  external bool pointerUp([num pointerId]);

  /// The x coordinate of the Input pointer, relative to the top-left of the parent Sprite.
  /// This value is only set when the pointer is over this Sprite.
  external num pointerX([num pointerId]);

  /// The y coordinate of the Input pointer, relative to the top-left of the parent Sprite
  /// This value is only set when the pointer is over this Sprite.
  external num pointerY([num pointerId]);

  /// Resets the Input Handler and disables it.
  external void reset();

  /// Restricts this sprite to drag movement only on the given axis. Note: If both are set to false the sprite will never move!
  external void setDragLock([bool allowHorizontal, bool allowVertical]);

  /// Starts the Input Handler running. This is called automatically when you enable input on a Sprite, or can be called directly if you need to set a specific priority.
  external Sprite start(num priority, bool useHandCursor);

  /// Called by Pointer when drag starts on this Sprite. Should not usually be called directly.
  external void startDrag(Pointer pointer);

  /// Stops the Input Handler from running.
  external void stop();

  /// Called by Pointer when drag is stopped on this Sprite. Should not usually be called directly.
  external void stopDrag(Pointer pointer);

  /// Internal Update method. This is called automatically and handles the Pointer
  /// and drag update loops.
  external void update(Pointer pointer);

  /// Called as a Pointer actively drags this Game Object.
  external bool updateDrag(Pointer pointer);

  /// Checks if the object this InputHandler is bound to is valid for consideration in the Pointer move event.
  /// This is called by Phaser.Pointer and shouldn't typically be called directly.
  external bool validForInput(num highestID, num highestRenderID,
      [bool includePixelPerfect]);
}

/// If you need more fine-grained control over the handling of specific keys you can create and use Phaser.Key objects.
@JS("Phaser.Key")
class Key {
  // @Ignore
  Key.fakeConstructor$();

  /// If you need more fine-grained control over the handling of specific keys you can create and use Phaser.Key objects.
  external factory Key(Game game, num keycode);

  /// The down state of the ALT key, if pressed at the same time as this key.
  external bool get altKey;
  external set altKey(bool v);

  /// The down state of the CTRL key, if pressed at the same time as this key.
  external bool get ctrlKey;
  external set ctrlKey(bool v);

  /// If the key is down this value holds the duration of that key press and is constantly updated.
  /// If the key is up it holds the duration of the previous down session. The number of milliseconds this key has been held down for.
  external num get duration;
  external set duration(num v);

  /// An enabled key processes its update and dispatches events.
  /// A key can be disabled momentarily at runtime instead of deleting it.
  /// Default: true
  external bool get enabled;
  external set enabled(bool v);

  /// Stores the most recent DOM event.
  external dynamic get event;
  external set event(dynamic v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// The "down" state of the key. This will remain `true` for as long as the keyboard thinks this key is held down.
  external bool get isDown;
  external set isDown(bool v);

  /// The "up" state of the key. This will remain `true` for as long as the keyboard thinks this key is up.
  /// Default: true
  external bool get isUp;
  external set isUp(bool v);

  /// True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
  external bool get JS$_justDown;
  external set JS$_justDown(bool v);

  /// The justDown value allows you to test if this Key has just been pressed down or not.
  /// When you check this value it will return `true` if the Key is down, otherwise `false`.
  /// You can only call justDown once per key press. It will only return `true` once, until the Key is released and pressed down again.
  /// This allows you to use it in situations where you want to check if this key is down without using a Signal, such as in a core game loop.
  /// Default: false
  external bool get justDown;
  external set justDown(bool v);

  /// True if the key has just been pressed (NOTE: requires to be reset, see justDown getter)
  external bool get JS$_justUp;
  external set JS$_justUp(bool v);

  /// The justUp value allows you to test if this Key has just been released or not.
  /// When you check this value it will return `true` if the Key is up, otherwise `false`.
  /// You can only call justUp once per key release. It will only return `true` once, until the Key is pressed down and released again.
  /// This allows you to use it in situations where you want to check if this key is up without using a Signal, such as in a core game loop.
  /// Default: false
  external bool get justUp;
  external set justUp(bool v);

  /// The keycode of this key.
  external num get keyCode;
  external set keyCode(num v);

  /// This Signal is dispatched every time this Key is pressed down. It is only dispatched once (until the key is released again).
  external Signal get onDown;
  external set onDown(Signal v);

  /// A callback that is called while this Key is held down. Warning: Depending on refresh rate that could be 60+ times per second.
  external Function get onHoldCallback;
  external set onHoldCallback(Function v);

  /// The context under which the onHoldCallback will be called.
  external dynamic get onHoldContext;
  external set onHoldContext(dynamic v);

  /// This Signal is dispatched every time this Key is released. It is only dispatched once (until the key is pressed and released again).
  external Signal get onUp;
  external set onUp(Signal v);

  /// If a key is held down this holds down the number of times the key has 'repeated'.
  external num get repeats;
  external set repeats(num v);

  /// The down state of the SHIFT key, if pressed at the same time as this key.
  external bool get shiftKey;
  external set shiftKey(bool v);

  /// The timestamp when the key was last pressed down. This is based on Game.time.now.
  external num get timeDown;
  external set timeDown(num v);

  /// The timestamp when the key was last released. This is based on Game.time.now.
  external num get timeUp;
  external set timeUp(num v);

  /// Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
  /// or was pressed down longer ago than then given duration.
  external bool downDuration([num duration]);

  /// Called automatically by Phaser.Keyboard.
  external void processKeyDown(KeyboardEvent event);

  /// Called automatically by Phaser.Keyboard.
  external void processKeyUp(KeyboardEvent event);

  /// Resets the state of this Key.
  /// This sets isDown to false, isUp to true, resets the time to be the current time, and _enables_ the key.
  /// In addition, if it is a "hard reset", it clears clears any callbacks associated with the onDown and onUp events and removes the onHoldCallback.
  external void reset([bool hard]);

  /// Called automatically by Phaser.Keyboard.
  external void update();

  /// Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
  /// or was pressed down longer ago than then given duration.
  external bool upDuration([num duration]);
}

/// The Keyboard class monitors keyboard input and dispatches keyboard events.
/// _Note_: many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.
/// See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.
/// Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.
/// For example the Chrome extension vimium is known to disable Phaser from using the D key. And there are others.
/// So please check your extensions before opening Phaser issues.
@JS("Phaser.Keyboard")
class Keyboard {
  // @Ignore
  Keyboard.fakeConstructor$();

  /// The Keyboard class monitors keyboard input and dispatches keyboard events.
  /// _Note_: many keyboards are unable to process certain combinations of keys due to hardware limitations known as ghosting.
  /// See http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/ for more details.
  /// Also please be aware that certain browser extensions can disable or override Phaser keyboard handling.
  /// For example the Chrome extension vimium is known to disable Phaser from using the D key. And there are others.
  /// So please check your extensions before opening Phaser issues.
  external factory Keyboard(Game game);
  external static num get A;
  external static set A(num v);
  external static num get B;
  external static set B(num v);
  external static num get C;
  external static set C(num v);
  external static num get D;
  external static set D(num v);
  external static num get E;
  external static set E(num v);
  external static num get F;
  external static set F(num v);
  external static num get G;
  external static set G(num v);
  external static num get H;
  external static set H(num v);
  external static num get I;
  external static set I(num v);
  external static num get J;
  external static set J(num v);
  external static num get K;
  external static set K(num v);
  external static num get L;
  external static set L(num v);
  external static num get M;
  external static set M(num v);
  external static num get N;
  external static set N(num v);
  external static num get O;
  external static set O(num v);
  external static num get P;
  external static set P(num v);
  external static num get Q;
  external static set Q(num v);
  external static num get R;
  external static set R(num v);
  external static num get S;
  external static set S(num v);
  external static num get T;
  external static set T(num v);
  external static num get U;
  external static set U(num v);
  external static num get V;
  external static set V(num v);
  external static num get W;
  external static set W(num v);
  external static num get X;
  external static set X(num v);
  external static num get Y;
  external static set Y(num v);
  external static num get Z;
  external static set Z(num v);
  external static num get ZERO;
  external static set ZERO(num v);
  external static num get ONE;
  external static set ONE(num v);
  external static num get TWO;
  external static set TWO(num v);
  external static num get THREE;
  external static set THREE(num v);
  external static num get FOUR;
  external static set FOUR(num v);
  external static num get FIVE;
  external static set FIVE(num v);
  external static num get SIX;
  external static set SIX(num v);
  external static num get SEVEN;
  external static set SEVEN(num v);
  external static num get EIGHT;
  external static set EIGHT(num v);
  external static num get NINE;
  external static set NINE(num v);
  external static num get NUMPAD_0;
  external static set NUMPAD_0(num v);
  external static num get NUMPAD_1;
  external static set NUMPAD_1(num v);
  external static num get NUMPAD_2;
  external static set NUMPAD_2(num v);
  external static num get NUMPAD_3;
  external static set NUMPAD_3(num v);
  external static num get NUMPAD_4;
  external static set NUMPAD_4(num v);
  external static num get NUMPAD_5;
  external static set NUMPAD_5(num v);
  external static num get NUMPAD_6;
  external static set NUMPAD_6(num v);
  external static num get NUMPAD_7;
  external static set NUMPAD_7(num v);
  external static num get NUMPAD_8;
  external static set NUMPAD_8(num v);
  external static num get NUMPAD_9;
  external static set NUMPAD_9(num v);
  external static num get NUMPAD_MULTIPLY;
  external static set NUMPAD_MULTIPLY(num v);
  external static num get NUMPAD_ADD;
  external static set NUMPAD_ADD(num v);
  external static num get NUMPAD_ENTER;
  external static set NUMPAD_ENTER(num v);
  external static num get NUMPAD_SUBTRACT;
  external static set NUMPAD_SUBTRACT(num v);
  external static num get NUMPAD_DECIMAL;
  external static set NUMPAD_DECIMAL(num v);
  external static num get NUMPAD_DIVIDE;
  external static set NUMPAD_DIVIDE(num v);
  external static num get F1;
  external static set F1(num v);
  external static num get F2;
  external static set F2(num v);
  external static num get F3;
  external static set F3(num v);
  external static num get F4;
  external static set F4(num v);
  external static num get F5;
  external static set F5(num v);
  external static num get F6;
  external static set F6(num v);
  external static num get F7;
  external static set F7(num v);
  external static num get F8;
  external static set F8(num v);
  external static num get F9;
  external static set F9(num v);
  external static num get F10;
  external static set F10(num v);
  external static num get F11;
  external static set F11(num v);
  external static num get F12;
  external static set F12(num v);
  external static num get F13;
  external static set F13(num v);
  external static num get F14;
  external static set F14(num v);
  external static num get F15;
  external static set F15(num v);
  external static num get COLON;
  external static set COLON(num v);
  external static num get EQUALS;
  external static set EQUALS(num v);
  external static num get COMMA;
  external static set COMMA(num v);
  external static num get UNDERSCORE;
  external static set UNDERSCORE(num v);
  external static num get PERIOD;
  external static set PERIOD(num v);
  external static num get QUESTION_MARK;
  external static set QUESTION_MARK(num v);
  external static num get TILDE;
  external static set TILDE(num v);
  external static num get OPEN_BRACKET;
  external static set OPEN_BRACKET(num v);
  external static num get BACKWARD_SLASH;
  external static set BACKWARD_SLASH(num v);
  external static num get CLOSED_BRACKET;
  external static set CLOSED_BRACKET(num v);
  external static num get QUOTES;
  external static set QUOTES(num v);
  external static num get BACKSPACE;
  external static set BACKSPACE(num v);
  external static num get TAB;
  external static set TAB(num v);
  external static num get CLEAR;
  external static set CLEAR(num v);
  external static num get ENTER;
  external static set ENTER(num v);
  external static num get SHIFT;
  external static set SHIFT(num v);
  external static num get CONTROL;
  external static set CONTROL(num v);
  external static num get ALT;
  external static set ALT(num v);
  external static num get CAPS_LOCK;
  external static set CAPS_LOCK(num v);
  external static num get ESC;
  external static set ESC(num v);
  external static num get SPACEBAR;
  external static set SPACEBAR(num v);
  external static num get PAGE_UP;
  external static set PAGE_UP(num v);
  external static num get PAGE_DOWN;
  external static set PAGE_DOWN(num v);
  external static num get END;
  external static set END(num v);
  external static num get HOME;
  external static set HOME(num v);
  external static num get LEFT;
  external static set LEFT(num v);
  external static num get UP;
  external static set UP(num v);
  external static num get RIGHT;
  external static set RIGHT(num v);
  external static num get DOWN;
  external static set DOWN(num v);
  external static num get INSERT;
  external static set INSERT(num v);
  external static num get DELETE;
  external static set DELETE(num v);
  external static num get HELP;
  external static set HELP(num v);
  external static num get NUM_LOCK;
  external static set NUM_LOCK(num v);
  external static num get PLUS;
  external static set PLUS(num v);
  external static num get MINUS;
  external static set MINUS(num v);

  /// The context under which the callbacks are run.
  external dynamic get callbackContext;
  external set callbackContext(dynamic v);

  /// Keyboard input will only be processed if enabled.
  /// Default: true
  external bool get enabled;
  external set enabled(bool v);

  /// The most recent DOM event from keydown or keyup. This is updated every time a new key is pressed or released.
  external dynamic get event;
  external set event(dynamic v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// Returns the string value of the most recently pressed key.
  external String get lastChar;
  external set lastChar(String v);

  /// Returns the most recently pressed Key. This is a Phaser.Key object and it changes every time a key is pressed.
  external Key get lastKey;
  external set lastKey(Key v);

  /// This callback is invoked every time a key is pressed down, including key repeats when a key is held down.
  external Function get onDownCallback;
  external set onDownCallback(Function v);

  /// This callback is invoked every time a DOM onkeypress event is raised, which is only for printable keys.
  external Function get onPressCallback;
  external set onPressCallback(Function v);

  /// This callback is invoked every time a key is released.
  external Function get onUpCallback;
  external set onUpCallback(Function v);

  /// The most recent DOM event from keypress.
  external dynamic get pressEvent;
  external set pressEvent(dynamic v);

  /// Add callbacks to the Keyboard handler so that each time a key is pressed down or released the callbacks are activated.
  external void addCallbacks(dynamic context,
      [Function onDown, Function onUp, Function onPress]);

  /// If you need more fine-grained control over a Key you can create a new Phaser.Key object via this method.
  /// The Key object can then be polled, have events attached to it, etc.
  external Key addKey(num keycode);

  /// A practical way to create an object containing user selected hotkeys.
  /// For example,
  /// addKeys( { 'up': Phaser.KeyCode.W, 'down': Phaser.KeyCode.S, 'left': Phaser.KeyCode.A, 'right': Phaser.KeyCode.D } );
  /// would return an object containing properties (`up`, `down`, `left` and `right`) referring to [Phaser.Key] object.
  external dynamic addKeys(dynamic keys);

  /// By default when a key is pressed Phaser will not stop the event from propagating up to the browser.
  /// There are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.
  /// The `addKeyCapture` method enables consuming keyboard event for specific keys so it doesn't bubble up to the the browser
  /// and cause the default browser behavior.
  /// Pass in either a single keycode or an array/hash of keycodes.
  external void addKeyCapture(dynamic keycode);

  /// Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right.
  external CursorKeys createCursorKeys();

  /// Clear all set key captures.
  external void clearCaptures();

  /// Stops the Keyboard event listeners from running (keydown and keyup). They are removed from the window.
  /// Also clears all key captures and currently created Key objects.
  external void destroy();

  /// Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
  /// or was pressed down longer ago than then given duration.
  external bool downDuration(num keycode, [num duration]);

  /// Returns true of the key is currently pressed down. Note that it can only detect key presses on the web browser.
  external bool isDown(num keycode);

  /// Process the keydown event.
  external void processKeyDown(KeyboardEvent event);

  /// Process the keypress event.
  external void processKeyPress(KeyboardEvent event);

  /// Process the keyup event.
  external void processKeyUp(KeyboardEvent event);

  /// Removes callbacks added by [Phaser.Keyboard#addCallbacks addCallbacks] and restores [Phaser.Keyboard#callbackContext callbackContext].
  external void removeCallbacks();

  /// Removes a Key object from the Keyboard manager.
  external void removeKey(num keycode);

  /// Removes an existing key capture.
  external void removeKeyCapture(num keycode);

  /// Resets all Keys.
  external void reset([bool hard]);

  /// Starts the Keyboard event listeners running (keydown, keyup and keypress). They are attached to the window.
  /// This is called automatically by Phaser.Input and should not normally be invoked directly.
  external void start();

  /// Stops the Keyboard event listeners from running (keydown, keyup and keypress). They are removed from the window.
  external void stop();

  /// Updates all currently defined keys.
  external void update();

  /// Returns `true` if the Key was pressed down within the `duration` value given, or `false` if it either isn't down,
  /// or was pressed down longer ago than then given duration.
  external bool upDuration(num keycode, [num duration]);
}

/// A key code represents a physical key on a keyboard.
/// The KeyCode class contains commonly supported keyboard key codes which can be used
/// as keycode`-parameters in several [Phaser.Keyboard] and [Phaser.Key] methods.
/// _Note_: These values should only be used indirectly, eg. as `Phaser.KeyCode.KEY`.
/// Future versions may replace the actual values, such that they remain compatible with `keycode`-parameters.
/// The current implementation maps to the [https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode KeyboardEvent.keyCode] property.
/// _Note_: Use `Phaser.KeyCode.KEY` instead of `Phaser.Keyboard.KEY` to refer to a key code;
/// the latter approach is supported for compatibility.
@JS("Phaser.KeyCode")
class KeyCode {
  // @Ignore
  KeyCode.fakeConstructor$();
  external static num get A;
  external static set A(num v);
  external static num get B;
  external static set B(num v);
  external static num get C;
  external static set C(num v);
  external static num get D;
  external static set D(num v);
  external static num get E;
  external static set E(num v);
  external static num get F;
  external static set F(num v);
  external static num get G;
  external static set G(num v);
  external static num get H;
  external static set H(num v);
  external static num get I;
  external static set I(num v);
  external static num get J;
  external static set J(num v);
  external static num get K;
  external static set K(num v);
  external static num get L;
  external static set L(num v);
  external static num get M;
  external static set M(num v);
  external static num get N;
  external static set N(num v);
  external static num get O;
  external static set O(num v);
  external static num get P;
  external static set P(num v);
  external static num get Q;
  external static set Q(num v);
  external static num get R;
  external static set R(num v);
  external static num get S;
  external static set S(num v);
  external static num get T;
  external static set T(num v);
  external static num get U;
  external static set U(num v);
  external static num get V;
  external static set V(num v);
  external static num get W;
  external static set W(num v);
  external static num get X;
  external static set X(num v);
  external static num get Y;
  external static set Y(num v);
  external static num get Z;
  external static set Z(num v);
  external static num get ZERO;
  external static set ZERO(num v);
  external static num get ONE;
  external static set ONE(num v);
  external static num get TWO;
  external static set TWO(num v);
  external static num get THREE;
  external static set THREE(num v);
  external static num get FOUR;
  external static set FOUR(num v);
  external static num get FIVE;
  external static set FIVE(num v);
  external static num get SIX;
  external static set SIX(num v);
  external static num get SEVEN;
  external static set SEVEN(num v);
  external static num get EIGHT;
  external static set EIGHT(num v);
  external static num get NINE;
  external static set NINE(num v);
  external static num get NUMPAD_0;
  external static set NUMPAD_0(num v);
  external static num get NUMPAD_1;
  external static set NUMPAD_1(num v);
  external static num get NUMPAD_2;
  external static set NUMPAD_2(num v);
  external static num get NUMPAD_3;
  external static set NUMPAD_3(num v);
  external static num get NUMPAD_4;
  external static set NUMPAD_4(num v);
  external static num get NUMPAD_5;
  external static set NUMPAD_5(num v);
  external static num get NUMPAD_6;
  external static set NUMPAD_6(num v);
  external static num get NUMPAD_7;
  external static set NUMPAD_7(num v);
  external static num get NUMPAD_8;
  external static set NUMPAD_8(num v);
  external static num get NUMPAD_9;
  external static set NUMPAD_9(num v);
  external static num get NUMPAD_MULTIPLY;
  external static set NUMPAD_MULTIPLY(num v);
  external static num get NUMPAD_ADD;
  external static set NUMPAD_ADD(num v);
  external static num get NUMPAD_ENTER;
  external static set NUMPAD_ENTER(num v);
  external static num get NUMPAD_SUBTRACT;
  external static set NUMPAD_SUBTRACT(num v);
  external static num get NUMPAD_DECIMAL;
  external static set NUMPAD_DECIMAL(num v);
  external static num get NUMPAD_DIVIDE;
  external static set NUMPAD_DIVIDE(num v);
  external static num get F1;
  external static set F1(num v);
  external static num get F2;
  external static set F2(num v);
  external static num get F3;
  external static set F3(num v);
  external static num get F4;
  external static set F4(num v);
  external static num get F5;
  external static set F5(num v);
  external static num get F6;
  external static set F6(num v);
  external static num get F7;
  external static set F7(num v);
  external static num get F8;
  external static set F8(num v);
  external static num get F9;
  external static set F9(num v);
  external static num get F10;
  external static set F10(num v);
  external static num get F11;
  external static set F11(num v);
  external static num get F12;
  external static set F12(num v);
  external static num get F13;
  external static set F13(num v);
  external static num get F14;
  external static set F14(num v);
  external static num get F15;
  external static set F15(num v);
  external static num get COLON;
  external static set COLON(num v);
  external static num get EQUALS;
  external static set EQUALS(num v);
  external static num get COMMA;
  external static set COMMA(num v);
  external static num get UNDERSCORE;
  external static set UNDERSCORE(num v);
  external static num get PERIOD;
  external static set PERIOD(num v);
  external static num get QUESTION_MARK;
  external static set QUESTION_MARK(num v);
  external static num get TILDE;
  external static set TILDE(num v);
  external static num get OPEN_BRACKET;
  external static set OPEN_BRACKET(num v);
  external static num get BACKWARD_SLASH;
  external static set BACKWARD_SLASH(num v);
  external static num get CLOSED_BRACKET;
  external static set CLOSED_BRACKET(num v);
  external static num get QUOTES;
  external static set QUOTES(num v);
  external static num get BACKSPACE;
  external static set BACKSPACE(num v);
  external static num get TAB;
  external static set TAB(num v);
  external static num get CLEAR;
  external static set CLEAR(num v);
  external static num get ENTER;
  external static set ENTER(num v);
  external static num get SHIFT;
  external static set SHIFT(num v);
  external static num get CONTROL;
  external static set CONTROL(num v);
  external static num get ALT;
  external static set ALT(num v);
  external static num get CAPS_LOCK;
  external static set CAPS_LOCK(num v);
  external static num get ESC;
  external static set ESC(num v);
  external static num get SPACEBAR;
  external static set SPACEBAR(num v);
  external static num get PAGE_UP;
  external static set PAGE_UP(num v);
  external static num get PAGE_DOWN;
  external static set PAGE_DOWN(num v);
  external static num get END;
  external static set END(num v);
  external static num get HOME;
  external static set HOME(num v);
  external static num get LEFT;
  external static set LEFT(num v);
  external static num get UP;
  external static set UP(num v);
  external static num get RIGHT;
  external static set RIGHT(num v);
  external static num get DOWN;
  external static set DOWN(num v);
  external static num get INSERT;
  external static set INSERT(num v);
  external static num get DELETE;
  external static set DELETE(num v);
  external static num get HELP;
  external static set HELP(num v);
  external static num get NUM_LOCK;
  external static set NUM_LOCK(num v);
  external static num get PLUS;
  external static set PLUS(num v);
  external static num get MINUS;
  external static set MINUS(num v);
}

/// Creates a new Line object with a start and an end point.
@JS("Phaser.Line")
class Line {
  // @Ignore
  Line.fakeConstructor$();

  /// Creates a new Line object with a start and an end point.
  external factory Line([num x1, num y1, num x2, num y2]);

  /// Gets the angle of the line in radians.
  external num get angle;
  external set angle(num v);

  /// The end point of the line.
  external PhaserPoint get end;
  external set end(Point v);

  /// Gets the height of this bounds of this line.
  external num get height;
  external set height(num v);

  /// Gets the left-most point of this line.
  external num get left;
  external set left(num v);

  /// Gets the length of the line segment.
  external num get length;
  external set length(num v);

  /// Gets the angle in radians of the normal of this line (line.angle - 90 degrees.)
  external num get normalAngle;
  external set normalAngle(num v);

  /// Gets the x component of the left-hand normal of this line.
  external num get normalX;
  external set normalX(num v);

  /// Gets the y component of the left-hand normal of this line.
  external num get normalY;
  external set normalY(num v);

  /// Gets the perpendicular slope of the line (x/y).
  external num get perpSlope;
  external set perpSlope(num v);

  /// Gets the right-most point of this line.
  external num get right;
  external set right(num v);

  /// Gets the slope of the line (y/x).
  external num get slope;
  external set slope(num v);

  /// The start point of the line.
  external PhaserPoint get start;
  external set start(Point v);

  /// Gets the top-most point of this line.
  external num get top;
  external set top(num v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// Gets the width of this bounds of this line.
  external num get width;
  external set width(num v);

  /// Gets the x coordinate of the top left of the bounds around this line.
  external num get x;
  external set x(num v);

  /// Gets the y coordinate of the top left of the bounds around this line.
  external num get y;
  external set y(num v);

  /// Finds the closest intersection between the Line and a Rectangle shape, or a rectangle-like
  /// object, such as a Sprite or Body.
  external static Point intersectionWithRectangle(Line line, Rectangle rect,
      [Point result]);

  /// Checks for intersection between two lines as defined by the given start and end points.
  /// If asSegment is true it will check for line segment intersection. If asSegment is false it will check for line intersection.
  /// Returns the intersection segment of AB and EF as a Point, or null if there is no intersection.
  /// Adapted from code by Keith Hair
  external static Point intersectsPoints(Point a, Point b, Point e, Point f,
      [bool asSegment, Point result]);

  /// Checks for intersection between this line and another Line.
  /// If asSegment is true it will check for segment intersection. If asSegment is false it will check for line intersection.
  /// Returns the intersection segment of AB and EF as a Point, or null if there is no intersection.
  /*external static Point intersects(Line a, Line b, [bool asSegment, Point result]);*/
  /// Checks for intersection between this line and another Line.
  /// If asSegment is true it will check for segment intersection. If asSegment is false it will check for line intersection.
  /// Returns the intersection segment of AB and EF as a Point, or null if there is no intersection.
  /*external Point intersects(Line line, [bool asSegment, Point result]);*/
  external Point intersects(Line a_line,
      [dynamic /*Line|bool*/ b_asSegment,
      dynamic /*bool|Point*/ asSegment_result,
      Point result]);
  external static bool intersectsRectangle(Line line, Rectangle rect);
  /*external static num reflect(Line a, Line b);*/
  /// Returns the reflected angle between two lines.
  /// This is the outgoing angle based on the angle of this line and the normalAngle of the given line.
  /*external num reflect(Line line);*/
  external num reflect(Line a_line, [Line b]);
  external Line centerOn(num x, num y);
  external Line clone(Line output);
  external List<dynamic> coordinatesOnLine(num stepRate, List<dynamic> results);
  external Line fromAngle(num x, num y, num angle, num length);
  external Line fromPoints(dynamic start, dynamic end);
  external Line fromSprite(Sprite startSprite, Sprite endSprite,
      [bool useCenter]);
  external Point midPoint([Point out]);
  external bool pointOnLine(num x, num y, [num epsilon]);
  external bool pointOnSegment(num x, num y, [num epsilon]);
  external Point random([Point out]);

  /// Rotates the line by the amount specified in `angle`.
  /// Rotation takes place from the center of the line.
  /// If you wish to rotate around a different point see Line.rotateAround.
  /// If you wish to rotate the ends of the Line then see Line.start.rotate or Line.end.rotate.
  external Line rotate(num angle, [bool asDegrees]);

  /// Rotates the line by the amount specified in `angle`.
  /// Rotation takes place around the coordinates given.
  external Line rotateAround(num x, num y, num angle, [bool asDegrees]);

  /// Sets the components of the Line to the specified values.
  external Line setTo([num x1, num y1, num x2, num y2]);
}

/// A basic Linked List data structure.
/// This implementation _modifies_ the `prev` and `next` properties of each item added:
/// - The `prev` and `next` properties must be writable and should not be used for any other purpose.
/// - Items _cannot_ be added to multiple LinkedLists at the same time.
/// - Only objects can be added.
@JS("Phaser.LinkedList")
class LinkedList {
  // @Ignore
  LinkedList.fakeConstructor$();

  /// First element in the list.
  external dynamic get first;
  external set first(dynamic v);

  /// Last element in the list.
  external dynamic get last;
  external set last(dynamic v);

  /// Next element in the list.
  external dynamic get next;
  external set next(dynamic v);

  /// Previous element in the list.
  external dynamic get prev;
  external set prev(dynamic v);

  /// Number of elements in the list.
  external num get total;
  external set total(num v);

  /// Adds a new element to this linked list.
  external dynamic add(dynamic item);

  /// Calls a function on all members of this list, using the member as the context for the callback.
  /// The function must exist on the member.
  external void callAll(Function callback);

  /// Removes the given element from this linked list if it exists.
  external void remove(dynamic item);

  /// Resets the first, last, next and previous node pointers in this list.
  external void reset();
}

/// The Loader handles loading all external content such as Images, Sounds, Texture Atlases and data files.
/// The loader uses a combination of tag loading (eg. Image elements) and XHR and provides progress and completion callbacks.
/// Parallel loading (see [Phaser.Loader#enableParallel enableParallel]) is supported and enabled by default.
/// Load-before behavior of parallel resources is controlled by synchronization points as discussed in [Phaser.Loader#withSyncPoint withSyncPoint].
/// Texture Atlases can be created with tools such as [Texture Packer](https://www.codeandweb.com/texturepacker/phaser) and
/// [Shoebox](http://renderhjs.net/shoebox/)
@JS("Phaser.Loader")
class Loader {
  // @Ignore
  Loader.fakeConstructor$();

  /// The Loader handles loading all external content such as Images, Sounds, Texture Atlases and data files.
  /// The loader uses a combination of tag loading (eg. Image elements) and XHR and provides progress and completion callbacks.
  /// Parallel loading (see [Phaser.Loader#enableParallel enableParallel]) is supported and enabled by default.
  /// Load-before behavior of parallel resources is controlled by synchronization points as discussed in [Phaser.Loader#withSyncPoint withSyncPoint].
  /// Texture Atlases can be created with tools such as [Texture Packer](https://www.codeandweb.com/texturepacker/phaser) and
  /// [Shoebox](http://renderhjs.net/shoebox/)
  external factory Loader(Game game);
  external static num get PHYSICS_LIME_CORONA_JSON;
  external static set PHYSICS_LIME_CORONA_JSON(num v);
  external static num get PHYSICS_PHASER_JSON;
  external static set PHYSICS_PHASER_JSON(num v);
  external static num get TEXTURE_ATLAS_JSON_ARRAY;
  external static set TEXTURE_ATLAS_JSON_ARRAY(num v);
  external static num get TEXTURE_ATLAS_JSON_HASH;
  external static set TEXTURE_ATLAS_JSON_HASH(num v);
  external static num get TEXTURE_ATLAS_XML_STARLING;
  external static set TEXTURE_ATLAS_XML_STARLING(num v);
  external static num get TEXTURE_ATLAS_JSON_PYXEL;
  external static set TEXTURE_ATLAS_JSON_PYXEL(num v);

  /// If you want to append a URL before the path of any asset you can set this here.
  /// Useful if allowing the asset base url to be configured outside of the game code.
  /// The string _must_ end with a "/".
  external String get baseURL;
  external set baseURL(String v);

  /// Local reference to the Phaser.Cache.
  external Cache get cache;
  external set cache(Cache v);

  /// The crossOrigin value applied to loaded images. Very often this needs to be set to 'anonymous'.
  external dynamic /*bool|String*/ get crossOrigin;
  external set crossOrigin(dynamic /*bool|String*/ v);

  /// If true (the default) then parallel downloading will be enabled.
  /// To disable all parallel downloads this must be set to false prior to any resource being loaded.
  external bool get enableParallel;
  external set enableParallel(bool v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// True if all assets in the queue have finished loading.
  external bool get hasLoaded;
  external set hasLoaded(bool v);

  /// Used to map the application mime-types to to the Accept header in XHR requests.
  /// If you don't require these mappings, or they cause problems on your server, then
  /// remove them from the headers object and the XHR request will not try to use them.
  /// This object can also be used to set the `X-Requested-With` header to
  /// `XMLHttpRequest` (or any other value you need). To enable this do:
  /// ```javascript
  /// this.load.headers.requestedWith = 'XMLHttpRequest'
  /// ```
  /// before adding anything to the Loader. The XHR loader will then call:
  /// ```javascript
  /// setRequestHeader('X-Requested-With', this.headers['requestedWith'])
  /// ```
  /// Default: {"undefined":"application/xml"}
  external dynamic get headers;
  external set headers(dynamic v);

  /// True if the Loader is in the process of loading the queue.
  external bool get isLoading;
  external set isLoading(bool v);

  /// The number of concurrent / parallel resources to try and fetch at once.
  /// Many current browsers limit 6 requests per domain; this is slightly conservative.
  /// This should generally be left at the default, but can be set to a higher limit for specific use-cases. Just be careful when setting large values as different browsers could behave differently.
  external num get maxParallelDownloads;
  external set maxParallelDownloads(num v);

  /// This event is dispatched immediately before a file starts loading.
  /// It's possible the file may fail (eg. download error, invalid format) after this event is sent.
  /// Params: `(progress, file key, file url)`
  external Signal get onFileStart;
  external set onFileStart(Signal v);

  /// This event is dispatched when a file has either loaded or failed to load.
  /// Any function bound to this will receive the following parameters:
  /// progress, file key, success?, total loaded files, total files
  /// Where progress is a number between 1 and 100 (inclusive) representing the percentage of the load.
  external Signal get onFileComplete;
  external set onFileComplete(Signal v);

  /// This event is dispatched when a file (or pack) errors as a result of the load request.
  /// For files it will be triggered before `onFileComplete`. For packs it will be triggered before `onPackComplete`.
  /// Params: `(file key, file)`
  external Signal get onFileError;
  external set onFileError(Signal v);

  /// This event is dispatched when the final file in the load queue has either loaded or failed.
  external Signal get onLoadComplete;
  external set onLoadComplete(Signal v);

  /// This event is dispatched when the loading process starts: before the first file has been requested,
  /// but after all the initial packs have been loaded.
  external Signal get onLoadStart;
  external set onLoadStart(Signal v);

  /// This event is dispatched when an asset pack has either loaded or failed to load.
  /// This is called when the asset pack manifest file has loaded and successfully added its contents to the loader queue.
  /// Params: `(pack key, success?, total packs loaded, total packs)`
  external Signal get onPackComplete;
  external set onPackComplete(Signal v);

  /// The value of `path`, if set, is placed before any _relative_ file path given. For example:
  /// ```javascript
  /// load.path = "images/sprites/";
  /// load.image("ball", "ball.png");
  /// load.image("tree", "level1/oaktree.png");
  /// load.image("boom", "http://server.com/explode.png");
  /// ```
  /// Would load the `ball` file from `images/sprites/ball.png` and the tree from
  /// `images/sprites/level1/oaktree.png` but the file `boom` would load from the URL
  /// given as it's an absolute URL.
  /// Please note that the path is added before the filename but *after* the baseURL (if set.)
  /// The string _must_ end with a "/".
  external String get path;
  external set path(String v);

  /// You can optionally link a progress sprite with [Phaser.Loader#setPreloadSprite setPreloadSprite].
  /// This property is an object containing: sprite, rect, direction, width and height
  external dynamic get preloadSprite;
  external set preloadSprite(dynamic v);

  /// The rounded load progress percentage value (from 0 to 100). See [Phaser.Loader#progressFloat].
  external num get progress;
  external set progress(num v);

  /// The non-rounded load progress value (from 0.0 to 100.0).
  /// A general indicator of the progress.
  /// It is possible for the progress to decrease, after `onLoadStart`, if more files are dynamically added.
  external num get progressFloat;
  external set progressFloat(num v);

  /// If true all calls to Loader.reset will be ignored. Useful if you need to create a load queue before swapping to a preloader state.
  external bool get resetLocked;
  external set resetLocked(bool v);

  /// If true and if the browser supports XDomainRequest, it will be used in preference for XHR.
  /// This is only relevant for IE 9 and should _only_ be enabled for IE 9 clients when required by the server/CDN.
  external bool get useXDomainRequest;
  external set useXDomainRequest(bool v);

  /// Informs the loader that the given file resource has been fetched and processed;
  /// or such a request has failed.
  external void asyncComplete(dynamic file, [String errorMessage]);

  /// Add a synchronization point to a specific file/asset in the load queue.
  /// This has no effect on already loaded assets.
  external Loader addSyncPoint(String type, String key);

  /// Internal function that adds a new entry to the file list. Do not call directly.
  external Loader addToFileList(String type, String key,
      [String url, dynamic properties, bool overwrite, String extension]);

  /// Adds a Texture Atlas file to the current load queue.
  /// To create the Texture Atlas you can use tools such as:
  /// [Texture Packer](https://www.codeandweb.com/texturepacker/phaser)
  /// [Shoebox](http://renderhjs.net/shoebox/)
  /// If using Texture Packer we recommend you enable "Trim sprite names".
  /// If your atlas software has an option to "rotate" the resulting frames, you must disable it.
  /// You can choose to either load the data externally, by providing a URL to a json file.
  /// Or you can pass in a JSON object or String via the `atlasData` parameter.
  /// If you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.
  /// If URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getImage(key)`. JSON files are automatically parsed upon load.
  /// If you need to control when the JSON is parsed then use `Loader.text` instead and parse the JSON file as needed.
  /// The URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the textureURL isn't specified then the Loader will take the key and create a filename from that.
  /// For example if the key is "player" and textureURL is null then the Loader will set the URL to be "player.png".
  /// The same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will
  /// set the atlasURL to be the key. For example if the key is "player" the atlasURL will be set to "player.json".
  /// If you do not desire this action then provide URLs and / or a data object.
  external Loader atlas(String key,
      [String textureURL, String atlasURL, dynamic atlasData, num format]);

  /// Adds a Texture Atlas file to the current load queue.
  /// Unlike `Loader.atlasJSONHash` this call expects the atlas data to be in a JSON Array format.
  /// To create the Texture Atlas you can use tools such as:
  /// [Texture Packer](https://www.codeandweb.com/texturepacker/phaser)
  /// [Shoebox](http://renderhjs.net/shoebox/)
  /// If using Texture Packer we recommend you enable "Trim sprite names".
  /// If your atlas software has an option to "rotate" the resulting frames, you must disable it.
  /// You can choose to either load the data externally, by providing a URL to a json file.
  /// Or you can pass in a JSON object or String via the `atlasData` parameter.
  /// If you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.
  /// If URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getImage(key)`. JSON files are automatically parsed upon load.
  /// If you need to control when the JSON is parsed then use `Loader.text` instead and parse the JSON file as needed.
  /// The URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the textureURL isn't specified then the Loader will take the key and create a filename from that.
  /// For example if the key is "player" and textureURL is null then the Loader will set the URL to be "player.png".
  /// The same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will
  /// set the atlasURL to be the key. For example if the key is "player" the atlasURL will be set to "player.json".
  /// If you do not desire this action then provide URLs and / or a data object.
  external Loader atlasJSONArray(String key,
      [String textureURL, String atlasURL, dynamic atlasData]);

  /// Adds a Texture Atlas file to the current load queue.
  /// Unlike `Loader.atlas` this call expects the atlas data to be in a JSON Hash format.
  /// To create the Texture Atlas you can use tools such as:
  /// [Texture Packer](https://www.codeandweb.com/texturepacker/phaser)
  /// [Shoebox](http://renderhjs.net/shoebox/)
  /// If using Texture Packer we recommend you enable "Trim sprite names".
  /// If your atlas software has an option to "rotate" the resulting frames, you must disable it.
  /// You can choose to either load the data externally, by providing a URL to a json file.
  /// Or you can pass in a JSON object or String via the `atlasData` parameter.
  /// If you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.
  /// If URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getImage(key)`. JSON files are automatically parsed upon load.
  /// If you need to control when the JSON is parsed then use `Loader.text` instead and parse the JSON file as needed.
  /// The URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the textureURL isn't specified then the Loader will take the key and create a filename from that.
  /// For example if the key is "player" and textureURL is null then the Loader will set the URL to be "player.png".
  /// The same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will
  /// set the atlasURL to be the key. For example if the key is "player" the atlasURL will be set to "player.json".
  /// If you do not desire this action then provide URLs and / or a data object.
  external Loader atlasJSONHash(String key,
      [String textureURL, String atlasURL, dynamic atlasData]);

  /// Adds a Texture Atlas file to the current load queue.
  /// This call expects the atlas data to be in the Starling XML data format.
  /// To create the Texture Atlas you can use tools such as:
  /// [Texture Packer](https://www.codeandweb.com/texturepacker/phaser)
  /// [Shoebox](http://renderhjs.net/shoebox/)
  /// If using Texture Packer we recommend you enable "Trim sprite names".
  /// If your atlas software has an option to "rotate" the resulting frames, you must disable it.
  /// You can choose to either load the data externally, by providing a URL to an xml file.
  /// Or you can pass in an XML object or String via the `atlasData` parameter.
  /// If you pass a String the data is automatically run through `Loader.parseXML` and then immediately added to the Phaser.Cache.
  /// If URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getImage(key)`. XML files are automatically parsed upon load.
  /// If you need to control when the XML is parsed then use `Loader.text` instead and parse the XML file as needed.
  /// The URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the textureURL isn't specified then the Loader will take the key and create a filename from that.
  /// For example if the key is "player" and textureURL is null then the Loader will set the URL to be "player.png".
  /// The same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will
  /// set the atlasURL to be the key. For example if the key is "player" the atlasURL will be set to "player.xml".
  /// If you do not desire this action then provide URLs and / or a data object.
  external Loader atlasXML(String key,
      [String textureURL, String atlasURL, dynamic atlasData]);

  /// Adds an audio file to the current load queue.
  /// The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getSound(key)`.
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// Mobile warning: There are some mobile devices (certain iPad 2 and iPad Mini revisions) that cannot play 48000 Hz audio.
  /// When they try to play the audio becomes extremely distorted and buzzes, eventually crashing the sound system.
  /// The solution is to use a lower encoding rate such as 44100 Hz.
  /// If an array is specified then the first URI (or URI + mime pair) that is device-compatible will be selected.
  /// For example: `"jump.mp3"`, `['jump.mp3', 'jump.ogg', 'jump.m4a']`, or `[{uri: "data:<opus_resource>", type: 'opus'}, 'fallback.mp3']`.
  /// BLOB and DATA URIs can be used but only support automatic detection when used in the pair form; otherwise the format must be manually checked before adding the resource.
  /// Audio files can't be played until they are decoded and, if specified, this enables immediate decoding. Decoding is a non-blocking async process, however it consumes huge amounts of CPU time on mobiles especially. - Default: true
  external Loader audio(
      String key, dynamic /*String|List<String>|dynamic*/ urls,
      [bool autoDecode]);

  /// A legacy alias for Loader.audioSprite. Please see that method for documentation.
  /// Audio files can't be played until they are decoded and, if specified, this enables immediate decoding. Decoding is a non-blocking async process, however it consumes huge amounts of CPU time on mobiles especially. - Default: true
  external Loader audiosprite(String key, List<String> urls,
      [String jsonURL, dynamic /*String|dynamic*/ jsonData, bool autoDecode]);

  /// Adds a binary file to the current load queue.
  /// The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getBinary(key)`.
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
  /// and no URL is given then the Loader will set the URL to be "alien.bin". It will always add `.bin` as the extension.
  /// If you do not desire this action then provide a URL.
  /// It will be loaded via xhr with a responseType of "arraybuffer". You can specify an optional callback to process the file after load.
  /// When the callback is called it will be passed 2 parameters: the key of the file and the file data.
  /// WARNING: If a callback is specified the data will be set to whatever it returns. Always return the data object, even if you didn't modify it.
  external Loader binary(String key,
      [String url, Function callback, dynamic callbackContext]);

  /// Adds Bitmap Font files to the current load queue.
  /// To create the Bitmap Font files you can use:
  /// BMFont (Windows, free): http://www.angelcode.com/products/bmfont/
  /// Glyph Designer (OS X, commercial): http://www.71squared.com/en/glyphdesigner
  /// Littera (Web-based, free): http://kvazars.com/littera/
  /// You can choose to either load the data externally, by providing a URL to an xml file.
  /// Or you can pass in an XML object or String via the `xmlData` parameter.
  /// If you pass a String the data is automatically run through `Loader.parseXML` and then immediately added to the Phaser.Cache.
  /// If URLs are provided the files are **not** loaded immediately after calling this method, but are added to the load queue.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getBitmapFont(key)`. XML files are automatically parsed upon load.
  /// If you need to control when the XML is parsed then use `Loader.text` instead and parse the XML file as needed.
  /// The URLs can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the textureURL isn't specified then the Loader will take the key and create a filename from that.
  /// For example if the key is "megaFont" and textureURL is null then the Loader will set the URL to be "megaFont.png".
  /// The same is true for the atlasURL. If atlasURL isn't specified and no atlasData has been provided then the Loader will
  /// set the atlasURL to be the key. For example if the key is "megaFont" the atlasURL will be set to "megaFont.xml".
  /// If you do not desire this action then provide URLs and / or a data object.
  external Loader bitmapFont(String key,
      [String textureURL,
      String atlasURL,
      dynamic atlasData,
      num xSpacing,
      num ySpacing]);

  /// Check whether a file/asset with a specific key is queued to be loaded.
  /// To access a loaded asset use Phaser.Cache, eg. [Phaser.Cache#checkImageKey]
  external bool checkKeyExists(String type, String key);

  /// Successfully loaded a CSV file - only used for certain types.
  external void csvLoadComplete(dynamic file, HttpRequest xhr);

  /// Called when a file has been downloaded and needs to be processed further.
  external void fileComplete(dynamic file, HttpRequest xhr);

  /// Error occurred when loading a file.
  external void fileError(dynamic file, HttpRequest xhr, String reason);

  /// The loading is all finished.
  external void finishedLoading([bool abnormal]);

  /// Find a file/asset with a specific key.
  /// Only assets in the download file queue will be found.
  /// The index may change and should only be used immediately following this call.
  external dynamic getAsset(String type, String key);

  /// Get the queue-index of the file/asset with a specific key.
  /// Only assets in the download file queue will be found.
  /// The index may change and should only be used immediately following this call
  external num getAssetIndex(String type, String key);

  /// Give a bunch of URLs, return the first URL that has an extension this device thinks it can play.
  /// It is assumed that the device can play "blob:" or "data:" URIs - There is no mime-type checking on data URIs.
  external void getAudioURL(List<dynamic> urls);

  /// Adds an Image to the current load queue.
  /// The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.
  /// Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the image via `Cache.getImage(key)`
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
  /// and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension.
  /// If you do not desire this action then provide a URL.
  /// This method also supports passing in a texture object as the `url` argument. This allows you to load
  /// compressed textures into Phaser. You can also use `Loader.texture` to do this.
  /// Compressed Textures are a WebGL only feature, and require 3rd party tools to create.
  /// Available tools include Texture Packer, PVRTexTool, DirectX Texture Tool and Mali Texture Compression Tool.
  /// Supported texture compression formats are: PVRTC, S3TC and ETC1.
  /// Supported file formats are: PVR, DDS, KTX and PKM.
  /// The formats that support all 3 compression algorithms are PVR and KTX.
  /// PKM only supports ETC1, and DDS only S3TC for now.
  /// The texture path object looks like this:
  /// ```javascript
  /// load.image('factory', {
  /// etc1: 'assets/factory_etc1.pkm',
  /// s3tc: 'assets/factory_dxt1.pvr',
  /// pvrtc: 'assets/factory_pvrtc.pvr',
  /// truecolor: 'assets/factory.png'
  /// });
  /// ```
  /// The `truecolor` property points to a standard PNG file, that will be used if none of the
  /// compressed formats are supported by the browser / GPU.
  external Loader image(String key,
      [dynamic /*String|dynamic*/ url, bool overwrite]);

  /// Generate an image from a BitmapData object and add it to the current load queue.
  external Loader imageFromBitmapData(String key, BitmapData bitmapData,
      [bool overwrite]);

  /// Generate a grid image and add it to the current load queue.
  external Loader imageFromGrid(
      String key, num width, num height, num cellWidth, num cellHeight,
      [String color]);

  /// Generate a texture image and add it to the current load queue.
  external Loader imageFromTexture(
      String key, dynamic data, num pixelWidth, num pixelHeight,
      [num palette]);

  /// Adds an array of images to the current load queue.
  /// It works by passing each element of the array to the Loader.image method.
  /// The files are **not** loaded immediately after calling this method. The files are added to the queue ready to be loaded when the loader starts.
  /// Phaser can load all common image types: png, jpg, gif and any other format the browser can natively handle.
  /// The keys must be unique Strings. They are used to add the files to the Phaser.Cache upon successful load.
  /// Retrieve the images via `Cache.getImage(key)`
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
  /// and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension.
  /// If you do not desire this action then provide a URL.
  external Loader images(List<String> keys, [List<String> urls]);

  /// Adds a JSON file to the current load queue.
  /// The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getJSON(key)`. JSON files are automatically parsed upon load.
  /// If you need to control when the JSON is parsed then use `Loader.text` instead and parse the text file as needed.
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
  /// and no URL is given then the Loader will set the URL to be "alien.json". It will always add `.json` as the extension.
  /// If you do not desire this action then provide a URL.
  external Loader json(String key, [String url, bool overwrite]);

  /// Successfully loaded a JSON file - only used for certain types.
  external void jsonLoadComplete(dynamic file, HttpRequest xhr);

  /// Continue async loading through an Audio tag.
  external void loadAudioTag(dynamic file);

  /// Start fetching a resource.
  /// All code paths, async or otherwise, from this function must return to `asyncComplete`.
  external void loadFile(dynamic file);

  /// Continue async loading through an Image tag.
  external void loadImageTag(dynamic file);

  /// Add a JSON resource pack ('packfile') to the Loader.
  /// A packfile is a JSON file that contains a list of assets to the be loaded.
  /// Please see the example 'loader/asset pack' in the Phaser Examples repository.
  /// Packs are always put before the first non-pack file that is not loaded / loading.
  /// This means that all packs added before any loading has started are added to the front
  /// of the file queue, in the order added.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// The URL of the packfile can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  external Loader pack(String key,
      [String url, dynamic data, dynamic callbackContext]);

  /// Parses string data as XML.
  external XmlDocument parseXml(String data);

  /// Adds a physics data file to the current load queue.
  /// The data must be in `Lime + Corona` JSON format. [Physics Editor](https://www.codeandweb.com) by code'n'web exports in this format natively.
  /// You can choose to either load the data externally, by providing a URL to a json file.
  /// Or you can pass in a JSON object or String via the `data` parameter.
  /// If you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.
  /// If a URL is provided the file is **not** loaded immediately after calling this method, but is added to the load queue.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getJSON(key)`. JSON files are automatically parsed upon load.
  /// If you need to control when the JSON is parsed then use `Loader.text` instead and parse the text file as needed.
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the URL isn't specified and no data is given then the Loader will take the key and create a filename from that.
  /// For example if the key is "alien" and no URL or data is given then the Loader will set the URL to be "alien.json".
  /// It will always use `.json` as the extension.
  /// If you do not desire this action then provide a URL or data object.
  external Loader physics(String key,
      [String url, dynamic data, String format]);

  /// Process the next item(s) in the file/asset queue.
  /// Process the queue and start loading enough items to fill up the inflight queue.
  /// If a sync-file is encountered then subsequent asset processing is delayed until it completes.
  /// The exception to this rule is that packfiles can be downloaded (but not processed) even if
  /// there appear other sync files (ie. packs) - this enables multiple packfiles to be fetched in parallel.
  /// such as during the start phaser.
  external void processLoadQueue();

  /// Process pack data. This will usually modify the file list.
  external void processPack(dynamic pack);

  /// Remove all file loading requests - this is _insufficient_ to stop current loading. Use `reset` instead.
  external void removeAll();

  /// Remove a file/asset from the loading queue.
  /// A file that is loaded or has started loading cannot be removed.
  external void removeFile(String type, String key);

  /// Internal function that replaces an existing entry in the file list with a new one. Do not call directly.
  external void replaceInFileList(
      String type, String key, String url, dynamic properties);

  /// Reset the loader and clear any queued assets. If `Loader.resetLocked` is true this operation will abort.
  /// This will abort any loading and clear any queued assets.
  /// Optionally you can clear any associated events.
  external void reset([bool hard, bool clearEvents]);

  /// Called automatically by ScaleManager when the game resizes in RESIZE scalemode.
  /// This can be used to adjust the preloading sprite size, eg.
  external void resize();

  /// Adds a JavaScript file to the current load queue.
  /// The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.
  /// The key must be a unique String.
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
  /// and no URL is given then the Loader will set the URL to be "alien.js". It will always add `.js` as the extension.
  /// If you do not desire this action then provide a URL.
  /// Upon successful load the JavaScript is automatically turned into a script tag and executed, so be careful what you load!
  /// A callback, which will be invoked as the script tag has been created, can also be specified.
  /// The callback must return relevant `data`.
  external Loader script(String key,
      [String url, Function callback, dynamic callbackContext]);

  /// Adds a fragment shader file to the current load queue.
  /// The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getShader(key)`.
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "blur"
  /// and no URL is given then the Loader will set the URL to be "blur.frag". It will always add `.frag` as the extension.
  /// If you do not desire this action then provide a URL.
  external Loader shader(String key, [String url, bool overwrite]);

  /// Set a Sprite to be a "preload" sprite by passing it to this method.
  /// A "preload" sprite will have its width or height crop adjusted based on the percentage of the loader in real-time.
  /// This allows you to easily make loading bars for games.
  /// The sprite will automatically be made visible when calling this.
  external void setPreloadSprite(dynamic /*Sprite|Image*/ sprite,
      [num direction]);

  /// Adds a Sprite Sheet to the current load queue.
  /// The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.
  /// To clarify the terminology that Phaser uses: A Sprite Sheet is an image containing frames, usually of an animation, that are all equal
  /// dimensions and often in sequence. For example if the frame size is 32x32 then every frame in the sprite sheet will be that size.
  /// Sometimes (outside of Phaser) the term "sprite sheet" is used to refer to a texture atlas.
  /// A Texture Atlas works by packing together images as best it can, using whatever frame sizes it likes, often with cropping and trimming
  /// the frames in the process. Software such as Texture Packer, Flash CC or Shoebox all generate texture atlases, not sprite sheets.
  /// If you've got an atlas then use `Loader.atlas` instead.
  /// The key must be a unique String. It is used to add the image to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getImage(key)`. Sprite sheets, being image based, live in the same Cache as all other Images.
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
  /// and no URL is given then the Loader will set the URL to be "alien.png". It will always add `.png` as the extension.
  /// If you do not desire this action then provide a URL.
  external Loader spritesheet(
      String key, String url, num frameWidth, num frameHeight,
      [num frameMax, num margin, num spacing, num skipFrames]);

  /// Start loading the assets. Normally you don't need to call this yourself as the StateManager will do so.
  external void start();

  /// Adds a Text file to the current load queue.
  /// The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getText(key)`
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
  /// and no URL is given then the Loader will set the URL to be "alien.txt". It will always add `.txt` as the extension.
  /// If you do not desire this action then provide a URL.
  external Loader text(String key, [String url, bool overwrite]);

  /// Adds a Compressed Texture Image to the current load queue.
  /// Compressed Textures are a WebGL only feature, and require 3rd party tools to create.
  /// Available tools include Texture Packer, PVRTexTool, DirectX Texture Tool and Mali Texture Compression Tool.
  /// Supported texture compression formats are: PVRTC, S3TC and ETC1.
  /// Supported file formats are: PVR, DDS, KTX and PKM.
  /// The formats that support all 3 compression algorithms are PVR and KTX.
  /// PKM only supports ETC1, and DDS only S3TC for now.
  /// The texture path object looks like this:
  /// ```javascript
  /// load.texture('factory', {
  /// etc1: 'assets/factory_etc1.pkm',
  /// s3tc: 'assets/factory_dxt1.pvr',
  /// pvrtc: 'assets/factory_pvrtc.pvr',
  /// truecolor: 'assets/factory.png'
  /// });
  /// ```
  /// The `truecolor` property points to a standard PNG file, that will be used if none of the
  /// compressed formats are supported by the browser / GPU.
  /// The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the image via `Cache.getImage(key)`
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
  /// and no URL is given then the Loader will set the URL to be "alien.pvr". It will always add `.pvr` as the extension.
  /// If you do not desire this action then provide a URL.
  external Loader texture(String key, dynamic object, [bool overwrite]);

  /// Adds a Tile Map data file to the current load queue.
  /// Phaser can load data in two different formats: CSV and Tiled JSON.
  /// Tiled is a free software package, specifically for creating tilemaps, and is available from http://www.mapeditor.org
  /// You can choose to either load the data externally, by providing a URL to a json file.
  /// Or you can pass in a JSON object or String via the `data` parameter.
  /// If you pass a String the data is automatically run through `JSON.parse` and then immediately added to the Phaser.Cache.
  /// If a URL is provided the file is **not** loaded immediately after calling this method, but is added to the load queue.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getTilemapData(key)`. JSON files are automatically parsed upon load.
  /// If you need to control when the JSON is parsed then use `Loader.text` instead and parse the text file as needed.
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the URL isn't specified and no data is given then the Loader will take the key and create a filename from that.
  /// For example if the key is "level1" and no URL or data is given then the Loader will set the URL to be "level1.json".
  /// If you set the format to be Tilemap.CSV it will set the URL to be "level1.csv" instead.
  /// If you do not desire this action then provide a URL or data object.
  external Loader tilemap(String key, [String url, dynamic data, num format]);

  /// Returns the number of files that have already been loaded, even if they errored.
  external num totalLoadedFiles();

  /// Returns the number of asset packs that have already been loaded, even if they errored.
  external num totalLoadedPacks();

  /// Returns the number of files still waiting to be processed in the load queue. This value decreases as each file in the queue is loaded.
  external num totalQueuedFiles();

  /// Returns the number of asset packs still waiting to be processed in the load queue. This value decreases as each pack in the queue is loaded.
  external num totalQueuedPacks();

  /// Transforms the asset URL.
  /// The default implementation prepends the baseURL if the url doesn't begin with http or //
  external String transformUrl(String url, [dynamic file]);
  external void updateProgress();

  /// Adds a video file to the current load queue.
  /// The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getVideo(key)`.
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// You don't need to preload a video in order to play it in your game. See `Video.createVideoFromURL` for details.
  /// If an array is specified then the first URI (or URI + mime pair) that is device-compatible will be selected.
  /// For example: `"boom.mp4"`, `['boom.mp4', 'boom.ogg', 'boom.webm']`, or `[{uri: "data:<opus_resource>", type: 'opus'}, 'fallback.mp4']`.
  /// BLOB and DATA URIs can be used but only support automatic detection when used in the pair form; otherwise the format must be manually checked before adding the resource.
  /// 'canplaythrough' implies the video has downloaded enough, and bandwidth is high enough that it can be played to completion.
  /// 'canplay' implies the video has downloaded enough to start playing, but not necessarily to finish.
  /// 'loadeddata' just makes sure that the video meta data and first frame have downloaded. Phaser uses this value automatically if the
  /// browser is detected as being Firefox and no `loadEvent` is given, otherwise it defaults to `canplaythrough`. - Default: 'canplaythrough'
  /// Or they can be loaded via xhr, stored as binary data in memory and then converted to a Blob. This isn't supported in IE9 or Android 2.
  /// If you need to have the same video playing at different times across multiple Sprites then you need to load it as a Blob.
  external Loader video(
      String key, dynamic /*String|List<String>|dynamic*/ urls,
      [String loadEvent, bool asBlob]);

  /// Add a synchronization point to the assets / files added within the supplied callback.
  /// A synchronization point denotes that an asset _must_ be completely loaded before
  /// subsequent assets can be loaded. An asset marked as a sync-point does not need to wait
  /// for previous assets to load (unless they are sync-points). Resources, such as packs, may still
  /// be downloaded around sync-points, as long as they do not finalize loading.
  external Loader withSyncPoint(Function callback, [dynamic callbackContext]);

  /// Adds an XML file to the current load queue.
  /// The file is **not** loaded immediately after calling this method. The file is added to the queue ready to be loaded when the loader starts.
  /// The key must be a unique String. It is used to add the file to the Phaser.Cache upon successful load.
  /// Retrieve the file via `Cache.getXML(key)`.
  /// The URL can be relative or absolute. If the URL is relative the `Loader.baseURL` and `Loader.path` values will be prepended to it.
  /// If the URL isn't specified the Loader will take the key and create a filename from that. For example if the key is "alien"
  /// and no URL is given then the Loader will set the URL to be "alien.xml". It will always add `.xml` as the extension.
  /// If you do not desire this action then provide a URL.
  external Loader xml(String key, [String url, bool overwrite]);

  /// Starts the xhr loader.
  /// This is designed specifically to use with asset file processing.
  external void xhrLoad(dynamic file, String url, String type, Function onload,
      [Function onerror]);

  /// Starts the xhr loader - using XDomainRequest.
  /// This should _only_ be used with IE 9. Phaser does not support IE 8 and XDR is deprecated in IE 10.
  /// This is designed specifically to use with asset file processing.
  external void xhrLoadWithXDR(
      dynamic file, String url, String type, Function onload,
      [Function onerror]);

  /// Successfully loaded an XML file - only used for certain types.
  external void xmlLoadComplete(dynamic file, HttpRequest xhr);
}

/// Phaser.LoaderParser parses data objects from Phaser.Loader that need more preparation before they can be inserted into the Cache.
@JS("Phaser.LoaderParser")
class LoaderParser {
  // @Ignore
  LoaderParser.fakeConstructor$();

  /// Alias for xmlBitmapFont, for backwards compatibility.
  external static dynamic bitmapFont(dynamic xml, BaseTexture baseTexture,
      [num xSpacing, num ySpacing, Frame frame, num resolution]);

  /// Parse a Bitmap Font from an XML file.
  external static dynamic xmlBitmapFont(dynamic xml, BaseTexture baseTexture,
      [num xSpacing, num ySpacing, Frame frame, num resolution]);

  /// Parse a Bitmap Font from a JSON file.
  external static dynamic jsonBitmapFont(dynamic json, BaseTexture baseTexture,
      [num xSpacing, num ySpacing, Frame frame, num resolution]);
}

/// The Matrix is a 3x3 matrix mostly used for display transforms within the renderer.
/// It is represented like so:
/// | a | b | tx |
/// | c | d | ty |
/// | 0 | 0 | 1 |
@JS("Phaser.Matrix")
class Matrix {
  // @Ignore
  Matrix.fakeConstructor$();

  /// Default: 1
  external num get a;
  external set a(num v);

  /// Default: 0
  external num get b;
  external set b(num v);

  /// Default: 0
  external num get c;
  external set c(num v);

  /// Default: 1
  external num get d;
  external set d(num v);

  /// Default: 0
  external num get tx;
  external set tx(num v);

  /// Default: 0
  external num get ty;
  external set ty(num v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// The Matrix is a 3x3 matrix mostly used for display transforms within the renderer.
  /// It is represented like so:
  /// | a | b | tx |
  /// | c | d | ty |
  /// | 0 | 0 | 1 |
  external factory Matrix([num a, num b, num c, num d, num tx, num ty]);

  /// Get a new position with the current transformation applied.
  /// Can be used to go from a childs coordinate space to the world coordinate space (e.g. rendering)
  external Point apply(Point pos, [Point newPos]);

  /// Get a new position with the inverse of the current transformation applied.
  /// Can be used to go from the world coordinate space to a childs coordinate space. (e.g. input)
  external Point applyInverse(Point pos, [Point newPos]);

  /// Creates a new Matrix object based on the values of this Matrix.
  /// If you provide the output parameter the values of this Matrix will be copied over to it.
  /// If the output parameter is blank a new Matrix object will be created.
  external Matrix clone([Matrix output]);

  /// Copies the properties from the given Matrix into this Matrix.
  external Matrix copyFrom(Matrix matrix);

  /// Copies the properties from this Matrix to the given Matrix.
  external Matrix copyTo(Matrix matrix);

  /// Sets the values of this Matrix to the values in the given array.
  /// The Array elements should be set as follows:
  /// a = array[0]
  /// b = array[1]
  /// c = array[3]
  /// d = array[4]
  /// tx = array[2]
  /// ty = array[5]
  external Matrix fromArray(List<num> array);

  /// Sets the values of this Matrix to the given values.
  external Matrix setTo(num a, num b, num c, num d, num tx, num ty);

  /// Creates a Float32 Array with values populated from this Matrix object.
  external List<num> toArray([bool transpose, List<num> array]);

  /// Translates the matrix on the x and y.
  /// This is the same as Matrix.tx += x.
  external Matrix translate(num x, num y);

  /// Applies a scale transformation to this matrix.
  external Matrix scale(num x, num y);

  /// Applies a rotation transformation to this matrix.
  external Matrix rotate(num angle);

  /// Appends the given Matrix to this Matrix.
  external Matrix append(Matrix matrix);

  /// Resets this Matrix to an identity (default) matrix.
  external Matrix identity();
}

/// A collection of useful mathematical functions.
/// These are normally accessed through `game.math`.
@JS("Phaser.Math")
class Math {
  // @Ignore
  Math.fakeConstructor$();

  /// Find the angle of a segment from (x1, y1) -> (x2, y2).
  external static num angleBetween(num x1, num y1, num x2, num y2);

  /// Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).
  external static num angleBetweenPoints(Point point1, Point point2);

  /// Find the angle of a segment from (x1, y1) -> (x2, y2).
  /// The difference between this method and Math.angleBetween is that this assumes the y coordinate travels
  /// down the screen.
  external static num angleBetweenY(num x1, num y1, num x2, num y2);

  /// Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).
  external static num angleBetweenPointsY(Point point1, Point point2);

  /// Averages all values passed to the function and returns the result.
  external static num average(
      [num numbers1, num numbers2, num numbers3, num numbers4, num numbers5]);
  external static num bernstein(num n, num i);

  /// Returns a random float in the range `[min, max)`. If these parameters are not in order than they will be put in order.
  /// Default is 0 for `min` and 1 for `max`.
  external static num random(num min, num max);

  /// Returns a random integer in the range `[min, max]`. If these parameters are not in order than they will be put in order.
  /// Default is 0 for `min` and 1 for `max`.
  external static num between(num min, num max);

  /// A Bezier Interpolation Method, mostly used by Phaser.Tween.
  external static num bezierInterpolation(List<num> v, num k);

  /// Calculates a catmum rom value.
  external static num catmullRom(num p0, num p1, num p2, num p3, num t);

  /// A Catmull Rom Interpolation Method, mostly used by Phaser.Tween.
  external static num catmullRomInterpolation(List<num> v, num k);

  /// Ceils to some place comparative to a `base`, default is 10 for decimal place.
  /// The `place` is represented by the power applied to `base` to get that place.
  external static num ceilTo(num value, [num place, num base]);

  /// Force a value within the boundaries by clamping it to the range `min`, `max`.
  external static num clamp(num x, num a, num b);

  /// Clamp `x` to the range `[a, Infinity)`.
  /// Roughly the same as `Math.max(x, a)`, except for NaN handling.
  external static num clampBottom(num x, num a);

  /// Convert degrees to radians.
  external static num degToRad(num degrees);

  /// The absolute difference between two values.
  external static num difference(num a, num b);

  /// Returns the euclidian distance between the two given set of coordinates.
  external static num distance(num x1, num y1, num x2, num y2);

  /// Returns the euclidean distance squared between the two given set of
  /// coordinates (cuts out a square root operation before returning).
  external static num distanceSq(num x1, num y1, num x2, num y2);

  /// Returns the distance between the two given set of coordinates at the power given.
  external static num distancePow(num xy, num y1, num x2, num y2, [num pow]);
  external static num factorial(num value);

  /// Floors to some place comparative to a `base`, default is 10 for decimal place.
  /// The `place` is represented by the power applied to `base` to get that place.
  external static num floorTo(num value, num place, num base);

  /// Applies a fuzzy ceil to the given value.
  external static num fuzzyCeil(num val, [num epsilon]);

  /// Two number are fuzzyEqual if their difference is less than epsilon.
  external static bool fuzzyEqual(num a, num b, [num epsilon]);

  /// `a` is fuzzyLessThan `b` if it is less than b + epsilon.
  /*external static bool fuzzyLessThan(num a, num b, [num epsilon]);*/
  /// `a` is fuzzyLessThan `b` if it is less than b + epsilon.
  /*external static bool fuzzyLessThan(num a, num b, [num epsilon]);*/
  external bool fuzzyLessThan(num a, num b, [num epsilon]);
  external static num fuzzyFloor(num val, [num epsilon]);
  external static bool fuzzyGreaterThan(num a, num b, [num epsilon]);

  /// Gets the shortest angle between `angle1` and `angle2`.
  /// Both angles must be in the range -180 to 180, which is the same clamped
  /// range that `sprite.angle` uses, so you can pass in two sprite angles to
  /// this method, and get the shortest angle back between the two of them.
  /// The angle returned will be in the same range. If the returned angle is
  /// greater than 0 then it's a counter-clockwise rotation, if < 0 then it's
  /// a clockwise rotation.
  external static num getShortestAngle(num angle1, num angle2);

  /// Given a number, this function returns the closest number that is a power of two.
  /// This function is from the Starling Framework.
  external static num getNextPowerOfTwo(num value);

  /// Half PI.
  /// Default: ~1.570
  external static num get HALF_PI;
  external static set HALF_PI(num v);

  /// Returns true if the number given is even.
  external static bool isEven(num n);

  /// Returns true if the number given is odd.
  external static bool isOdd(num n);

  /// Checks if the given dimensions make a power of two texture.
  external static bool isPowerOfTwo(num width, num height);

  /// Calculates a linear (interpolation) value over t.
  external static num linear(num p0, num p1, num t);

  /// A Linear Interpolation Method, mostly used by Phaser.Tween.
  external static num linearInterpolation(List<num> v, num k);

  /// Linear mapping from range <a1, a2> to range <b1, b2>
  external static num mapLinear(num x, num a1, num a2, num b1, num b2);

  /// Variation of Math.max that can be passed either an array of numbers or the numbers as parameters.
  /// Prefer the standard `Math.max` function when appropriate.
  external static num max(
      [num numbers1, num numbers2, num numbers3, num numbers4, num numbers5]);

  /// Adds the given amount to the value, but never lets the value go over the specified maximum.
  external static num maxAdd(num value, num amount, num max);

  /// Variation of Math.max that can be passed a property and either an array of objects or the objects as parameters.
  /// It will find the largest matching property value from the given objects.
  external static num maxProperty(
      [num numbers1, num numbers2, num numbers3, num numbers4, num numbers5]);

  /// Variation of Math.min that can be passed either an array of numbers or the numbers as parameters.
  /// Prefer the standard `Math.min` function when appropriate.
  external static num min(
      [num numbers1, num numbers2, num numbers3, num numbers4, num numbers5]);

  /// Variation of Math.min that can be passed a property and either an array of objects or the objects as parameters.
  /// It will find the lowest matching property value from the given objects.
  external static num minProperty(
      [num numbers1, num numbers2, num numbers3, num numbers4, num numbers5]);

  /// Subtracts the given amount from the value, but never lets the value go below the specified minimum.
  external static num minSub(num value, num amount, num min);

  /// Normalizes an angle to the [0,2pi) range.
  external static num normalizeAngle(num angle, [bool radians]);

  /// Work out what percentage value `a` is of value `b` using the given base.
  external static num percent(num a, num b, [num base]);
  external static num p2px(num v);

  /// Twice PI.
  /// Default: ~6.283
  external static num get PI2;
  external static set PI2(num v);

  /// Convert radians to degrees.
  external static num radToDeg(num radians);

  /// Reverses an angle.
  external static num reverseAngle(num angleRed);

  /// Rotates currentAngle towards targetAngle, taking the shortest rotation distance.
  /// The lerp argument is the amount to rotate by in this call.
  external static num rotateToAngle(num currentAngle, num targetAngle,
      [num lerp]);

  /// Round to the next whole number _away_ from zero.
  external static num roundAwayFromZero(num value);

  /// Round to some place comparative to a `base`, default is 10 for decimal place.
  /// The `place` is represented by the power applied to `base` to get that place.
  /// e.g. 2000/7 ~= 285.714285714285714285714 ~= (bin)100011101.1011011011011011
  /// roundTo(2000/7,3) === 0
  /// roundTo(2000/7,2) == 300
  /// roundTo(2000/7,1) == 290
  /// roundTo(2000/7,0) == 286
  /// roundTo(2000/7,-1) == 285.7
  /// roundTo(2000/7,-2) == 285.71
  /// roundTo(2000/7,-3) == 285.714
  /// roundTo(2000/7,-4) == 285.7143
  /// roundTo(2000/7,-5) == 285.71429
  /// roundTo(2000/7,3,2)  == 288       -- 100100000
  /// roundTo(2000/7,2,2)  == 284       -- 100011100
  /// roundTo(2000/7,1,2)  == 286       -- 100011110
  /// roundTo(2000/7,0,2)  == 286       -- 100011110
  /// roundTo(2000/7,-1,2) == 285.5     -- 100011101.1
  /// roundTo(2000/7,-2,2) == 285.75    -- 100011101.11
  /// roundTo(2000/7,-3,2) == 285.75    -- 100011101.11
  /// roundTo(2000/7,-4,2) == 285.6875  -- 100011101.1011
  /// roundTo(2000/7,-5,2) == 285.71875 -- 100011101.10111
  /// Note what occurs when we round to the 3rd space (8ths place), 100100000, this is to be assumed
  /// because we are rounding 100011.1011011011011011 which rounds up.
  external static num roundTo(num value, [num place, num base]);
  external static num shear(num n);

  /// A value representing the sign of the value: -1 for negative, +1 for positive, 0 if value is 0.
  /// This works differently from `Math.sign` for values of NaN and -0, etc.
  external static num sign(num x);

  /// Generate a sine and cosine table simultaneously and extremely quickly.
  /// The parameters allow you to specify the length, amplitude and frequency of the wave.
  /// This generator is fast enough to be used in real-time.
  /// Code based on research by Franky of scene.at
  external static dynamic /*{ sin: number[]; cos: number[]; }*/ sinCosGenerator(
      num length,
      [num sinAmplitude,
      num cosAmplitude,
      num frequency]);

  /// Returns the length of the hypotenuse connecting two segments of given lengths.
  external static num hypot(num a, num b);

  /// Smootherstep function as detailed at http://en.wikipedia.org/wiki/Smoothstep
  external static num smootherstep(num x, num min, num max);

  /// Smoothstep function as detailed at http://en.wikipedia.org/wiki/Smoothstep
  external static num smoothstep(num x, num min, num max);

  /// Snap a value to nearest grid slice, using rounding.
  /// Example: if you have an interval gap of 5 and a position of 12... you will snap to 10 whereas 14 will snap to 15.
  external static num snapTo(num input, num gap, [num start]);

  /// Snap a value to nearest grid slice, using ceil.
  /// Example: if you have an interval gap of 5 and a position of 12... you will snap to 15.
  /// As will 14 will snap to 15... but 16 will snap to 20.
  external static num snapToCeil(num input, num gap, [num start]);

  /// Snap a value to nearest grid slice, using floor.
  /// Example: if you have an interval gap of 5 and a position of 12... you will snap to 10.
  /// As will 14 snap to 10... but 16 will snap to 15.
  external static num snapToFloor(num input, num gap, [num start]);

  /// Checks if two values are within the given tolerance of each other.
  external static bool within(num a, num b, num tolerance);

  /// Ensures that the value always stays between min and max, by wrapping the value around.
  /// If `max` is not larger than `min` the result is 0.
  external static num wrap(num value, num min, num max);

  /// Keeps an angle value between -180 and +180; or -PI and PI if radians.
  external static num wrapAngle(num angle, [bool radians]);

  /// Adds value to amount and ensures that the result always stays between 0 and max, by wrapping the value around.
  /// Values _must_ be positive integers, and are passed through Math.abs. See [Phaser.Math#wrap] for an alternative.
  external static num wrapValue(num value, num amount, num max);
}

@anonymous
@JS()
abstract class WheelEventProxy {
  external WheelEventProxy bindEvent(dynamic event);
  external String get type;
  external set type(String v);
  external num get deltaMode;
  external set deltaMode(num v);
  external num get deltaX;
  external set deltaX(num v);
  external num get deltaY;
  external set deltaY(num v);
  external num get deltaZ;
  external set deltaZ(num v);
}

/// The Mouse class is responsible for handling all aspects of mouse interaction with the browser.
/// It captures and processes mouse events that happen on the game canvas object.
/// It also adds a single `mouseup` listener to `window` which is used to capture the mouse being released
/// when not over the game.
/// You should not normally access this class directly, but instead use a Phaser.Pointer object
/// which normalises all game input for you, including accurate button handling.
@JS("Phaser.Mouse")
class Mouse {
  // @Ignore
  Mouse.fakeConstructor$();

  /// The Mouse class is responsible for handling all aspects of mouse interaction with the browser.
  /// It captures and processes mouse events that happen on the game canvas object.
  /// It also adds a single `mouseup` listener to `window` which is used to capture the mouse being released
  /// when not over the game.
  /// You should not normally access this class directly, but instead use a Phaser.Pointer object
  /// which normalises all game input for you, including accurate button handling.
  external factory Mouse(Game game);
  external static num get NO_BUTTON;
  external static set NO_BUTTON(num v);
  external static num get LEFT_BUTTON;
  external static set LEFT_BUTTON(num v);
  external static num get MIDDLE_BUTTON;
  external static set MIDDLE_BUTTON(num v);
  external static num get RIGHT_BUTTON;
  external static set RIGHT_BUTTON(num v);
  external static num get BACK_BUTTON;
  external static set BACK_BUTTON(num v);
  external static num get FORWARD_BUTTON;
  external static set FORWARD_BUTTON(num v);
  external static num get WHEEL_DOWN;
  external static set WHEEL_DOWN(num v);
  external static num get WHEEL_UP;
  external static set WHEEL_UP(num v);

  /// This property was removed in Phaser 2.4 and should no longer be used.
  /// Instead please see the Pointer button properties such as `Pointer.leftButton`, `Pointer.rightButton` and so on.
  /// Or Pointer.button holds the DOM event button value if you require that.
  external num get button;
  external set button(num v);

  /// The context under which callbacks are called.
  external dynamic get callbackContext;
  external set callbackContext(dynamic v);

  /// If true the DOM mouse events will have event.preventDefault applied to them, if false they will propagate fully.
  external bool get capture;
  external set capture(bool v);

  /// Mouse input will only be processed if enabled.
  /// Default: true
  external bool get enabled;
  external set enabled(bool v);

  /// The browser mouse DOM event. Will be null if no mouse event has ever been received.
  /// Access this property only inside a Mouse event handler and do not keep references to it.
  external MouseEvent get event;
  external set event(MouseEvent v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// A reference to the Phaser Input Manager.
  external Input get input;
  external set input(Input v);

  /// If the mouse has been Pointer Locked successfully this will be set to true.
  external bool get locked;
  external set locked(bool v);

  /// A callback that can be fired when the mouse is pressed down.
  external VoidFunc1<MouseEvent> get mouseDownCallback;
  external set mouseDownCallback(VoidFunc1<MouseEvent> v);

  /// A callback that can be fired when the mouse is no longer over the game canvas.
  external VoidFunc1<MouseEvent> get mouseOutCallback;
  external set mouseOutCallback(VoidFunc1<MouseEvent> v);

  /// A callback that can be fired when the mouse enters the game canvas (usually after a mouseout).
  external VoidFunc1<MouseEvent> get mouseOverCallback;
  external set mouseOverCallback(VoidFunc1<MouseEvent> v);

  /// A callback that can be fired when the mouse is released from a pressed down state.
  external VoidFunc1<MouseEvent> get mouseUpCallback;
  external set mouseUpCallback(VoidFunc1<MouseEvent> v);

  /// A callback that can be fired when the mousewheel is used.
  external VoidFunc1<MouseEvent> get mouseWheelCallback;
  external set mouseWheelCallback(VoidFunc1<MouseEvent> v);

  /// Internal event handler reference.
  external VoidFunc1<MouseEvent> get JS$_onMouseDown;
  external set JS$_onMouseDown(VoidFunc1<MouseEvent> v);

  /// Internal event handler reference.
  external VoidFunc1<MouseEvent> get JS$_onMouseMove;
  external set JS$_onMouseMove(VoidFunc1<MouseEvent> v);

  /// Internal event handler reference.
  external VoidFunc1<MouseEvent> get JS$_onMouseUp;
  external set JS$_onMouseUp(VoidFunc1<MouseEvent> v);

  /// Internal event handler reference.
  external VoidFunc1<MouseEvent> get JS$_onMouseOut;
  external set JS$_onMouseOut(VoidFunc1<MouseEvent> v);

  /// Internal event handler reference.
  external VoidFunc1<MouseEvent> get JS$_onMouseOver;
  external set JS$_onMouseOver(VoidFunc1<MouseEvent> v);

  /// Internal event handler reference.
  external VoidFunc1<MouseEvent> get JS$_onMouseWheel;
  external set JS$_onMouseWheel(VoidFunc1<MouseEvent> v);

  /// Wheel proxy event object, if required. Shared for all wheel events for this mouse.
  external WheelEventProxy get JS$_wheelEvent;
  external set JS$_wheelEvent(WheelEventProxy v);

  /// This event is dispatched when the browser enters or leaves pointer lock state.
  external Signal get pointerLock;
  external set pointerLock(Signal v);

  /// If true Pointer.stop will be called if the mouse leaves the game canvas.
  external bool get stopOnGameOut;
  external set stopOnGameOut(bool v);

  /// The direction of the _last_ mousewheel usage 1 for up -1 for down.
  external num get wheelDelta;
  external set wheelDelta(num v);

  /// The internal method that handles the mouse down event from the browser.
  external void onMouseDown(MouseEvent event);

  /// The internal method that handles the mouse move event from the browser.
  external void onMouseMove(MouseEvent event);

  /// The internal method that handles the mouse out event from the browser.
  external void onMouseOut(MouseEvent event);

  /// The internal method that handles the mouse over event from the browser.
  external void onMouseOver(MouseEvent event);

  /// The internal method that handles the mouse up event from the browser.
  external void onMouseUp(MouseEvent event);

  /// The internal method that handles the mouse up event from the window.
  external void onMouseUpGlobal(MouseEvent event);

  /// The internal method that handles the mouse wheel event from the browser.
  external void onMouseWheel(MouseEvent event);

  /// Internal pointerLockChange handler.
  external void pointerLockChange(MouseEvent event);

  /// Internal release pointer lock handler.
  external void releasePointerLock();

  /// If the browser supports it you can request that the pointer be locked to the browser window.
  /// This is classically known as 'FPS controls', where the pointer can't leave the browser until the user presses an exit key.
  /// If the browser successfully enters a locked state the event Phaser.Mouse.pointerLock will be dispatched and the first parameter will be 'true'.
  external void requestPointerLock();

  /// Starts the event listeners running.
  external void start();

  /// Stop the event listeners.
  external void stop();
}

/// The MSPointer class handles [https://developers.google.com/web/updates/2016/10/pointer-events Pointer-event] interactions with the game via a dedicated [Phaser.Pointer]. (It's named after the nonstandard [https://msdn.microsoft.com/library/hh673557(v=vs.85).aspx MSPointerEvent] since that was the first browser implementation.)
/// It's [http://caniuse.com/#feat=pointer currently supported  in IE 10+, Edge, Chrome (including Android), and Opera].
/// You should not normally access this class directly, but instead use a [Phaser.Pointer] object which
/// normalises all game input for you including accurate button handling.
/// Please note that at the current time of writing Phaser does not yet support chorded button interactions:
/// http://www.w3.org/TR/pointerevents/#chorded-button-interactions
/// You can disable Phaser's use of Pointer Events by either of two ways:
/// ```javascript
/// // **Before** `new Phaser.Game()`:
/// Phaser.Device.onInitialized.add(function () {
/// this.mspointer = false;
/// });
/// ```
/// ```javascript
/// // Once, in the earliest State `init` or `create` callback (e.g., Boot):
/// this.input.mspointer.stop();
/// ```
@JS("Phaser.MSPointer")
class MSPointer {
  // @Ignore
  MSPointer.fakeConstructor$();

  /// The MSPointer class handles [https://developers.google.com/web/updates/2016/10/pointer-events Pointer-event] interactions with the game via a dedicated [Phaser.Pointer]. (It's named after the nonstandard [https://msdn.microsoft.com/library/hh673557(v=vs.85).aspx MSPointerEvent] since that was the first browser implementation.)
  /// It's [http://caniuse.com/#feat=pointer currently supported  in IE 10+, Edge, Chrome (including Android), and Opera].
  /// You should not normally access this class directly, but instead use a [Phaser.Pointer] object which
  /// normalises all game input for you including accurate button handling.
  /// Please note that at the current time of writing Phaser does not yet support chorded button interactions:
  /// http://www.w3.org/TR/pointerevents/#chorded-button-interactions
  /// You can disable Phaser's use of Pointer Events by either of two ways:
  /// ```javascript
  /// // **Before** `new Phaser.Game()`:
  /// Phaser.Device.onInitialized.add(function () {
  /// this.mspointer = false;
  /// });
  /// ```
  /// ```javascript
  /// // Once, in the earliest State `init` or `create` callback (e.g., Boot):
  /// this.input.mspointer.stop();
  /// ```
  external factory MSPointer(Game game);

  /// This property was removed in Phaser 2.4 and should no longer be used.
  /// Instead please see the Pointer button properties such as `Pointer.leftButton`, `Pointer.rightButton` and so on.
  /// Or Pointer.button holds the DOM event button value if you require that.
  external num get button;
  external set button(num v);

  /// If true the Pointer events will have event.preventDefault applied to them, canceling the corresponding MouseEvent or TouchEvent.
  external bool get capture;
  external set capture(bool v);

  /// The context under which callbacks are called (defaults to game).
  external dynamic get callbackContext;
  external set callbackContext(dynamic v);

  /// The most recent PointerEvent from the browser. Will be null if no event has ever been received.
  /// Access this property only inside a Pointer event handler and do not keep references to it.
  external MSPointerEvent get event;
  external set event(MSPointerEvent v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// A reference to the Phaser Input Manager.
  external Input get input;
  external set input(Input v);
  external VoidFunc1<MSPointerEvent> get onPointerDown;
  external set onPointerDown(VoidFunc1<MSPointerEvent> v);
  external VoidFunc1<MSPointerEvent> get onPointerMove;
  external set onPointerMove(VoidFunc1<MSPointerEvent> v);
  external VoidFunc1<MSPointerEvent> get onPointerUp;
  external set onPointerUp(VoidFunc1<MSPointerEvent> v);
  external VoidFunc1<MSPointerEvent> get mouseDownCallback;
  external set mouseDownCallback(VoidFunc1<MSPointerEvent> v);
  external VoidFunc1<MSPointerEvent> get mouseMoveCallback;
  external set mouseMoveCallback(VoidFunc1<MSPointerEvent> v);
  external VoidFunc1<MSPointerEvent> get mouseUpCallback;
  external set mouseUpCallback(VoidFunc1<MSPointerEvent> v);

  /// A callback that can be fired on a MSPointerDown event.
  external VoidFunc1<MSPointerEvent> get pointerDownCallback;
  external set pointerDownCallback(VoidFunc1<MSPointerEvent> v);

  /// A callback that can be fired on a MSPointerMove event.
  external VoidFunc1<MSPointerEvent> get pointerMoveCallback;
  external set pointerMoveCallback(VoidFunc1<MSPointerEvent> v);

  /// A callback that can be fired on a MSPointerUp event.
  external VoidFunc1<MSPointerEvent> get pointerUpCallback;
  external set pointerUpCallback(VoidFunc1<MSPointerEvent> v);

  /// Starts the event listeners running.
  external void start();

  /// Stop the event listeners.
  external void stop();
}

/// Phaser.Net handles browser URL related tasks such as checking host names, domain names and query string manipulation.
@JS("Phaser.Net")
class Net {
  // @Ignore
  Net.fakeConstructor$();

  /// Phaser.Net handles browser URL related tasks such as checking host names, domain names and query string manipulation.
  external factory Net(Game game);
  external Game get game;
  external set game(Game v);

  /// Compares the given domain name against the hostname of the browser containing the game.
  /// If the domain name is found it returns true.
  /// You can specify a part of a domain, for example 'google' would match 'google.com', 'google.co.uk', etc.
  /// Do not include 'http://' at the start.
  external bool checkDomainName(String domain);

  /// Takes a Uniform Resource Identifier (URI) component (previously created by encodeURIComponent or by a similar routine) and
  /// decodes it, replacing \ with spaces in the return. Used internally by the Net classes.
  external String decodeURI(String value);

  /// Returns the hostname given by the browser.
  external String getHostName();

  /// Returns the Query String as an object.
  /// If you specify a parameter it will return just the value of that parameter, should it exist.
  external String getQueryString([String parameter]);

  /// Updates a value on the Query String and returns it in full.
  /// If the value doesn't already exist it is set.
  /// If the value exists it is replaced with the new value given. If you don't provide a new value it is removed from the query string.
  /// Optionally you can redirect to the new url, or just return it as a string.
  external String updateQueryString(String key, dynamic value,
      [bool redirect, String url]);
}

/// Create a new `Particle` object. Particles are extended Sprites that are emitted by a particle emitter such as Phaser.Particles.Arcade.Emitter.
@JS("Phaser.Particle")
class Particle extends Sprite {
  // @Ignore
  Particle.fakeConstructor$() : super.fakeConstructor$();

  /// Create a new `Particle` object. Particles are extended Sprites that are emitted by a particle emitter such as Phaser.Particles.Arcade.Emitter.
  external factory Particle(Game game, num x, num y,
      [dynamic key, dynamic frame]);

  /// A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.
  /// This property is mostly used internally by the physics systems, but is exposed for the use of plugins.
  external bool get fresh;
  external set fresh(bool v);

  /// Called by the Emitter when this particle is emitted. Left empty for you to over-ride as required.
  external void onEmit();

  /// Resets the Particle. This places the Particle at the given x/y world coordinates and then
  /// sets alive, exists, visible and renderable all to true. Also resets the outOfBounds state and health values.
  /// If the Particle has a physics body that too is reset.
  external Particle reset(num x, num y, [num health]);

  /// Called by the Emitter if autoAlpha has been enabled. Passes over the alpha ease data and resets the alpha counter.
  external void setAlphaData(List<dynamic> data);

  /// Called by the Emitter if autoScale has been enabled. Passes over the scale ease data and resets the scale counter.
  external void setScaleData(List<dynamic> data);

  /// Updates the Particle scale or alpha if autoScale and autoAlpha are set.
  external void update();
}

/// Phaser.Particles is the Particle Manager for the game. It is called during the game update loop and in turn updates any Emitters attached to it.
@JS("Phaser.Particles")
class Particles {
  // @Ignore
  Particles.fakeConstructor$();

  /// Phaser.Particles is the Particle Manager for the game. It is called during the game update loop and in turn updates any Emitters attached to it.
  external factory Particles(Game game);

  /// Internal emitters store.
  external dynamic get emitters;
  external set emitters(dynamic v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// -
  external num get ID;
  external set ID(num v);

  /// Adds a new Particle Emitter to the Particle Manager.
  external Emitter add(Emitter emitter);

  /// Removes an existing Particle Emitter from the Particle Manager.
  external void remove(Emitter emitter);

  /// Updates all Emitters who have their exists value set to true.
  /// Phaser no longer uses this method; Emitters receive updates via [Phaser.Stage#update] instead.
  external void update();
}

// Module Particles

// Module Arcade
@anonymous
@JS()
abstract class EmitterCount {
  external num get emitted;
  external set emitted(num v);
  external num get failed;
  external set failed(num v);
  external num get totalEmitted;
  external set totalEmitted(num v);
  external num get totalFailed;
  external set totalFailed(num v);
  external factory EmitterCount(
      {num emitted, num failed, num totalEmitted, num totalFailed});
}

/// Emitter is a lightweight particle emitter that uses Arcade Physics.
/// It can be used for one-time explosions or for continuous effects like rain and fire.
/// All it really does is launch Particle objects out at set intervals, and fixes their positions and velocities accordingly.
@JS("Phaser.Particles.Arcade.Emitter")
class Emitter extends Group {
  // @Ignore
  Emitter.fakeConstructor$() : super.fakeConstructor$();

  /// Emitter is a lightweight particle emitter that uses Arcade Physics.
  /// It can be used for one-time explosions or for continuous effects like rain and fire.
  /// All it really does is launch Particle objects out at set intervals, and fixes their positions and velocities accordingly.
  external factory Emitter(Game game, [num x, num y, num maxParticles]);

  /// An array of the calculated alpha easing data applied to particles with alphaRates > 0.
  external List<dynamic> get alphaData;
  external set alphaData(List<dynamic> v);

  /// When a new Particle is emitted this controls if it will automatically change alpha. Use Emitter.setAlpha to configure.
  external bool get autoAlpha;
  external set autoAlpha(bool v);

  /// When a new Particle is emitted this controls if it will automatically scale in size. Use Emitter.setScale to configure.
  external bool get autoScale;
  external set autoScale(bool v);

  /// The angle of rotation of the group container, in degrees.
  /// This adjusts the group itself by modifying its local rotation transform.
  /// This has no impact on the rotation/angle properties of the children, but it will update their worldTransform
  /// and on-screen orientation and position.
  external num get angle;
  external set angle(num v);

  /// The angular drag component of particles launched from the emitter if they are rotating.
  external num get angularDrag;
  external set angularDrag(num v);

  /// The blendMode as set on the particle when emitted from the Emitter. Defaults to NORMAL. Needs browser capable of supporting canvas blend-modes (most not available in WebGL)
  external num /*enum Phaser.blendModes*/ get blendMode;
  external set blendMode(num /*enum Phaser.blendModes*/ v);

  /// Gets the bottom position of the Emitter.
  external num get bottom;
  external set bottom(num v);

  /// How much each particle should bounce on each axis. 1 = full bounce, 0 = no bounce.
  external PhaserPoint get bounce;
  external set bounce(Point v);
  external EmitterCount get counts;
  external set counts(EmitterCount v);

  /// The point the particles are emitted from.
  /// Emitter.x and Emitter.y control the containers location, which updates all current particles
  /// Emitter.emitX and Emitter.emitY control the emission location relative to the x/y position.
  external num get emitX;
  external set emitX(num v);

  /// The point the particles are emitted from.
  /// Emitter.x and Emitter.y control the containers location, which updates all current particles
  /// Emitter.emitX and Emitter.emitY control the emission location relative to the x/y position.
  external num get emitY;
  external set emitY(num v);

  /// If exists is false the group will be excluded from collision checks and filters such as [Phaser.Group#forEachExists forEachExists]. The group will not call `preUpdate` and `postUpdate` on its children and the children will not receive physics updates or camera/world boundary checks. The group will still be [Phaser.Group#visible visible] and will still call `update` on its children (unless [Phaser.Group#updateOnlyExistingChildren updateOnlyExistingChildren] is true).
  /// Default: true
  external bool get exists;
  external set exists(bool v);

  /// How often a particle is emitted in ms (if emitter is started with Explode === false).
  /// Default: 100
  external num get frequency;
  external set frequency(num v);

  /// Sets the `body.gravity` of each particle sprite to this on launch.
  external PhaserPoint get gravity;
  external set gravity(Point v);
  external Group get group;
  external set group(Group v);

  /// Gets or sets the height of the Emitter. This is the region in which a particle can be emitted.
  external num get height;
  external set height(num v);

  /// Gets the left position of the Emitter.
  external num get left;
  external set left(num v);

  /// How long each particle lives once it is emitted in ms. Default is 2 seconds. Set lifespan to 'zero' for particles to live forever.
  /// Default: 2000
  external num get lifespan;
  external set lifespan(num v);

  /// The number of particles released during one particle's [Phaser.Particles.Arcade.Emitter#lifespan lifespan], after calling [Phaser.Particles.Arcade.Emitter#flow flow].
  external num get lifespanOutput;
  external set lifespanOutput(num v);

  /// The maximum angle of initial particle velocities, in degrees. When set to a non-null value (with [Phaser.Particles.Arcade.Emitter#minAngle minAngle]), [Phaser.Particles.Arcade.Emitter#minSpeed minSpeed] and [Phaser.Particles.Arcade.Emitter#maxSpeed maxSpeed] are used and [Phaser.Particles.Arcade.Emitter#minParticleSpeed minParticleSpeed] and [Phaser.Particles.Arcade.Emitter#maxParticleSpeed maxParticleSpeed] are ignored.
  external num get maxAngle;
  external set maxAngle(num v);

  /// The total number of particles in this emitter.
  external num get maxParticles;
  external set maxParticles(num v);

  /// The maximum possible scale of a particle. This is applied to the X and Y axis. If you need to control each axis see maxParticleScaleX.
  /// Default: 1
  external num get maxParticleScale;
  external set maxParticleScale(num v);

  /// The maximum possible velocity of a particle.
  external PhaserPoint get maxParticleSpeed;
  external set maxParticleSpeed(Point v);

  /// The maximum possible angular velocity of a particle.
  /// Default: 360
  external num get maxRotation;
  external set maxRotation(num v);

  /// The maximum initial speed of particles released within [Phaser.Particles.Arcade.Emitter#minAngle minAngle] and [Phaser.Particles.Arcade.Emitter#maxAngle maxAngle].
  /// Default: 100
  external num get maxSpeed;
  external set maxSpeed(num v);

  /// The minimum angle of initial particle velocities, in degrees. When set to a non-null value (with [Phaser.Particles.Arcade.Emitter#maxAngle maxAngle]), [Phaser.Particles.Arcade.Emitter#minSpeed minSpeed] and [Phaser.Particles.Arcade.Emitter#maxSpeed maxSpeed] are used and [Phaser.Particles.Arcade.Emitter#minParticleSpeed minParticleSpeed] and [Phaser.Particles.Arcade.Emitter#maxParticleSpeed maxParticleSpeed] are ignored.
  external num get minAngle;
  external set minAngle(num v);

  /// The minimum possible scale of a particle. This is applied to the X and Y axis. If you need to control each axis see minParticleScaleX.
  /// Default: 1
  external num get minParticleScale;
  external set minParticleScale(num v);

  /// The minimum possible velocity of a particle.
  external PhaserPoint get minParticleSpeed;
  external set minParticleSpeed(Point v);

  /// The minimum possible angular velocity of a particle.
  external num get minRotation;
  external set minRotation(num v);

  /// The minimum initial speed of particles released within [Phaser.Particles.Arcade.Emitter#minAngle minAngle] and [Phaser.Particles.Arcade.Emitter#maxAngle maxAngle].
  external num get minSpeed;
  external set minSpeed(num v);

  /// A handy string name for this emitter. Can be set to anything.
  external String get name;
  external set name(String v);

  /// Determines whether the emitter is currently emitting particles. It is totally safe to directly toggle this.
  external bool get on;
  external set on(bool v);

  /// The number of particles released per second, after calling [Phaser.Particles.Arcade.Emitter#flow flow].
  external num get output;
  external set output(num v);

  /// When a particle is created its anchor will be set to match this Point object (defaults to x/y: 0.5 to aid in rotation)
  external PhaserPoint get particleAnchor;
  external set particleAnchor(Point v);

  /// If this is `true` then when the Particle is emitted it will be bought to the top of the Emitters display list.
  external bool get particleBringToTop;
  external set particleBringToTop(bool v);

  /// If this is `true` then when the Particle is emitted it will be sent to the back of the Emitters display list.
  external bool get particleSendToBack;
  external set particleSendToBack(bool v);

  /// For emitting your own particle class types. They must extend Phaser.Particle.
  external dynamic get particleClass;
  external set particleClass(dynamic v);

  /// The X and Y drag component of particles launched from the emitter.
  external PhaserPoint get particleDrag;
  external set particleDrag(Point v);

  /// The const physics body type of this object.
  external num get physicsType;
  external set physicsType(num v);

  /// The coordinates, in pixels, of this DisplayObject, relative to its parent container.
  /// The value of this property does not reflect any positioning happening further up the display list.
  /// To obtain that value please see the `worldPosition` property.
  external PhaserPoint get position;
  external set position(Point v);

  /// The expected number of unreleased particles after a flow interval of [Phaser.Particles.Arcade.Emitter#lifespan lifespan], after calling [Phaser.Particles.Arcade.Emitter#flow flow].
  external num get remainder;
  external set remainder(num v);

  /// Gets the right position of the Emitter.
  external num get right;
  external set right(num v);

  /// An array of the calculated scale easing data applied to particles with scaleRates > 0.
  external List<dynamic> get scaleData;
  external set scaleData(List<dynamic> v);

  /// Gets the top position of the Emitter.
  external num get top;
  external set top(num v);

  /// Internal Phaser Type value.
  external num get type;
  external set type(num v);

  /// Gets or sets the width of the Emitter. This is the region in which a particle can be emitted.
  external num get width;
  external set width(num v);

  /// Gets or sets the x position of the Emitter.
  external num get x;
  external set x(num v);

  /// Gets or sets the y position of the Emitter.
  external num get y;
  external set y(num v);

  /// Change the emitter's center to match the center of any object with a `center` property, such as an Arcade Body.
  /// If the object doesn't have a `center` property it will be set to the object's anchor-adjusted world position (`object.world`).
  external Emitter at(dynamic object);

  /// This function is used internally to emit the next particle in the queue.
  /// However it can also be called externally to emit a particle.
  /// When called externally you can use the arguments to override any defaults the Emitter has set.
  /// The newly emitted particle is available in [Phaser.Particles.Arcade.Emitter#cursor].
  external bool emitParticle(
      [num x,
      num y,
      dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ key,
      dynamic /*String|num*/ frame]);

  /// Call this function to emit the given quantity of particles at all once (an explosion)
  external Emitter explode([num lifespan, num quantity]);

  /// Call this function to start emitting a flow of particles.
  /// `quantity` particles are released every interval of `frequency` ms until `total` particles have been released (or forever).
  /// If you set the total to be 20 and quantity to be 5 then flow will emit 4 times in total (4  5 = 20 total) and then turn [#on off].
  /// If you set the total to be -1 then no quantity cap is used and it will keep emitting (as long as there are inactive particles available).
  /// [Phaser.Particles.Arcade.Emitter#output output], [Phaser.Particles.Arcade.Emitter#lifespanOutput lifespanOutput], and [Phaser.Particles.Arcade.Emitter#remainder remainder] describe the particle flow rate.
  /// During a stable flow, the number of active particles approaches [Phaser.Particles.Arcade.Emitter#lifespanOutput lifespanOutput] and the number of inactive particles approaches [Phaser.Particles.Arcade.Emitter#remainder remainder].
  /// If [Phaser.Particles.Arcade.Emitter#remainder remainder] is less than 0, there will likely be no particles available for a portion of the flow (see [Phaser.Particles.Arcade.Emitter#count count]).
  external Emitter flow(
      [num lifespan, num frequency, num quantity, num total, bool immediate]);

  /// Call this function to turn off all the particles and the emitter.
  external Emitter kill();

  /// This function generates a new set of particles for use by this emitter.
  /// The particles are stored internally waiting to be emitted via Emitter.start.
  external Emitter makeParticles(dynamic keys,
      [dynamic frames,
      num quantity,
      bool collide,
      bool collideWorldBounds,
      dynamic particleArguments]);
  external Particles reset(num x, num y, [num health]);

  /// A more compact way of setting the alpha constraints of the particles.
  /// The rate parameter, if set to a value above zero, lets you set the speed at which the Particle change in alpha from min to max.
  /// If rate is zero, which is the default, the particle won't change alpha - instead it will pick a random alpha between min and max on emit.
  external Emitter setAlpha(
      [num min, num max, num rate, num ease(num k), bool yoyo]);

  /// Sets a radial pattern for emitting particles.
  /// This is a shorthand for setting [Phaser.Particles.Arcade.Emitter#minAngle minAngle], [Phaser.Particles.Arcade.Emitter#maxAngle maxAngle], [Phaser.Particles.Arcade.Emitter#minSpeed minSpeed], and [Phaser.Particles.Arcade.Emitter#maxSpeed maxSpeed].
  /// To remove the radial pattern, use `setAngle(null, null)`.
  external Emitter setAngle(num minAngle, num maxAngle,
      [num minSpeed, num maxSpeed]);

  /// A more compact way of setting the angular velocity constraints of the particles.
  external Emitter setRotation([num min, num max]);

  /// A more compact way of setting the scale constraints of the particles.
  /// The rate parameter, if set to a value above zero, lets you set the speed and ease which the Particle uses to change in scale from min to max across both axis.
  /// If rate is zero, which is the default, the particle won't change scale during update, instead it will pick a random scale between min and max on emit.
  external Emitter setScale(
      [num minX,
      num maxX,
      num minY,
      num maxY,
      num rate,
      num ease(num k),
      bool yoyo]);

  /// A more compact way of setting the width and height of the emitter.
  external Emitter setSize(num width, num height);

  /// A more compact way of setting the X velocity range of the emitter.
  external Emitter setXSpeed(num min, num max);

  /// A more compact way of setting the Y velocity range of the emitter.
  external Emitter setYSpeed(num min, num max);

  /// Start emitting particles.
  /// [Phaser.Particles.Arcade.Emitter#explode explode] and [Phaser.Particles.Arcade.Emitter#flow flow] are simpler methods.
  /// There are two patterns, based on the `explode` argument:
  /// ##### explode=true
  /// start(true, lifespan=0, null, total)
  /// When `explode` is true or `forceQuantity` is true, `start` emits `total` particles immediately. You should pass a nonzero `total`.
  /// ##### explode=false
  /// start(false, lifespan=0, frequency=250, total=0)
  /// When `explode` is false and `forceQuantity` is false, `start` emits 1 particle every interval of `frequency` ms. If `total` is not zero, the emitter turns itself off after `total` particles have been released. If `total` is zero, the emitter keeps emitting particles as long as they are available. To emit more than 1 particle per flow interval, use [Phaser.Particles.Arcade.Emitter#flow flow] instead.
  /// `forceQuantity` seems equivalent to `explode` and can probably be avoided.
  external Emitter start(
      [bool explode,
      num lifespan,
      num frequency,
      num total,
      bool forceQuantity]);

  /// Called automatically by the game loop, decides when to launch particles and when to "die".
  external void update();

  /// Handy for bringing game objects "back to life". Just sets alive and exists back to true.
  external Emitter revive();
}

// End module Arcade

// End module Particles
/// The Physics Manager is responsible for looking after all of the running physics systems.
/// Phaser supports 4 physics systems: Arcade Physics, P2, Ninja Physics and Box2D via a commercial plugin.
/// Game Objects (such as Sprites) can only belong to 1 physics system, but you can have multiple systems active in a single game.
/// For example you could have P2 managing a polygon-built terrain landscape that an vehicle drives over, while it could be firing bullets that use the
/// faster (due to being much simpler) Arcade Physics system.
@JS("Phaser.Physics")
class Physics {
  // @Ignore
  Physics.fakeConstructor$();

  /// The Physics Manager is responsible for looking after all of the running physics systems.
  /// Phaser supports 4 physics systems: Arcade Physics, P2, Ninja Physics and Box2D via a commercial plugin.
  /// Game Objects (such as Sprites) can only belong to 1 physics system, but you can have multiple systems active in a single game.
  /// For example you could have P2 managing a polygon-built terrain landscape that an vehicle drives over, while it could be firing bullets that use the
  /// faster (due to being much simpler) Arcade Physics system.
  external factory Physics(Game game, [dynamic config]);
  external static num get ARCADE;
  external static set ARCADE(num v);
  external static num get P2JS;
  external static set P2JS(num v);
  external static num get NINJA;
  external static set NINJA(num v);
  external static num get BOX2D;
  external static set BOX2D(num v);
  external static num get CHIPMUNK;
  external static set CHIPMUNK(num v);
  external static num get MATTERJS;
  external static set MATTERJS(num v);

  /// The Arcade Physics system.
  external Arcade get arcade;
  external set arcade(Arcade v);

  /// The physics configuration object as passed to the game on creation.
  external dynamic get config;
  external set config(dynamic v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// The N+ Ninja Physics system.
  external Ninja get ninja;
  external set ninja(Ninja v);

  /// The P2.JS Physics system.
  external P2 get p2;
  external set p2(P2 v);

  /// The Box2D Physics system.
  external dynamic get box2d;
  external set box2d(dynamic v);

  /// Clears down all active physics systems. This doesn't destroy them, it just clears them of objects and is called when the State changes.
  external void clear();

  /// Destroys all active physics systems. Usually only called on a Game Shutdown, not on a State swap.
  external void destroy();

  /// This will create a default physics body on the given game object or array of objects.
  /// A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.
  /// It can be for any of the physics systems that have been started:
  /// Phaser.Physics.Arcade - A light weight AABB based collision system with basic separation.
  /// Phaser.Physics.P2JS - A full-body advanced physics system supporting multiple object shapes, polygon loading, contact materials, springs and constraints.
  /// Phaser.Physics.NINJA - A port of Metanet Softwares N+ physics system. Advanced AABB and Circle vs. Tile collision.
  /// Phaser.Physics.BOX2D - A port of https://code.google.com/p/box2d-html5
  /// Phaser.Physics.MATTER - A full-body and light-weight advanced physics system (still in development)
  /// Phaser.Physics.CHIPMUNK is still in development.
  /// If you require more control over what type of body is created, for example to create a Ninja Physics Circle instead of the default AABB, then see the
  /// individual physics systems `enable` methods instead of using this generic one.
  external void enable(dynamic object, [num system, bool debug]);

  /// Parses the Physics Configuration object passed to the Game constructor and starts any physics systems specified within.
  external void parseConfig();

  /// preUpdate checks.
  external void preUpdate();

  /// Resets the active physics system. Called automatically on a Phaser.State swap.
  external void reset();

  /// Updates the physics bounds to match the world dimensions.
  external void setBoundsToWorld();

  /// This will create an instance of the requested physics simulation.
  /// Phaser.Physics.Arcade is running by default, but all others need activating directly.
  /// You can start the following physics systems:
  /// Phaser.Physics.P2JS - A full-body advanced physics system by Stefan Hedman.
  /// Phaser.Physics.NINJA - A port of Metanet Softwares N+ physics system.
  /// Phaser.Physics.BOX2D - A commercial Phaser Plugin (see http://phaser.io)
  /// Both Ninja Physics and Box2D require their respective plugins to be loaded before you can start them.
  /// They are not bundled into the core Phaser library.
  /// If the physics world has already been created (i.e. in another state in your game) then
  /// calling startSystem will reset the physics world, not re-create it. If you need to start them again from their constructors
  /// then set Phaser.Physics.p2 (or whichever system you want to recreate) to `null` before calling `startSystem`.
  external void startSystem(num system);

  /// Updates all running physics systems.
  external void update();
}

/// A Video object that takes a previously loaded Video from the Phaser Cache and handles playback of it.
/// Alternatively it takes a getUserMedia feed from an active webcam and streams the contents of that to
/// the Video instead (see `startMediaStream` method)
/// The video can then be applied to a Sprite as a texture. If multiple Sprites share the same Video texture and playback
/// changes (i.e. you pause the video, or seek to a new time) then this change will be seen across all Sprites simultaneously.
/// Due to a bug in IE11 you cannot play a video texture to a Sprite in WebGL. For IE11 force Canvas mode.
/// If you need each Sprite to be able to play a video fully independently then you will need one Video object per Sprite.
/// Please understand the obvious performance implications of doing this, and the memory required to hold videos in RAM.
/// On some mobile browsers such as iOS Safari, you cannot play a video until the user has explicitly touched the screen.
/// This works in the same way as audio unlocking. Phaser will handle the touch unlocking for you, however unlike with audio
/// it's worth noting that every single Video needs to be touch unlocked, not just the first one. You can use the `changeSource`
/// method to try and work around this limitation, but see the method help for details.
/// Small screen devices, especially iPod and iPhone will launch the video in its own native video player,
/// outside of the Safari browser. There is no way to avoid this, it's a device imposed limitation.
/// Note: On iOS if you need to detect when the user presses the 'Done' button (before the video ends)
/// then you need to add your own event listener
@JS("Phaser.Video")
class Video {
  // @Ignore
  Video.fakeConstructor$();

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// The key of the Video in the Cache, if stored there. Will be `null` if this Video is using the webcam instead.
  /// Default: null
  external String get key;
  external set key(String v);

  /// The HTML Video Element that is added to the document.
  external VideoElement get video;
  external set video(VideoElement v);
  external BaseTexture get baseTexture;
  external set baseTexture(BaseTexture v);

  /// The PIXI.Texture.
  external Texture get texture;
  external set texture(Texture v);

  /// The Frame this video uses for rendering.
  external Frame get textureFrame;
  external set textureFrame(Frame v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// If true this video will never send its image data to the GPU when its dirty flag is true. This only applies in WebGL.
  external bool get disableTextureUpload;
  external set disableTextureUpload(bool v);
  external bool get dirty;
  external set dirty(bool v);

  /// The current time of the video in seconds. If set the video will attempt to seek to that point in time.
  external num get currentTime;
  external set currentTime(num v);

  /// The duration of the video in seconds.
  external num get duration;
  external set duration(num v);

  /// The progress of this video. This is a value between 0 and 1, where 0 is the start and 1 is the end of the video.
  external num get progress;
  external set progress(num v);

  /// Gets or sets the muted state of the Video.
  external bool get mute;
  external set mute(bool v);

  /// Gets or sets the paused state of the Video.
  /// If the video is still touch locked (such as on iOS devices) this call has no effect.
  external bool get paused;
  external set paused(bool v);

  /// Gets or sets the volume of the Video, a value between 0 and 1. The value given is clamped to the range 0 to 1.
  external bool get volume;
  external set volume(bool v);

  /// Gets or sets the playback rate of the Video. This is the speed at which the video is playing.
  external bool get playbackRate;
  external set playbackRate(bool v);

  /// True if the video is currently playing (and not paused or ended), otherwise false.
  external bool get playing;
  external set playing(bool v);

  /// Gets or sets if the Video is set to loop.
  /// Please note that at present some browsers (i.e. Chrome) do not support *seamless* video looping.
  /// If the video isn't yet set this will always return false.
  external bool get loop;
  external set loop(bool v);

  /// The width of the video in pixels.
  external num get width;
  external set width(num v);

  /// The height of the video in pixels.
  external num get height;
  external set height(num v);

  /// The Video Stream data. Only set if this Video is streaming from the webcam via `startMediaStream`.
  external dynamic get videoStream;
  external set videoStream(dynamic v);

  /// Is there a streaming video source? I.e. from a webcam.
  external bool get isStreaming;
  external set isStreaming(bool v);

  /// A snapshot grabbed from the video. This is initially black. Populate it by calling Video.grab().
  /// When called the BitmapData is updated with a grab taken from the current video playing or active video stream.
  /// If Phaser has been compiled without BitmapData support this property will always be `null`.
  external BitmapData get snapshot;
  external set snapshot(BitmapData v);

  /// The amount of ms allowed to elapsed before the Video.onTimeout signal is dispatched while waiting for webcam access.
  /// Default: 15000
  external num get timeout;
  external set timeout(num v);

  /// When starting playback of a video Phaser will monitor its readyState using a setTimeout call.
  /// The setTimeout happens once every `Video.retryInterval` ms. It will carry on monitoring the video
  /// state in this manner until the `retryLimit` is reached and then abort.
  /// Default: 20
  external num get retryLimit;
  external set retryLimit(num v);

  /// The current retry attempt.
  external num get retry;
  external set retry(num v);

  /// The number of ms between each retry at monitoring the status of a downloading video.
  /// Default: 500
  external num get retryInterval;
  external set retryInterval(num v);

  /// This signal is dispatched if the user allows access to their webcam.
  external Signal get onAccess;
  external set onAccess(Signal v);

  /// This signal is dispatched if an error occurs either getting permission to use the webcam (for a Video Stream) or when trying to play back a video file.
  external Signal get onError;
  external set onError(Signal v);

  /// This signal is dispatched when the Video starts to play. It sends 3 parameters: a reference to the Video object, if the video is set to loop or not and the playback rate.
  external Signal get onPlay;
  external set onPlay(Signal v);

  /// This signal is dispatched when the Video completes playback, i.e. enters an 'ended' state. On iOS specifically it also fires if the user hits the 'Done' button at any point during playback. Videos set to loop will never dispatch this signal.
  external Signal get onComplete;
  external set onComplete(Signal v);
  external Signal get onUpdate;
  external set onUpdate(Signal v);

  /// This signal is dispatched if when asking for permission to use the webcam no response is given within a the Video.timeout limit.
  /// This may be because the user has picked `Not now` in the permissions window, or there is a delay in establishing the LocalMediaStream.
  external Signal get onTimeout;
  external set onTimeout(Signal v);

  /// true if this video is currently locked awaiting a touch event. This happens on some mobile devices, such as iOS.
  external bool get touchLocked;
  external set touchLocked(bool v);
  external VoidFunc0 get complete;
  external set complete(VoidFunc0 v);

  /// A Video object that takes a previously loaded Video from the Phaser Cache and handles playback of it.
  /// Alternatively it takes a getUserMedia feed from an active webcam and streams the contents of that to
  /// the Video instead (see `startMediaStream` method)
  /// The video can then be applied to a Sprite as a texture. If multiple Sprites share the same Video texture and playback
  /// changes (i.e. you pause the video, or seek to a new time) then this change will be seen across all Sprites simultaneously.
  /// Due to a bug in IE11 you cannot play a video texture to a Sprite in WebGL. For IE11 force Canvas mode.
  /// If you need each Sprite to be able to play a video fully independently then you will need one Video object per Sprite.
  /// Please understand the obvious performance implications of doing this, and the memory required to hold videos in RAM.
  /// On some mobile browsers such as iOS Safari, you cannot play a video until the user has explicitly touched the screen.
  /// This works in the same way as audio unlocking. Phaser will handle the touch unlocking for you, however unlike with audio
  /// it's worth noting that every single Video needs to be touch unlocked, not just the first one. You can use the `changeSource`
  /// method to try and work around this limitation, but see the method help for details.
  /// Small screen devices, especially iPod and iPhone will launch the video in its own native video player,
  /// outside of the Safari browser. There is no way to avoid this, it's a device imposed limitation.
  /// Note: On iOS if you need to detect when the user presses the 'Done' button (before the video ends)
  /// then you need to add your own event listener
  external factory Video(Game game, [String key, String url]);

  /// Updates the given Display Objects so they use this Video as their texture.
  /// This will replace any texture they will currently have set.
  external Video add(dynamic /*Sprite|List<Sprite>|Image|List<Image>*/ object);

  /// Creates a new Phaser.Image object, assigns this Video to be its texture, adds it to the world then returns it.
  external Image addToWorld(
      [num x, num y, num anchorX, num anchorY, num scaleX, num scaleY]);

  /// Creates a new Video element from the given Blob. The Blob must contain the video data in the correct encoded format.
  /// This method is typically called by the Phaser.Loader and Phaser.Cache for you, but is exposed publicly for convenience.
  external Video createVideoFromBlob(Blob blob);

  /// Instead of playing a video file this method allows you to stream video data from an attached webcam.
  /// As soon as this method is called the user will be prompted by their browser to "Allow" access to the webcam.
  /// If they allow it the webcam feed is directed to this Video. Call `Video.play` to start the stream.
  /// If they block the webcam the onError signal will be dispatched containing the NavigatorUserMediaError
  /// or MediaStreamError event.
  /// You can optionally set a width and height for the stream. If set the input will be cropped to these dimensions.
  /// If not given then as soon as the stream has enough data the video dimensions will be changed to match the webcam device.
  /// You can listen for this with the onChangeSource signal.
  external Video startMediaStream([bool captureAudio, num width, num height]);

  /// Creates a new Video element from the given URL.
  external Video createVideoFromURL(String url, [bool autoplay]);

  /// On some mobile browsers you cannot play a video until the user has explicitly touched the video to allow it.
  /// Phaser handles this via the `setTouchLock` method. However if you have 3 different videos, maybe an "Intro", "Start" and "Game Over"
  /// split into three different Video objects, then you will need the user to touch-unlock every single one of them.
  /// You can avoid this by using just one Video object and simply changing the video source. Once a Video element is unlocked it remains
  /// unlocked, even if the source changes. So you can use this to your benefit to avoid forcing the user to 'touch' the video yet again.
  /// As you'd expect there are limitations. So far we've found that the videos need to be in the same encoding format and bitrate.
  /// This method will automatically handle a change in video dimensions, but if you try swapping to a different bitrate we've found it
  /// cannot render the new video on iOS (desktop browsers cope better).
  /// When the video source is changed the video file is requested over the network. Listen for the `onChangeSource` signal to know
  /// when the new video has downloaded enough content to be able to be played. Previous settings such as the volume and loop state
  /// are adopted automatically by the new video.
  external Video changeSource(String src, [bool autoplay]);
  external Video connectToMediaStram(dynamic video, dynamic stream);

  /// Destroys the Video object. This calls `Video.stop` and then `Video.removeVideoElement`.
  /// If any Sprites are using this Video as their texture it is up to you to manage those.
  external void destroy();

  /// Starts this video playing.
  /// If the video is already playing, or has been queued to play with `changeSource` then this method just returns.
  external Video play([bool loop, num playbackRate]);

  /// Called when the video starts to play. Updates the texture.
  external void playHandler();

  /// If the game is running in WebGL this will push the texture up to the GPU if it's dirty.
  /// This is called automatically if the Video is being used by a Sprite, otherwise you need to remember to call it in your render function.
  /// If you wish to suppress this functionality set Video.disableTextureUpload to `true`.
  external void render();

  /// Removes the Video element from the DOM by calling parentNode.removeChild on itself.
  /// Also removes the autoplay and src attributes and nulls the reference.
  external void removeVideoElement();
  external void resizeFrame(dynamic parent, num width, num height);

  /// Sets the Input Manager touch callback to be Video.unlock.
  /// Required for mobile video unlocking. Mostly just used internally.
  external void setTouchLock();

  /// Grabs the current frame from the Video or Video Stream and renders it to the Video.snapshot BitmapData.
  /// You can optionally set if the BitmapData should be cleared or not, the alpha and the blend mode of the draw.
  /// If you need more advanced control over the grabbing them call `Video.snapshot.copy` directly with the same parameters as BitmapData.copy.
  external BitmapData grab([bool clear, num alpha, String blendMode]);

  /// Stops the video playing.
  /// This removes all locally set signals.
  /// If you only wish to pause playback of the video, to resume at a later time, use `Video.paused = true` instead.
  /// If the video hasn't finished downloading calling `Video.stop` will not abort the download. To do that you need to
  /// call `Video.destroy` instead.
  /// If you are using a video stream from a webcam then calling Stop will disconnect the MediaStream session and disable the webcam.
  external void stop();

  /// Enables the video on mobile devices, usually after the first touch.
  /// If the SoundManager hasn't been unlocked then this will automatically unlock that as well.
  /// Only one video can be pending unlock at any one time.
  external bool unlock();

  /// Called automatically if the video source changes and updates the internal texture dimensions.
  /// Then dispatches the onChangeSource signal.
  external void updateTexture([dynamic event, num width, num height]);
}

// Module Physics
/// The Arcade Physics world. Contains Arcade Physics related collision, overlap and motion methods.
@JS("Phaser.Physics.Arcade")
class Arcade {
  // @Ignore
  Arcade.fakeConstructor$();

  /// A constant used for the sortDirection value.
  /// Use this if you don't wish to perform any pre-collision sorting at all, or will manually sort your Groups.
  external static num get SORT_NONE;
  external static set SORT_NONE(num v);

  /// A constant used for the sortDirection value.
  /// Use this if your game world is wide but short and scrolls from the left to the right (i.e. Mario)
  external static num get LEFT_RIGHT;
  external static set LEFT_RIGHT(num v);

  /// A constant used for the sortDirection value.
  /// Use this if your game world is wide but short and scrolls from the right to the left (i.e. Mario backwards)
  external static num get RIGHT_LEFT;
  external static set RIGHT_LEFT(num v);

  /// A constant used for the sortDirection value.
  /// Use this if your game world is narrow but tall and scrolls from the top to the bottom (i.e. Dig Dug)
  external static num get TOP_BOTTOM;
  external static set TOP_BOTTOM(num v);

  /// A constant used for the sortDirection value.
  /// Use this if your game world is narrow but tall and scrolls from the bottom to the top (i.e. Commando or a vertically scrolling shoot-em-up)
  external static num get BOTTOM_TOP;
  external static set BOTTOM_TOP(num v);

  /// A value added to the delta values during collision checks.
  external static num get OVERLAP_BIAS;
  external static set OVERLAP_BIAS(num v);
  external static num get TILE_BIAS;
  external static set TILE_BIAS(num v);

  /// The Arcade Physics world. Contains Arcade Physics related collision, overlap and motion methods.
  external factory Arcade(Game game);

  /// The bounds inside of which the physics world exists. Defaults to match the world bounds.
  external Rectangle get bounds;
  external set bounds(Rectangle v);

  /// Which edges of the World bounds Bodies can collide against when `collideWorldBounds` is `true`.
  /// For example checkCollision.down = false means Bodies cannot collide with the World.bounds.bottom. An object containing allowed collision flags (up, down, left, right).
  external dynamic /*{ up?: boolean; down?: boolean; left?: boolean; right?: boolean; }*/ get checkCollision;
  external set checkCollision(
      dynamic /*{ up?: boolean; down?: boolean; left?: boolean; right?: boolean; }*/ v);

  /// If true World.separate will always separate on the X axis before Y. Otherwise it will check gravity totals first.
  external bool get forceX;
  external set forceX(bool v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// The World gravity setting. Defaults to x: 0, y: 0, or no gravity.
  external PhaserPoint get gravity;
  external set gravity(Point v);

  /// If `true` the `Body.preUpdate` method will be skipped, halting all motion for all bodies. Note that other methods such as `collide` will still work, so be careful not to call them on paused bodies.
  external bool get isPaused;
  external set isPaused(bool v);

  /// The world QuadTree.
  external QuadTree get quadTree;
  external set quadTree(QuadTree v);

  /// Used by the QuadTree to set the maximum number of objects per quad.
  external num get maxObjects;
  external set maxObjects(num v);

  /// Used by the QuadTree to set the maximum number of iteration levels.
  external num get maxLevels;
  external set maxLevels(num v);

  /// If true the QuadTree will not be used for any collision. QuadTrees are great if objects are well spread out in your game, otherwise they are a performance hit. If you enable this you can disable on a per body basis via `Body.skipQuadTree`.
  external bool get skipQuadTree;
  external set skipQuadTree(bool v);

  /// Used when colliding a Sprite vs. a Group, or a Group vs. a Group, this defines the direction the sort is based on. Default is Phaser.Physics.Arcade.LEFT_RIGHT.
  external num get sortDirection;
  external set sortDirection(num v);

  /// Given the rotation (in radians) and speed calculate the acceleration and return it as a Point object, or set it to the given point object.
  /// One way to use this is: accelerationFromRotation(rotation, 200, sprite.acceleration) which will set the values directly to the sprites acceleration and not create a new Point object.
  external Point accelerationFromRotation(num rotation,
      [num speed, Point point]);

  /// Sets the acceleration.x/y property on the display object so it will move towards the target at the given speed (in pixels per second sq.)
  /// You must give a maximum speed value, beyond which the display object won't go any faster.
  /// Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
  /// Note: The display object doesn't stop moving once it reaches the destination coordinates.
  external num accelerateToObject(dynamic displayObject, dynamic destination,
      [num speed, num xSpeedMax, num ySpeedMax]);

  /// Sets the acceleration.x/y property on the display object so it will move towards the target at the given speed (in pixels per second sq.)
  /// You must give a maximum speed value, beyond which the display object won't go any faster.
  /// Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
  /// Note: The display object doesn't stop moving once it reaches the destination coordinates.
  external num accelerateToPointer(dynamic displayObject,
      [Pointer pointer, num speed, num xSpeedMax, num ySpeedMax]);

  /// Sets the acceleration.x/y property on the display object so it will move towards the x/y coordinates at the given speed (in pixels per second sq.)
  /// You must give a maximum speed value, beyond which the display object won't go any faster.
  /// Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
  /// Note: The display object doesn't stop moving once it reaches the destination coordinates.
  external num accelerateToXY(dynamic displayObject, num x, num y,
      [num speed, num xSpeedMax, num ySpeedMax]);

  /// Find the angle in radians between two display objects (like Sprites).
  /// The optional `world` argument allows you to return the result based on the Game Objects `world` property,
  /// instead of its `x` and `y` values. This is useful of the object has been nested inside an offset Group,
  /// or parent Game Object.
  external num angleBetween(dynamic source, dynamic target, [bool world]);

  /// Find the angle in radians between a display object (like a Sprite) and a Pointer, taking their x/y and center into account.
  /// The optional `world` argument allows you to return the result based on the Game Objects `world` property,
  /// instead of its `x` and `y` values. This is useful of the object has been nested inside an offset Group,
  /// or parent Game Object.
  external num angleToPointer(dynamic displayObject,
      [Pointer pointer, bool world]);

  /// Find the angle in radians between a display object (like a Sprite) and the given x/y coordinate.
  /// The optional `world` argument allows you to return the result based on the Game Objects `world` property,
  /// instead of its `x` and `y` values. This is useful of the object has been nested inside an offset Group,
  /// or parent Game Object.
  external num angleToXY(dynamic displayObject, num x, num y, [bool world]);

  /// From a set of points or display objects, find the one closest to a source point or object.
  external dynamic closest(dynamic source, List<dynamic> targets,
      [bool world, bool useCenter]);

  /// Checks for collision between two game objects and separates them if colliding ([https://gist.github.com/samme/cbb81dd19f564dcfe2232761e575063d details]). If you don't require separation then use [Phaser.Physics.Arcade#overlap overlap] instead.
  /// You can perform Sprite vs. Sprite, Sprite vs. Group, Group vs. Group, Sprite vs. Tilemap Layer or Group vs. Tilemap Layer collisions.
  /// Both the `object1` and `object2` can be arrays of objects, of differing types.
  /// If two Groups or arrays are passed, each member of one will be tested against each member of the other.
  /// If one Group **only** is passed (as `object1`), each member of the Group will be collided against the other members.
  /// If either object is `null` the collision test will fail.
  /// Bodies with `enable = false` and Sprites with `exists = false` are skipped (ignored).
  /// An optional processCallback can be provided. If given this function will be called when two sprites are found to be colliding. It is called before any separation takes place, giving you the chance to perform additional checks. If the function returns true then the collision and separation is carried out. If it returns false it is skipped.
  /// The collideCallback is an optional function that is only called if two sprites collide. If a processCallback has been set then it needs to return true for collideCallback to be called.
  /// **This function is not recursive**, and will not test against children of objects passed (i.e. Groups or Tilemaps within other Groups).
  /// ##### Examples
  /// ```javascript
  /// collide(group);
  /// collide(group, undefined); // equivalent
  /// collide(sprite1, sprite2);
  /// collide(sprite, group);
  /// collide(group1, group2);
  /// collide([sprite1, sprite2], [sprite3, sprite4]); // 1 vs. 3, 1 vs. 4, 2 vs. 3, 2 vs. 4
  /// ```
  /// ##### Tilemaps
  /// Tiles marked via [Phaser.Tilemap#setCollision] (and similar methods) are "solid". If a Sprite collides with one of these tiles, the two are separated by moving the Sprite outside the tile's edges. Enable [Phaser.TilemapLayer#debug] to see the colliding edges of the Tilemap.
  /// Tiles with a callback attached via [Phaser.Tilemap#setTileIndexCallback] or [Phaser.Tilemap#setTileLocationCallback] invoke the callback if a Sprite collides with them. If a tile has a callback attached via both methods, only the location callback is invoked. The colliding Sprite is separated from the tile only if the callback returns `true`.
  external bool collide(dynamic object1,
      [dynamic object2,
      Function collideCallback,
      Function processCallback,
      dynamic callbackContext]);

  /// A tween-like function that takes a starting velocity and some other factors and returns an altered velocity.
  /// Based on a function in Flixel by @ADAMATOMIC
  external num computeVelocity(
      num axis, Body body, num velocity, num acceleration, num drag,
      [num max]);

  /// Find the distance between two display objects (like Sprites).
  /// The optional `world` argument allows you to return the result based on the Game Objects `world` property,
  /// instead of its `x` and `y` values. This is useful of the object has been nested inside an offset Group,
  /// or parent Game Object.
  /// If you have nested objects and need to calculate the distance between their centers in World coordinates,
  /// set their anchors to (0.5, 0.5) and use the `world` argument.
  /// If objects aren't nested or they share a parent's offset, you can calculate the distance between their
  /// centers with the `useCenter` argument, regardless of their anchor values.
  external num distanceBetween(dynamic source, dynamic target,
      [bool world, bool useCenter]);

  /// Find the distance between a display object (like a Sprite) and a Pointer. If no Pointer is given the Input.activePointer is used.
  /// The calculation is made from the display objects x/y coordinate. This may be the top-left if its anchor hasn't been changed.
  /// If you need to calculate from the center of a display object instead use [Phaser.Physics.Arcade#distanceBetween distanceBetween] with the `useCenter` argument.
  /// The optional `world` argument allows you to return the result based on the Game Objects `world` property,
  /// instead of its `x` and `y` values. This is useful of the object has been nested inside an offset Group,
  /// or parent Game Object.
  external num distanceToPointer(dynamic displayObject,
      [Pointer pointer, bool world]);

  /// Find the distance between a display object (like a Sprite) and the given x/y coordinates.
  /// The calculation is made from the display objects x/y coordinate. This may be the top-left if its anchor hasn't been changed.
  /// If you need to calculate from the center of a display object instead use [Phaser.Physics.Arcade#distanceBetween distanceBetween] with the `useCenter` argument.
  /// The optional `world` argument allows you to return the result based on the Game Objects `world` property,
  /// instead of its `x` and `y` values. This is useful of the object has been nested inside an offset Group,
  /// or parent Game Object.
  external num distanceToXY(dynamic displayObject, num x, num y, [bool world]);

  /// This will create an Arcade Physics body on the given game object or array of game objects.
  /// A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.
  external void enable(dynamic object, [bool children]);

  /// Creates an Arcade Physics body on the given game object.
  /// A game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.
  /// When you add an Arcade Physics body to an object it will automatically add the object into its parent Groups hash array.
  external void enableBody(dynamic object);

  /// From a set of points or display objects, find the one farthest from a source point or object.
  external dynamic farthest(dynamic source, List<dynamic> targets,
      [bool world, bool useCenter]);

  /// Given a Group and a location this will check to see which Group children overlap with the coordinates.
  /// Each child will be sent to the given callback for further processing.
  /// Note that the children are not checked for depth order, but simply if they overlap the coordinate or not.
  external List<Sprite> getObjectsAtLocation(num x, num y, Group group,
      [void callback(dynamic callbackArg, dynamic object),
      dynamic callbackContext,
      dynamic callbackArg]);

  /// Calculates the horizontal overlap between two Bodies and sets their properties accordingly, including:
  /// `touching.left`, `touching.right` and `overlapX`.
  external num getOverlapX(Body body1, Body body2);

  /// Calculates the vertical overlap between two Bodies and sets their properties accordingly, including:
  /// `touching.up`, `touching.down` and `overlapY`.
  external num getOverlapY(Body body1, Body body2);

  /// Check for intersection against two bodies.
  external bool intersects(Body body1, Body body2);

  /// Move the given display object towards the destination object at a steady velocity.
  /// If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.
  /// Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.
  /// Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
  /// Note: The display object doesn't stop moving once it reaches the destination coordinates.
  /// Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)
  external num moveToObject(dynamic displayObject, dynamic destination,
      [num speed, num maxTime]);

  /// Move the given display object towards the pointer at a steady velocity. If no pointer is given it will use Phaser.Input.activePointer.
  /// If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
  /// Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.
  /// Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
  /// Note: The display object doesn't stop moving once it reaches the destination coordinates.
  external num moveToPointer(dynamic displayObject,
      [num speed, Pointer pointer, num maxTime]);

  /// Move the given display object towards the x/y coordinates at a steady velocity.
  /// If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.
  /// Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.
  /// Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.
  /// Note: The display object doesn't stop moving once it reaches the destination coordinates.
  /// Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)
  external num moveToXY(dynamic displayObject, num x, num y,
      [num speed, num maxTime]);

  /// Checks for overlaps between two game objects. The objects can be Sprites, Groups or Emitters.
  /// Unlike [Phaser.Physics.Arcade#collide collide] the objects are NOT automatically separated or have any physics applied, they merely test for overlap results.
  /// You can perform Sprite vs. Sprite, Sprite vs. Group and Group vs. Group overlap checks.
  /// Both the first and second parameter can be arrays of objects, of differing types.
  /// If two arrays are passed, the contents of the first parameter will be tested against all contents of the 2nd parameter.
  /// **This function is not recursive**, and will not test against children of objects passed (i.e. Groups within Groups).
  /// ##### Tilemaps
  /// Any overlapping tiles, including blank/null tiles, will give a positive result. Tiles marked via [Phaser.Tilemap#setCollision] (and similar methods) have no special status, and callbacks added via [Phaser.Tilemap#setTileIndexCallback] or [Phaser.Tilemap#setTileLocationCallback] are not invoked. So calling this method without any callbacks isn't very useful.
  /// If you're interested only in whether an object overlaps a certain tile or class of tiles, filter the tiles with `processCallback` and then use the result returned by this method. Blank/null tiles can be excluded by their [Phaser.Tile#index index] (-1).
  /// If you want to take action on certain overlaps, examine the tiles in `collideCallback` and then handle as you like.
  external bool overlap(dynamic object1, dynamic object2,
      [Function overlapCallback,
      Function processCallback,
      dynamic callbackContext]);
  external bool processTileSeparationX(Body body, num x);
  external void processTileSeparationY(Body body, num y);

  /// Updates the size of this physics world.
  external void setBounds(num x, num y, num width, num height);

  /// Updates the size of this physics world to match the size of the game world.
  external void setBoundsToWorld();

  /// The core separation function to separate two physics bodies.
  external bool separate(Body body1, Body body2,
      [Function processCallback, dynamic callbackContext, bool overlapOnly]);

  /// The core separation function to separate two physics bodies on the x axis.
  external bool separateX(Body body1, Body body2, bool overlapOnly);

  /// The core separation function to separate two physics bodies on the y axis.
  external bool separateY(Body body1, Body body2, bool overlapOnly);
  external bool separateTile(num i, Body body, Tile tile);

  /// This method will sort a Groups hash array.
  /// If the Group has `physicsSortDirection` set it will use the sort direction defined.
  /// Otherwise if the sortDirection parameter is undefined, or Group.physicsSortDirection is null, it will use Phaser.Physics.Arcade.sortDirection.
  /// By changing Group.physicsSortDirection you can customise each Group to sort in a different order.
  external void sort(Group group);
  external num tileCheckX(Body body, Tile tile);
  external num tileCheckY(Body body, Tile tile);

  /// Called automatically by a Physics body, it updates all motion related values on the Body unless `World.isPaused` is `true`.
  external void updateMotion(Body body);

  /// Given the angle (in degrees) and speed calculate the velocity and return it as a Point object, or set it to the given point object.
  /// One way to use this is: velocityFromAngle(angle, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.
  external Point velocityFromAngle(num angle, [num speed, Point point]);

  /// Given the rotation (in radians) and speed calculate the velocity and return it as a Point object, or set it to the given point object.
  /// One way to use this is: velocityFromRotation(rotation, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.
  external Point velocityFromRotation(num rotation, [num speed, Point point]);
}

// Module Arcade
/// The Physics Body is linked to a single Sprite. All physics operations should be performed against the body rather than
/// the Sprite itself. For example you can set the velocity, acceleration, bounce values etc all on the Body.
@JS("Phaser.Physics.Arcade.Body")
class Body {
  // @Ignore
  Body.fakeConstructor$();

  /// The Physics Body is linked to a single Sprite. All physics operations should be performed against the body rather than
  /// the Sprite itself. For example you can set the velocity, acceleration, bounce values etc all on the Body.
  external factory Body(Sprite sprite);

  /// The acceleration is the rate of change of the velocity. Measured in pixels per second squared.
  external PhaserPoint get acceleration;
  external set acceleration(Point v);

  /// Allow this Body to be influenced by [Phaser.Physics.Arcade.Body#drag drag]?
  /// Default: true
  external bool get allowDrag;
  external set allowDrag(bool v);

  /// Allow this Body to be influenced by gravity? Either world or local.
  /// Default: true
  external bool get allowGravity;
  external set allowGravity(bool v);

  /// Allow this Body to be rotated? (via angularVelocity, etc)
  /// Default: true
  external bool get allowRotation;
  external set allowRotation(bool v);

  /// The angle of the Body's **velocity** in radians.
  external num get angle;
  external set angle(num v);

  /// The angular acceleration is the rate of change of the angular velocity. Measured in degrees per second squared.
  external num get angularAcceleration;
  external set angularAcceleration(num v);

  /// The drag applied during the rotation of the Body. Measured in degrees per second squared.
  external num get angularDrag;
  external set angularDrag(num v);

  /// The angular velocity is the rate of change of the Body's rotation. It is measured in degrees per second.
  external num get angularVelocity;
  external set angularVelocity(num v);

  /// This object is populated with boolean values when the Body collides with the World bounds or a Tile.
  /// For example if blocked.up is true then the Body cannot move up. An object containing on which faces this Body is blocked from moving, if any (none, up, down, left, right).
  external FaceChoices get blocked;
  external set blocked(FaceChoices v);

  /// The bottom value of this Body (same as Body.y + Body.height)
  external num get bottom;
  external set bottom(num v);

  /// The elasticity of the Body when colliding. bounce.x/y = 1 means full rebound, bounce.x/y = 0.5 means 50% rebound velocity.
  external PhaserPoint get bounce;
  external set bounce(Point v);

  /// The center coordinate of the Physics Body.
  external PhaserPoint get center;
  external set center(Point v);

  /// Set the checkCollision properties to control which directions collision is processed for this Body.
  /// For example checkCollision.up = false means it won't collide when the collision happened while moving up.
  /// If you need to disable a Body entirely, use `body.enable = false`, this will also disable motion.
  /// If you need to disable just collision and/or overlap checks, but retain motion, set `checkCollision.none = true`. An object containing allowed collision (none, up, down, left, right).
  external FaceChoices get checkCollision;
  external set checkCollision(FaceChoices v);

  /// A Body can be set to collide against the World bounds automatically and rebound back into the World if this is set to true. Otherwise it will leave the World. Should the Body collide with the World bounds?
  external bool get collideWorldBounds;
  external set collideWorldBounds(bool v);

  /// This flag allows you to disable the custom x separation that takes place by Physics.Arcade.separate.
  /// Used in combination with your own collision processHandler you can create whatever type of collision response you need. Use a custom separation system or the built-in one?
  external bool get customSeparateX;
  external set customSeparateX(bool v);

  /// This flag allows you to disable the custom y separation that takes place by Physics.Arcade.separate.
  /// Used in combination with your own collision processHandler you can create whatever type of collision response you need. Use a custom separation system or the built-in one?
  external bool get customSeparateY;
  external set customSeparateY(bool v);

  /// The Sprite position is updated based on the delta x/y values. You can set a cap on those (both +-) using deltaMax.
  external PhaserPoint get deltaMax;
  external set deltaMax(Point v);

  /// If this Body in a preUpdate (true) or postUpdate (false) state?
  external bool get dirty;
  external set dirty(bool v);

  /// The drag applied to the motion of the Body (when [Phaser.Physics.Arcade.Body#allowDrag allowDrag] is enabled). Measured in pixels per second squared.
  external PhaserPoint get drag;
  external set drag(Point v);

  /// If a body is overlapping with another body, but neither of them are moving (maybe they spawned on-top of each other?) this is set to true. Body embed value.
  external bool get embedded;
  external set embedded(bool v);

  /// A disabled body won't be checked for any form of collision or overlap or have its pre/post updates run.
  /// Default: true
  external bool get enable;
  external set enable(bool v);

  /// A const reference to the direction the Body is traveling or facing: Phaser.NONE, Phaser.LEFT, Phaser.RIGHT, Phaser.UP, or Phaser.DOWN. If the Body is moving on both axes, UP and DOWN take precedence.
  external num get facing;
  external set facing(num v);

  /// If this Body is [Phaser.Physics.Arcade.Body#immovable immovable] and moving, and another Body is 'riding' this one, this is the amount of motion the riding Body receives on each axis.
  external PhaserPoint get friction;
  external set friction(Point v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// This Body's local gravity, **added** to any world gravity, unless Body.allowGravity is set to false.
  external PhaserPoint get gravity;
  external set gravity(Point v);

  /// The calculated width / 2 of the physics body.
  external num get halfWidth;
  external set halfWidth(num v);

  /// The calculated height / 2 of the physics body.
  external num get halfHeight;
  external set halfHeight(num v);

  /// The calculated height of the physics body.
  external num get height;
  external set height(num v);

  /// An immovable Body will not receive any impacts from other bodies. **Two** immovable Bodies can't separate or exchange momentum and will pass through each other.
  external bool get immovable;
  external set immovable(bool v);

  /// If `true` this Body is using circular collision detection. If `false` it is using rectangular.
  /// Use `Body.setCircle` to control the collision shape this Body uses.
  external bool get isCircle;
  external set isCircle(bool v);

  /// Set by the `moveTo` and `moveFrom` methods.
  external bool get isMoving;
  external set isMoving(bool v);

  /// The mass of the Body. When two bodies collide their mass is used in the calculation to determine the exchange of velocity.
  /// Default: 1
  external num get mass;
  external set mass(num v);

  /// The maximum angular velocity in degrees per second that the Body can reach.
  /// Default: 1000
  external num get maxAngular;
  external set maxAngular(num v);

  /// The maximum velocity (in pixels per second squared) that the Body can reach.
  external PhaserPoint get maxVelocity;
  external set maxVelocity(Point v);

  /// Whether the physics system should update the Body's position and rotation based on its velocity, acceleration, drag, and gravity.
  /// If you have a Body that is being moved around the world via a tween or a Group motion, but its local x/y position never
  /// actually changes, then you should set Body.moves = false. Otherwise it will most likely fly off the screen.
  /// If you want the physics system to move the body around, then set moves to true.
  /// A Body with moves = false can still be moved slightly (but not accelerated) during collision separation unless you set [Phaser.Physics.Arcade.Body#immovable immovable] as well. Set to true to allow the Physics system to move this Body, otherwise false to move it manually.
  /// Default: true
  external bool get moves;
  external set moves(bool v);

  /// Optional callback. If set, invoked during the running of `moveTo` or `moveFrom` events.
  external dynamic get movementCallback;
  external set movementCallback(dynamic v);

  /// Context in which to call the movementCallback.
  external dynamic get movementCallbackContext;
  external set movementCallbackContext(dynamic v);

  /// The distanced traveled during the last update, equal to `velocity * physicsElapsed`. Calculated during the Body.preUpdate and applied to its position.
  external PhaserPoint get newVelocity;
  external set newVelocity(Point v);

  /// The offset of the Physics Body from the Sprite's texture.
  external PhaserPoint get offset;
  external set offset(Point v);

  /// A Signal that is dispatched when this Body collides with another Body.
  /// You still need to call `game.physics.arcade.collide` in your `update` method in order
  /// for this signal to be dispatched.
  /// Usually you'd pass a callback to the `collide` method, but this signal provides for
  /// a different level of notification.
  /// Due to the potentially high volume of signals this could create it is disabled by default.
  /// To use this feature set this property to a Phaser.Signal: `sprite.body.onCollide = new Phaser.Signal()`
  /// and it will be called when a collision happens, passing two arguments: the sprites which collided.
  /// The first sprite in the argument is always the owner of this Body.
  /// If two Bodies with this Signal set collide, both will dispatch the Signal.
  external Signal get onCollide;
  external set onCollide(Signal v);

  /// Listen for the completion of `moveTo` or `moveFrom` events.
  external Signal get onMoveComplete;
  external set onMoveComplete(Signal v);

  /// A Signal that is dispatched when this Body overlaps with another Body.
  /// You still need to call `game.physics.arcade.overlap` in your `update` method in order
  /// for this signal to be dispatched.
  /// Usually you'd pass a callback to the `overlap` method, but this signal provides for
  /// a different level of notification.
  /// Due to the potentially high volume of signals this could create it is disabled by default.
  /// To use this feature set this property to a Phaser.Signal: `sprite.body.onOverlap = new Phaser.Signal()`
  /// and it will be called when a collision happens, passing two arguments: the sprites which collided.
  /// The first sprite in the argument is always the owner of this Body.
  /// If two Bodies with this Signal set collide, both will dispatch the Signal.
  external Signal get onOverlap;
  external set onOverlap(Signal v);

  /// A Signal that is dispatched when this Body collides with the world bounds.
  /// Due to the potentially high volume of signals this could create it is disabled by default.
  /// To use this feature set this property to a Phaser.Signal: `sprite.body.onWorldBounds = new Phaser.Signal()`
  /// and it will be called when a collision happens, passing five arguments:
  /// `onWorldBounds(sprite, up, down, left, right)`
  /// where the Sprite is a reference to the Sprite that owns this Body, and the other arguments are booleans
  /// indicating on which side of the world the Body collided.
  external Signal get onWorldBounds;
  external set onWorldBounds(Signal v);

  /// When this body collides with another, the amount of overlap is stored here. The amount of horizontal overlap during the collision.
  external num get overlapX;
  external set overlapX(num v);

  /// When this body collides with another, the amount of overlap is stored here. The amount of vertical overlap during the collision.
  external num get overlapY;
  external set overlapY(num v);
  external num get phase;
  external set phase(num v);

  /// The position of the physics body, equivalent to ([Phaser.Physics.Arcade.Body#left left], [Phaser.Physics.Arcade.Body#top top]).
  external PhaserPoint get position;
  external set position(Point v);

  /// The previous rotation of the physics body, in degrees.
  external num get preRotation;
  external set preRotation(num v);

  /// The previous position of the physics body.
  external PhaserPoint get prev;
  external set prev(Point v);

  /// The radius of the circular collision shape this Body is using if Body.setCircle has been enabled, relative to the Sprite's _texture_.
  /// If you wish to change the radius then call [Phaser.Physics.Arcade.Body#setCircle setCircle] again with the new value.
  /// If you wish to stop the Body using a circle then call [Phaser.Physics.Arcade.Body#setCircle setCircle] with a radius of zero (or undefined).
  /// The actual radius of the Body (at any Sprite scale) is equal to [Phaser.Physics.Arcade.Body#halfWidth halfWidth] and the diameter is equal to [Phaser.Physics.Arcade.Body#width width].
  external num get radius;
  external set radius(num v);

  /// The right value of this Body (same as Body.x + Body.width)
  external num get right;
  external set right(num v);

  /// The Body's rotation in degrees, as calculated by its angularVelocity and angularAcceleration. Please understand that the collision Body
  /// itself never rotates, it is always axis-aligned. However these values are passed up to the parent Sprite and updates its rotation.
  external num get rotation;
  external set rotation(num v);

  /// If true and you collide this Sprite against a Group, it will disable the collision check from using a QuadTree.
  external bool get skipQuadTree;
  external set skipQuadTree(bool v);

  /// The un-scaled original size.
  external num get sourceWidth;
  external set sourceWidth(num v);

  /// The un-scaled original size.
  external num get sourceHeight;
  external set sourceHeight(num v);

  /// The speed of the Body in pixels per second, equal to the magnitude of the velocity.
  external num get speed;
  external set speed(num v);

  /// Reference to the parent Sprite.
  external Sprite get sprite;
  external set sprite(Sprite v);

  /// Set by the `moveTo` and `moveFrom` methods.
  external bool get stopVelocityOnCollide;
  external set stopVelocityOnCollide(bool v);

  /// If true the Body will check itself against the Sprite.getBounds() dimensions and adjust its width and height accordingly.
  /// If false it will compare its dimensions against the Sprite scale instead, and adjust its width height if the scale has changed.
  /// Typically you would need to enable syncBounds if your sprite is the child of a responsive display object such as a FlexLayer,
  /// or in any situation where the Sprite scale doesn't change, but its parents scale is effecting the dimensions regardless.
  external bool get syncBounds;
  external set syncBounds(bool v);

  /// If this is an especially small or fast moving object then it can sometimes skip over tilemap collisions if it moves through a tile in a step.
  /// Set this padding value to add extra padding to its bounds. tilePadding.x applied to its width, y to its height. Extra padding to be added to this sprite's dimensions when checking for tile collision.
  external PhaserPoint get tilePadding;
  external set tilePadding(Point v);

  /// This object is populated with boolean values when the Body collides with another.
  /// touching.up = true means the collision happened to the top of this Body for example. An object containing touching results (none, up, down, left, right).
  external FaceChoices get touching;
  external set touching(FaceChoices v);

  /// The type of physics system this body belongs to.
  external num get type;
  external set type(num v);

  /// This object is populated with previous touching values from the bodies previous collision. An object containing previous touching results (none, up, down, left, right).
  external FaceChoices get wasTouching;
  external set wasTouching(FaceChoices v);

  /// The calculated width of the physics body.
  external num get width;
  external set width(num v);

  /// The elasticity of the Body when colliding with the World bounds.
  /// By default this property is `null`, in which case `Body.bounce` is used instead. Set this property
  /// to a Phaser.Point object in order to enable a World bounds specific bounce value.
  external PhaserPoint get worldBounce;
  external set worldBounce(Point v);

  /// The velocity, or rate of change the Body's position. Measured in pixels per second.
  external PhaserPoint get velocity;
  external set velocity(Point v);

  /// The x position.
  external num get x;
  external set x(num v);

  /// The y position.
  external num get y;
  external set y(num v);

  /// Internal method.
  external void checkWorldBounds();

  /// Returns the delta x value. The difference between Body.x now and in the previous step.
  external num deltaX();

  /// Returns the delta y value. The difference between Body.y now and in the previous step.
  external num deltaY();

  /// Returns the delta z value. The difference between Body.rotation now and in the previous step.
  external num deltaZ();

  /// Returns the absolute delta x value.
  external num deltaAbsX();

  /// Returns the absolute delta y value.
  external num deltaAbsY();

  /// Destroys this Body.
  /// First it calls Group.removeFromHash if the Game Object this Body belongs to is part of a Group.
  /// Then it nulls the Game Objects body reference, and nulls this Body.sprite reference.
  external void destroy();

  /// Returns the bounds of this physics body.
  /// Only used internally by the World collision methods.
  external dynamic getBounds(dynamic obj);

  /// Tests if a world point lies within this Body.
  external bool hitTest(num x, num y);

  /// Note: This method is experimental, and may be changed or removed in a future release.
  /// This method moves the Body in the given direction, for the duration specified.
  /// It works by setting the velocity on the Body, and an internal timer, and then
  /// monitoring the duration each frame. When the duration is up the movement is
  /// stopped and the `Body.onMoveComplete` signal is dispatched.
  /// Movement also stops if the Body collides or overlaps with any other Body.
  /// You can control if the velocity should be reset to zero on collision, by using
  /// the property `Body.stopVelocityOnCollide`.
  /// Stop the movement at any time by calling `Body.stopMovement`.
  /// You can optionally set a speed in pixels per second. If not specified it
  /// will use the current `Body.speed` value. If this is zero, the function will return false.
  /// Please note that due to browser timings you should allow for a variance in
  /// when the duration will actually expire. Depending on system it may be as much as
  /// +- 50ms. Also this method doesn't take into consideration any other forces acting
  /// on the Body, such as Gravity, drag or maxVelocity, all of which may impact the
  /// movement.
  external bool moveFrom(num duration, [num speed, num direction]);

  /// Note: This method is experimental, and may be changed or removed in a future release.
  /// This method moves the Body in the given direction, for the duration specified.
  /// It works by setting the velocity on the Body, and an internal distance counter.
  /// The distance is monitored each frame. When the distance equals the distance
  /// specified in this call, the movement is stopped, and the `Body.onMoveComplete`
  /// signal is dispatched.
  /// Movement also stops if the Body collides or overlaps with any other Body.
  /// You can control if the velocity should be reset to zero on collision, by using
  /// the property `Body.stopVelocityOnCollide`.
  /// Stop the movement at any time by calling `Body.stopMovement`.
  /// Please note that due to browser timings you should allow for a variance in
  /// when the distance will actually expire.
  /// Note: This method doesn't take into consideration any other forces acting
  /// on the Body, such as Gravity, drag or maxVelocity, all of which may impact the
  /// movement.
  external bool moveTo(num duration, num distance, [num direction]);

  /// Returns true if the bottom of this Body is in contact with either the world bounds or a tile.
  external bool onFloor();

  /// Returns true if either side of this Body is in contact with either the world bounds or a tile.
  external bool onWall();

  /// Internal method.
  external void preUpdate();

  /// Internal method.
  external void postUpdate();

  /// Render Sprite Body.
  external void render(dynamic context, Body body,
      [String color, bool filled, num lineWidth]);

  /// Render Sprite Body Physics Data as text.
  external void renderBodyInfo(Debug debug, Body body);

  /// Resets all Body values (velocity, acceleration, rotation, etc)
  external void reset(num x, num y);

  /// Sets this Body as using a circle, of the given radius, for all collision detection instead of a rectangle.
  /// The radius is given in pixels (relative to the Sprite's _texture_) and is the distance from the center of the circle to the edge.
  /// You can also control the x and y offset, which is the position of the Body relative to the top-left of the Sprite's texture.
  /// To change a Body back to being rectangular again call `Body.setSize`.
  /// Note: Circular collision only happens with other Arcade Physics bodies, it does not
  /// work against tile maps, where rectangular collision is the only method supported.
  external void setCircle(num radius, [num offsetX, num offsetY]);

  /// You can modify the size of the physics Body to be any dimension you need.
  /// This allows you to make it smaller, or larger, than the parent Sprite. You
  /// can also control the x and y offset of the Body.
  /// The width, height, and offset arguments are relative to the Sprite
  /// _texture_ and are scaled with the Sprite's [Phaser.Sprite#scale]
  /// (but **not** the scale of any ancestors or the [Phaser.Camera#scale
  /// Camera scale]).
  /// For example: If you have a Sprite with a texture that is 80x100 in size,
  /// and you want the physics body to be 32x32 pixels in the middle of the
  /// texture, you would do:
  /// `setSize(32 / Math.abs(this.scale.x), 32 / Math.abs(this.scale.y), 24,
  /// 34)`
  /// Where the first two parameters are the new Body size (32x32 pixels)
  /// relative to the Sprite's scale. 24 is the horizontal offset of the Body
  /// from the top-left of the Sprites texture, and 34 is the vertical offset.
  /// If you've scaled a Sprite by altering its `width`, `height`, or `scale`
  /// and you want to position the Body relative to the Sprite's dimensions
  /// (which will differ from its texture's dimensions), you should divide these
  /// arguments by the Sprite's current scale:
  /// `setSize(32 / sprite.scale.x, 32 / sprite.scale.y)`
  /// Calling `setSize` on a Body that has already had `setCircle` will reset
  /// all of the Circle properties, making this Body rectangular again.
  /// texture.
  /// texture.
  /// Sprite's texture.
  /// Sprite's texture.
  external void setSize(num width, num height, [num offsetX, num offsetY]);

  /// Internal method.
  external bool updateBounds();
}

@JS("Phaser.Physics.Arcade.FaceChoices")
class FaceChoices {
  // @Ignore
  FaceChoices.fakeConstructor$();
  external bool get none;
  external set none(bool v);
  external bool get up;
  external set up(bool v);
  external bool get down;
  external set down(bool v);
  external bool get left;
  external set left(bool v);
  external bool get right;
  external set right(bool v);
}

// End module Arcade
/// Ninja Physics. The Ninja Physics system was created in Flash by Metanet Software and ported to JavaScript by Richard Davey.
/// It allows for AABB and Circle to Tile collision. Tiles can be any of 34 different types, including slopes, convex and concave shapes.
/// It does what it does very well, but is ripe for expansion and optimisation. Here are some features that I'd love to see the community add:
/// * AABB to AABB collision
/// * AABB to Circle collision
/// * AABB and Circle 'immovable' property support
/// * n-way collision, so an AABB/Circle could pass through a tile from below and land upon it.
/// * QuadTree or spatial grid for faster Body vs. Tile Group look-ups.
/// * Optimise the internal vector math and reduce the quantity of temporary vars created.
/// * Expand Gravity and Bounce to allow for separate x/y axis values.
/// * Support Bodies linked to Sprites that don't have anchor set to 0.5
/// Feel free to attempt any of the above and submit a Pull Request with your code! Be sure to include test cases proving they work.
@JS("Phaser.Physics.Ninja")
class Ninja {
  // @Ignore
  Ninja.fakeConstructor$();

  /// Ninja Physics. The Ninja Physics system was created in Flash by Metanet Software and ported to JavaScript by Richard Davey.
  /// It allows for AABB and Circle to Tile collision. Tiles can be any of 34 different types, including slopes, convex and concave shapes.
  /// It does what it does very well, but is ripe for expansion and optimisation. Here are some features that I'd love to see the community add:
  /// * AABB to AABB collision
  /// * AABB to Circle collision
  /// * AABB and Circle 'immovable' property support
  /// * n-way collision, so an AABB/Circle could pass through a tile from below and land upon it.
  /// * QuadTree or spatial grid for faster Body vs. Tile Group look-ups.
  /// * Optimise the internal vector math and reduce the quantity of temporary vars created.
  /// * Expand Gravity and Bounce to allow for separate x/y axis values.
  /// * Support Bodies linked to Sprites that don't have anchor set to 0.5
  /// Feel free to attempt any of the above and submit a Pull Request with your code! Be sure to include test cases proving they work.
  external factory Ninja(Game game);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// The World gravity setting.
  external num get gravity;
  external set gravity(num v);

  /// The bounds inside of which the physics world exists. Defaults to match the world bounds.
  external Rectangle get bounds;
  external set bounds(Rectangle v);

  /// Used by the QuadTree to set the maximum number of objects per quad.
  external num get maxObjects;
  external set maxObjects(num v);

  /// Used by the QuadTree to set the maximum number of iteration levels.
  external num get maxLevels;
  external set maxLevels(num v);

  /// The world QuadTree.
  external QuadTree get quadTree;
  external set quadTree(QuadTree v);

  /// Local reference to game.time.
  external Time get time;
  external set time(Time v);

  /// Clears all physics bodies from the given TilemapLayer that were created with `World.convertTilemap`.
  external void clearTilemapLayerBodies(Tilemap map, dynamic layer);

  /// Checks for collision between two game objects. You can perform Sprite vs. Sprite, Sprite vs. Group, Group vs. Group, Sprite vs. Tilemap Layer or Group vs. Tilemap Layer collisions.
  /// The second parameter can be an array of objects, of differing types.
  /// The objects are also automatically separated. If you don't require separation then use ArcadePhysics.overlap instead.
  /// An optional processCallback can be provided. If given this function will be called when two sprites are found to be colliding. It is called before any separation takes place,
  /// giving you the chance to perform additional checks. If the function returns true then the collision and separation is carried out. If it returns false it is skipped.
  /// The collideCallback is an optional function that is only called if two sprites collide. If a processCallback has been set then it needs to return true for collideCallback to be called.
  external bool collide(dynamic object1, dynamic object2,
      [Function collideCallback,
      Function processCallback,
      dynamic callbackContext]);

  /// Goes through all tiles in the given Tilemap and TilemapLayer and converts those set to collide into physics tiles.
  /// Only call this *after* you have specified all of the tiles you wish to collide with calls like Tilemap.setCollisionBetween, etc.
  /// Every time you call this method it will destroy any previously created bodies and remove them from the world.
  /// Therefore understand it's a very expensive operation and not to be done in a core game update loop.
  /// In Ninja the Tiles have an ID from 0 to 33, where 0 is 'empty', 1 is a full tile, 2 is a 45-degree slope, etc. You can find the ID
  /// list either at the very bottom of `Tile.js`, or in a handy visual reference in the `resources/Ninja Physics Debug Tiles` folder in the repository.
  /// The slopeMap parameter is an array that controls how the indexes of the tiles in your tilemap data will map to the Ninja Tile IDs.
  /// For example if you had 6 tiles in your tileset: Imagine the first 4 should be converted into fully solid Tiles and the other 2 are 45-degree slopes.
  /// Your slopeMap array would look like this: `[ 1, 1, 1, 1, 2, 3 ]`.
  /// Where each element of the array is a tile in your tilemap and the resulting Ninja Tile it should create.
  external List<Ninja_Tile> convertTilemap(
      Tilemap map, dynamic layer, dynamic slopeMap);

  /// This will create a Ninja Physics AABB body on the given game object. Its dimensions will match the width and height of the object at the point it is created.
  /// A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.
  external void enableAABB(dynamic object, [bool children]);

  /// This will create a Ninja Physics Circle body on the given game object.
  /// A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.
  external void enableCircle(dynamic object, num radius, [bool children]);

  /// This will create a Ninja Physics Tile body on the given game object. There are 34 different types of tile you can create, including 45 degree slopes,
  /// convex and concave circles and more. The id parameter controls which Tile type is created, but you can also change it at run-time.
  /// Note that for all degree based tile types they need to have an equal width and height. If the given object doesn't have equal width and height it will use the width.
  /// A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.
  external void enableTile(dynamic object, num id, [bool children]);

  /// This will create a Ninja Physics body on the given game object or array of game objects.
  /// A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.
  external void enable(dynamic object,
      [num type, num id, num radius, bool children]);

  /// Creates a Ninja Physics body on the given game object.
  /// A game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.
  external void enableBody(dynamic object, [num type, num id, num radius]);

  /// Checks for overlaps between two game objects. The objects can be Sprites, Groups or Emitters.
  /// You can perform Sprite vs. Sprite, Sprite vs. Group and Group vs. Group overlap checks.
  /// Unlike collide the objects are NOT automatically separated or have any physics applied, they merely test for overlap results.
  /// The second parameter can be an array of objects, of differing types.
  external bool overlap(dynamic object1, dynamic object2,
      [Function overlapCallback,
      Function processCallback,
      dynamic callbackContext]);

  /// The core separation function to separate two physics bodies.
  external bool separate(Ninja_Body body1, Ninja_Body body2,
      [Function processCallback, dynamic callbackContext, bool overlapOnly]);

  /// Updates the size of this physics world.
  external void setBounds(num x, num y, num width, num height);

  /// Updates the size of this physics world to match the size of the game world.
  external void setBoundsToWorld();
}

// Module Ninja
/// The Physics Body is linked to a single Sprite. All physics operations should be performed against the body rather than
/// the Sprite itself. For example you can set the velocity, bounce values etc all on the Body.
@JS("Phaser.Physics.Ninja.Body")
class Ninja_Body {
  // @Ignore
  Ninja_Body.fakeConstructor$();

  /// The Physics Body is linked to a single Sprite. All physics operations should be performed against the body rather than
  /// the Sprite itself. For example you can set the velocity, bounce values etc all on the Body.
  external factory Ninja_Body(Ninja system, Sprite sprite,
      [num type, num id, num radius, num x, num y, num width, num height]);

  /// The AABB object this body is using for collision.
  external AABB get aabb;
  external set aabb(AABB v);

  /// The angle of this Body
  external num get angle;
  external set angle(num v);

  /// The bottom value of this Body (same as Body.y + Body.height)
  external num get bottom;
  external set bottom(num v);

  /// The bounciness of this object when it collides. A value between 0 and 1. We recommend setting it to 0.999 to avoid jittering.
  /// Default: 0.3
  external num get bounce;
  external set bounce(num v);

  /// Set the checkCollision properties to control which directions collision is processed for this Body.
  /// For example checkCollision.up = false means it won't collide when the collision happened while moving up. An object containing allowed collision.
  external FaceChoices get checkCollision;
  external set checkCollision(FaceChoices v);

  /// The Circle object this body is using for collision.
  external Ninja_Circle get circle;
  external set circle(Ninja_Circle v);

  /// A Body can be set to collide against the World bounds automatically and rebound back into the World if this is set to true. Otherwise it will leave the World. Should the Body collide with the World bounds?
  external bool get collideWorldBounds;
  external set collideWorldBounds(bool v);

  /// The drag applied to this object as it moves.
  /// Default: 1
  external num get drag;
  external set drag(num v);

  /// A const reference to the direction the Body is traveling or facing.
  external num get facing;
  external set facing(num v);

  /// The friction applied to this object as it moves.
  /// Default: 0.05
  external num get friction;
  external set friction(num v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// How much of the world gravity should be applied to this object? 1 = all of it, 0.5 = 50%, etc.
  /// Default: 1
  external num get gravityScale;
  external set gravityScale(num v);

  /// The height of this Body
  external num get height;
  external set height(num v);

  /// An immovable Body will not receive any impacts from other bodies. Not fully implemented.
  external bool get immovable;
  external set immovable(bool v);

  /// The maximum speed this body can travel at (taking drag and friction into account)
  /// Default: 8
  external num get maxSpeed;
  external set maxSpeed(num v);

  /// The right value of this Body (same as Body.x + Body.width)
  external num get right;
  external set right(num v);

  /// Reference to the parent Sprite.
  external Sprite get sprite;
  external set sprite(Sprite v);

  /// The parent physics system.
  external Ninja get system;
  external set system(Ninja v);

  /// The Tile object this body is using for collision.
  external Ninja_Tile get tile;
  external set tile(Ninja_Tile v);

  /// This object is populated with boolean values when the Body collides with another.
  /// touching.up = true means the collision happened to the top of this Body for example. An object containing touching results.
  external FaceChoices get touching;
  external set touching(FaceChoices v);

  /// The type of physics system this body belongs to.
  external num get type;
  external set type(num v);

  /// A local reference to the body shape.
  external dynamic get shape;
  external set shape(dynamic v);

  /// The speed of this Body
  external num get speed;
  external set speed(num v);

  /// The velocity in pixels per second sq. of the Body.
  external PhaserPoint get velocity;
  external set velocity(Point v);

  /// This object is populated with previous touching values from the bodies previous collision. An object containing previous touching results.
  external FaceChoices get wasTouching;
  external set wasTouching(FaceChoices v);

  /// The width of this Body
  external num get width;
  external set width(num v);

  /// The x position.
  external num get x;
  external set x(num v);

  /// The y position.
  external num get y;
  external set y(num v);

  /// Returns the absolute delta x value.
  external num deltaAbsX();

  /// Returns the absolute delta y value.
  external num deltaAbsY();

  /// Returns the delta x value. The difference between Body.x now and in the previous step.
  external num deltaX();

  /// Returns the delta y value. The difference between Body.y now and in the previous step.
  external num deltaY();

  /// Destroys this body's reference to the sprite and system, and destroys its shape.
  external void destroy();

  /// Stops all movement of this body.
  external void setZeroVelocity();
  external void moveTo(num speed, num angle);
  external void moveFrom(num speed, num angle);
  external void moveLeft(num speed);
  external void moveRight(num speed);
  external void moveUp(num speed);
  external void moveDown(num speed);
  external void poseUpdate();

  /// Internal method.
  external void preUpdate();

  /// Render Sprite's Body.
  external void render(dynamic context, Ninja_Body body,
      [String color, bool filled]);

  /// Resets all Body values and repositions on the Sprite.
  external void reset();
}

/// Ninja Physics AABB constructor.
/// Note: This class could be massively optimised and reduced in size. I leave that challenge up to you.
@JS("Phaser.Physics.Ninja.AABB")
class AABB {
  // @Ignore
  AABB.fakeConstructor$();

  /// Ninja Physics AABB constructor.
  /// Note: This class could be massively optimised and reduced in size. I leave that challenge up to you.
  external factory AABB(Ninja_Body body, num x, num y, num width, num height);
  external static num get COL_NONE;
  external static set COL_NONE(num v);
  external static num get COL_AXIS;
  external static set COL_AXIS(num v);
  external static num get COL_OTHER;
  external static set COL_OTHER(num v);

  /// All of the collision response handlers.
  external dynamic get aabbTileProjections;
  external set aabbTileProjections(dynamic v);

  /// A reference to the body that owns this shape.
  external Ninja_Body get body;
  external set body(Ninja_Body v);

  /// The height.
  external num get height;
  external set height(num v);
  external PhaserPoint get oldPos;
  external set oldPos(Point v);

  /// The position of this object.
  external PhaserPoint get pos;
  external set pos(Point v);

  /// A reference to the physics system.
  external Ninja get system;
  external set system(Ninja v);

  /// The width.
  external num get width;
  external set width(num v);

  /// The velocity of this object.
  external PhaserPoint get velocity;
  external set velocity(Point v);

  /// Half the width.
  external num get xw;
  external set xw(num v);

  /// Half the height.
  external num get yw;
  external set yw(num v);

  /// Collides this AABB against the world bounds.
  external void collideWorldBounds();

  /// Collides this AABB against a AABB.
  external bool collideAABBVsAABB(AABB aabb);

  /// Collides this AABB against a Tile.
  external bool collideAABBVsTile(Ninja_Tile tile);

  /// Destroys this AABB's reference to Body and System
  external void destroy();

  /// Updates this AABBs position.
  external void integrate();

  /// Render this AABB for debugging purposes.
  external void render(
      dynamic context, num xOffset, num yOffset, String color, bool filled);

  /// Process a collision partner-agnostic collision response and apply the resulting forces.
  external void reportCollision(num px, num py, num dx, num dy);

  /// Process a world collision and apply the resulting forces.
  external void reportCollisionVsWorld(
      num px, num py, num dx, num dy, dynamic obj);

  /// Process a body collision and apply the resulting forces. Still very much WIP and doesn't work fully. Feel free to fix!
  external void reportCollisionVsBody(
      num px, num py, num dx, num dy, dynamic obj);

  /// Resolves tile collision.
  external bool resolveTile(num x, num y, AABB body, Ninja_Tile tile);
  external void reverse();
}

/// Ninja Physics Circle constructor.
/// Note: This class could be massively optimised and reduced in size. I leave that challenge up to you.
@JS("Phaser.Physics.Ninja.Circle")
class Ninja_Circle {
  // @Ignore
  Ninja_Circle.fakeConstructor$();

  /// Ninja Physics Circle constructor.
  /// Note: This class could be massively optimised and reduced in size. I leave that challenge up to you.
  external factory Ninja_Circle(Ninja_Body body, num x, num y, num radius);
  external num get COL_NONE;
  external set COL_NONE(num v);
  external num get COL_AXIS;
  external set COL_AXIS(num v);
  external num get COL_OTHER;
  external set COL_OTHER(num v);

  /// A reference to the body that owns this shape.
  external Ninja_Body get body;
  external set body(Ninja_Body v);

  /// All of the collision response handlers.
  external dynamic /*JSMap of <num,(x: number, y: number, oH: number, oV: number, obj: Phaser.Physics.Ninja.Circle, t: Phaser.Physics.Ninja.Tile) => number>*/ get circleTileProjections;
  external set circleTileProjections(
      dynamic /*JSMap of <num,(x: number, y: number, oH: number, oV: number, obj: Phaser.Physics.Ninja.Circle, t: Phaser.Physics.Ninja.Tile) => number>*/ v);
  external PhaserPoint get oldPos;
  external set oldPos(Point v);

  /// The height.
  external num get height;
  external set height(num v);

  /// The position of this object.
  external PhaserPoint get pos;
  external set pos(Point v);

  /// The radius of this circle shape.
  external num get radius;
  external set radius(num v);

  /// A reference to the physics system.
  external Ninja get system;
  external set system(Ninja v);
  external num get type;
  external set type(num v);

  /// The velocity of this object.
  external PhaserPoint get velocity;
  external set velocity(Point v);

  /// The width.
  external num get width;
  external set width(num v);

  /// Half the width.
  external num get xw;
  external set xw(num v);

  /// Half the height.
  external num get yw;
  external set yw(num v);

  /// Collides this Circle with a Tile.
  external bool collideCircleVsTile(Ninja_Tile tile);

  /// Collides this Circle against the world bounds.
  external void collideWorldBounds();

  /// Destroys this Circle's reference to Body and System
  external void destroy();
  external num distance(num dest, [bool round]);

  /// Updates this Circles position.
  external void integrate();

  /// Render this circle for debugging purposes.
  external void render(
      dynamic context, num xOffset, num yOffset, String color, bool filled);

  /// Process a world collision and apply the resulting forces.
  external void reportCollisionVsWorld(
      num px, num py, num dx, num dy, dynamic obj);
  external void reportCollisionVsBody(
      num px, num py, num dx, num dy, dynamic obj);

  /// Resolves tile collision.
  external bool resolveCircleTile(
      num x, num y, num oH, num oV, Ninja_Circle obj, Ninja_Tile t);
}

@JS("Phaser.Physics.Ninja.TileType")
class TileType {
  external static num get TYPE_EMPTY;
  external static num get TYPE_FULL;
  external static num get TYPE_45DEG;
  external static num get TYPE_CONCAVE;
  external static num get TYPE_CONVEX;
  external static num get TYPE_22DEGs;
  external static num get TYPE_22DEGb;
  external static num get TYPE_67DEGs;
  external static num get TYPE_67DEGb;
  external static num get TYPE_HALF;
}

/// Ninja Physics Tile constructor.
/// A Tile is defined by its width, height and type. It's type can include slope data, such as 45 degree slopes, or convex slopes.
/// Understand that for any type including a slope (types 2 to 29) the Tile must be SQUARE, i.e. have an equal width and height.
/// Also note that as Tiles are primarily used for levels they have gravity disabled and world bounds collision disabled by default.
/// Note: This class could be massively optimised and reduced in size. I leave that challenge up to you.
@JS("Phaser.Physics.Ninja.Tile")
class Ninja_Tile {
  // @Ignore
  Ninja_Tile.fakeConstructor$();

  /// Ninja Physics Tile constructor.
  /// A Tile is defined by its width, height and type. It's type can include slope data, such as 45 degree slopes, or convex slopes.
  /// Understand that for any type including a slope (types 2 to 29) the Tile must be SQUARE, i.e. have an equal width and height.
  /// Also note that as Tiles are primarily used for levels they have gravity disabled and world bounds collision disabled by default.
  /// Note: This class could be massively optimised and reduced in size. I leave that challenge up to you.
  external factory Ninja_Tile(
      Ninja_Body body, num x, num y, num width, num height,
      [num type]);

  /// A reference to the body that owns this shape.
  external Ninja_Body get body;
  external set body(Ninja_Body v);

  /// The bottom value of this Body (same as Body.y + Body.height)
  external num get bottom;
  external set bottom(num v);
  external bool get flipped;
  external set flipped(bool v);

  /// The height.
  external num get height;
  external set height(num v);

  /// The ID of this Tile.
  external num get id;
  external set id(num v);

  /// The position of this object in the previous update.
  external PhaserPoint get oldpos;
  external set oldpos(Point v);

  /// The position of this object.
  external PhaserPoint get pos;
  external set pos(Point v);

  /// The right value of this Body (same as Body.x + Body.width)
  external num get right;
  external set right(num v);
  external num get rotation;
  external set rotation(num v);

  /// A reference to the physics system.
  external Ninja get system;
  external set system(Ninja v);

  /// The type of this Tile.
  external num /*enum Phaser.Physics.Ninja.TileType*/ get type;
  external set type(num /*enum Phaser.Physics.Ninja.TileType*/ v);

  /// The velocity of this object.
  external PhaserPoint get velocity;
  external set velocity(Point v);

  /// The width.
  external num get width;
  external set width(num v);

  /// Half the width.
  external num get xw;
  external set xw(num v);

  /// Half the height.
  external num get yw;
  external set yw(num v);

  /// The x position.
  external num get x;
  external set x(num v);

  /// The y position.
  external num get y;
  external set y(num v);

  /// Sets this tile to be empty.
  external void clear();

  /// Tiles cannot collide with the world bounds, it's up to you to keep them where you want them. But we need this API stub to satisfy the Body.
  external void collideWorldBounds();

  /// Destroys this Tiles reference to Body and System.
  external void destroy();

  /// Updates this objects position.
  external void integrate();

  /// Process a world collision and apply the resulting forces.
  external void reportCollisionVsWorld(
      num px, num py, num dx, num dy, dynamic obj);

  /// Tiles cannot collide with the world bounds, it's up to you to keep them where you want them. But we need this API stub to satisfy the Body.
  external num setType(num id);
}

// End module Ninja
/// This is your main access to the P2 Physics World.
/// From here you can create materials, listen for events and add bodies into the physics simulation.
@JS("Phaser.Physics.P2")
class P2 {
  // @Ignore
  P2.fakeConstructor$();

  /// This is your main access to the P2 Physics World.
  /// From here you can create materials, listen for events and add bodies into the physics simulation.
  external factory P2(Game game, [dynamic config]);

  /// Enable to automatically apply body damping each step.
  external bool get applyDamping;
  external set applyDamping(bool v);

  /// Enable to automatically apply gravity each step.
  external bool get applyGravity;
  external set applyGravity(bool v);

  /// Enable to automatically apply spring forces each step.
  external bool get applySpringForces;
  external set applySpringForces(bool v);

  /// An array of the bodies the world bounds collides with.
  external List<P2_Body> get boundsCollidesWith;
  external set boundsCollidesWith(List<P2_Body> v);

  /// A default collision group.
  external CollisionGroup get boundsCollisionGroup;
  external set boundsCollisionGroup(CollisionGroup v);

  /// The p2 World configuration object.
  external dynamic get config;
  external set config(dynamic v);

  /// The context under which the callbacks are fired.
  external dynamic get callbackContext;
  external set callbackContext(dynamic v);

  /// An array containing the collision groups that have been defined in the World.
  external List<CollisionGroup> get collisionGroups;
  external set collisionGroups(List<CollisionGroup> v);

  /// The default Contact Material being used by the World.
  external ContactMaterial get contactMaterial;
  external set contactMaterial(ContactMaterial v);

  /// Set to true if you want to the world to emit the "impact" event. Turning this off could improve performance.
  external bool get emitImpactEvent;
  external set emitImpactEvent(bool v);

  /// A default collision group.
  external CollisionGroup get everythingCollisionGroup;
  external set everythingCollisionGroup(CollisionGroup v);

  /// The frame rate the world will be stepped at. Defaults to 1 / 60, but you can change here. Also see useElapsedTime property.
  external num get frameRate;
  external set frameRate(num v);

  /// Friction between colliding bodies. This value is used if no matching ContactMaterial is found for a Material pair.
  external num get friction;
  external set friction(num v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// The gravity applied to all bodies each step.
  external InversePointProxy get gravity;
  external set gravity(InversePointProxy v);

  /// A local array of all created Materials.
  external List<Material> get materials;
  external set materials(List<Material> v);

  /// A default collision group.
  external CollisionGroup get nothingCollisionGroup;
  external set nothingCollisionGroup(CollisionGroup v);

  /// This signal is dispatched when a new Body is added to the World.
  /// It sends 1 argument: `body` which is the `Phaser.Physics.P2.Body` that was added to the world.
  external Signal get onBodyAdded;
  external set onBodyAdded(Signal v);

  /// This signal is dispatched when a Body is removed to the World.
  /// It sends 1 argument: `body` which is the `Phaser.Physics.P2.Body` that was removed from the world.
  external Signal get onBodyRemoved;
  external set onBodyRemoved(Signal v);

  /// This Signal is dispatched when a first contact is created between two bodies. This happens *before* the step has been done.
  /// It sends 5 arguments: `bodyA`, `bodyB`, `shapeA`, `shapeB` and `contactEquations`.
  /// It is possible that in certain situations the `bodyA` or `bodyB` values are `null`. You should check for this
  /// in your own code to avoid processing potentially null physics bodies.
  external Signal get onBeginContact;
  external set onBeginContact(Signal v);

  /// This signal is dispatched when a Constraint is added to the World.
  /// It sends 1 argument: `constraint` which is the `Phaser.Physics.P2.Constraint` that was added to the world.
  external Signal get onConstraintAdded;
  external set onConstraintAdded(Signal v);

  /// This signal is dispatched when a Constraint is removed from the World.
  /// It sends 1 argument: `constraint` which is the `Phaser.Physics.P2.Constraint` that was removed from the world.
  external Signal get onConstraintRemoved;
  external set onConstraintRemoved(Signal v);

  /// This signal is dispatched when a Contact Material is added to the World.
  /// It sends 1 argument: `material` which is the `Phaser.Physics.P2.ContactMaterial` that was added to the world.
  external Signal get onContactMaterialAdded;
  external set onContactMaterialAdded(Signal v);

  /// This signal is dispatched when a Contact Material is removed from the World.
  /// It sends 1 argument: `material` which is the `Phaser.Physics.P2.ContactMaterial` that was removed from the world.
  external Signal get onContactMaterialRemoved;
  external set onContactMaterialRemoved(Signal v);

  /// This Signal is dispatched when final contact occurs between two bodies. This happens *before* the step has been done.
  /// It sends 4 arguments: `bodyA`, `bodyB`, `shapeA` and `shapeB`.
  /// It is possible that in certain situations the `bodyA` or `bodyB` values are `null`. You should check for this
  /// in your own code to avoid processing potentially null physics bodies.
  external Signal get onEndContact;
  external set onEndContact(Signal v);

  /// This signal is dispatched when a Spring is added to the World.
  /// It sends 1 argument: `spring` which is either a `Phaser.Physics.P2.Spring`, `p2.LinearSpring` or `p2.RotationalSpring` that was added to the world.
  external Signal get onSpringAdded;
  external set onSpringAdded(Signal v);

  /// This signal is dispatched when a Spring is removed from the World.
  /// It sends 1 argument: `spring` which is either a `Phaser.Physics.P2.Spring`, `p2.LinearSpring` or `p2.RotationalSpring` that was removed from the world.
  external Signal get onSpringRemoved;
  external set onSpringRemoved(Signal v);

  /// The paused state of the P2 World.
  external bool get paused;
  external set paused(bool v);
  external Function get postBroaddphaseCallback;
  external set postBroaddphaseCallback(Function v);

  /// Default coefficient of restitution between colliding bodies. This value is used if no matching ContactMaterial is found for a Material pair.
  external num get restitution;
  external set restitution(num v);

  /// Enable/disable constraint solving in each step.
  external bool get solveConstraints;
  external set solveConstraints(bool v);

  /// The World time.
  external dynamic get time;
  external set time(dynamic v);

  /// The total number of bodies in the world.
  external num get total;
  external set total(num v);

  /// If true the frameRate value will be ignored and instead p2 will step with the value of Game.Time.physicsElapsed, which is a delta time value.
  external bool get useElapsedTime;
  external set useElapsedTime(bool v);

  /// An object containing the 4 wall bodies that bound the physics world.
  external dynamic
      /*{
                left?: Phaser.Physics.P2.Body;
                right?: Phaser.Physics.P2.Body;
                top?: Phaser.Physics.P2.Body;
                bottom?: Phaser.Physics.P2.Body;
            }*/
      get walls;
  external set walls(
      dynamic /*{
                left?: Phaser.Physics.P2.Body;
                right?: Phaser.Physics.P2.Body;
                top?: Phaser.Physics.P2.Body;
                bottom?: Phaser.Physics.P2.Body;
            }*/
      v);

  /// The p2 World in which the simulation is run.
  external World get world;
  external set world(World v);

  /// Add a body to the world.
  external bool addBody(P2_Body body);

  /// Adds a Contact Material to the world.
  external ContactMaterial addContactMaterial(ContactMaterial material);

  /// Adds a Constraint to the world.
  external dynamic/*=T*/ addConstraint/*<T>*/(dynamic/*=T*/ constraint);

  /// Adds a Spring to the world.
  external Spring addSpring(Spring spring);

  /// Handles a p2 begin contact event.
  external void beginContactHandler(dynamic event);

  /// Clears all bodies from the simulation, resets callbacks and resets the collision bitmask.
  /// The P2 world is also cleared:
  /// * Removes all solver equations
  /// * Removes all constraints
  /// * Removes all bodies
  /// * Removes all springs
  /// * Removes all contact materials
  /// This is called automatically when you switch state.
  external void clear();

  /// Clears all physics bodies from the given TilemapLayer that were created with `World.convertTilemap`.
  external void clearTilemapLayerBodies(Tilemap map, [dynamic layer]);

  /// Converts all of the polyline, polygon, and rectangle objects inside a Tiled ObjectGroup into physics bodies that are added to the world.
  /// Note that the polylines and polygons must be created in such a way that they can withstand polygon decomposition.
  external List<P2_Body> convertCollisionObjects(Tilemap map,
      [dynamic layer, bool addToWorld]);

  /// Goes through all tiles in the given Tilemap and TilemapLayer and converts those set to collide into physics bodies.
  /// Only call this *after* you have specified all of the tiles you wish to collide with calls like Tilemap.setCollisionBetween, etc.
  /// Every time you call this method it will destroy any previously created bodies and remove them from the world.
  /// Therefore understand it's a very expensive operation and not to be done in a core game update loop.
  external List<P2_Body> convertTilemap(Tilemap map,
      [dynamic layer, bool addToWorld, bool optimize]);

  /// Creates a new Body and adds it to the World.
  /// Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...],
  /// or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.
  /*external P2_Body createBody(num x, num y, num mass,
    [bool addToWorld, BodyOptions options, List<List<num>> data]);*/
  /// Creates a new Body and adds it to the World.
  /// Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...],
  /// or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.
  /*external P2_Body createBody(num x, num y, num mass,
    [bool addToWorld, BodyOptions options, List<num> data]);*/
  external P2_Body createBody(num x, num y, num mass,
      [bool addToWorld,
      BodyOptions options,
      List<dynamic> /*List<List<num>>|List<num>*/ data]);

  /// Creates a new Collision Group and optionally applies it to the given object.
  /// Collision Groups are handled using bitmasks, therefore you have a fixed limit you can create before you need to re-use older groups.
  /*external CollisionGroup createCollisionGroup([Group group]);*/
  /// Creates a new Collision Group and optionally applies it to the given object.
  /// Collision Groups are handled using bitmasks, therefore you have a fixed limit you can create before you need to re-use older groups.
  /*external CollisionGroup createCollisionGroup([Sprite group]);*/
  external CollisionGroup createCollisionGroup(
      [dynamic /*Group|Sprite*/ group]);

  /// Creates a Contact Material from the two given Materials. You can then edit the properties of the Contact Material directly.
  external ContactMaterial createContactMaterial(
      Material materialA, Material materialB,
      [ContactMaterialOptions options]);

  /// Creates a constraint that tries to keep the distance between two bodies constant.
  external DistanceConstraint createDistanceConstraint(
      dynamic bodyA, dynamic bodyB, num distance,
      [List<num> localAnchorA, List<num> localAnchorB, num maxForce]);

  /// Creates a constraint that tries to keep the distance between two bodies constant.
  external GearConstraint createGearConstraint(dynamic bodyA, dynamic bodyB,
      [num angle, num ratio]);

  /// Locks the relative position between two bodies.
  external LockConstraint createLockConstraint(dynamic bodyA, dynamic bodyB,
      [List<num> offset, num angle, num maxForce]);

  /// Creates a Material. Materials are applied to Shapes owned by a Body and can be set with Body.setMaterial().
  /// Materials are a way to control what happens when Shapes collide. Combine unique Materials together to create Contact Materials.
  /// Contact Materials have properties such as friction and restitution that allow for fine-grained collision control between different Materials.
  external Material createMaterial([String name, P2_Body body]);

  /// Creates a new Particle and adds it to the World.
  /// Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...],
  /// or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.
  /*external P2_Body createParticle(num x, num y, num mass,
    [bool addToWorld, BodyOptions options, List<List<num>> data]);*/
  /// Creates a new Particle and adds it to the World.
  /// Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...],
  /// or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.
  /*external P2_Body createParticle(num x, num y, num mass,
    [bool addToWorld, BodyOptions options, List<num> data]);*/
  external P2_Body createParticle(num x, num y, num mass,
      [bool addToWorld,
      BodyOptions options,
      List<dynamic> /*List<List<num>>|List<num>*/ data]);

  /// Constraint that only allows bodies to move along a line, relative to each other.
  /// See http://www.iforce2d.net/b2dtut/joints-prismatic
  external PrismaticConstraint createPrismaticConstraint(
      dynamic body, dynamic bodyB,
      [bool lockRotation,
      List<num> anchorA,
      List<num> anchorB,
      Float32List axis,
      num maxForce]);

  /// Connects two bodies at given offset points, letting them rotate relative to each other around this point.
  /// The pivot points are given in world (pixel) coordinates.
  external RevoluteConstraint createRevoluteConstraint(
      dynamic bodyA, List<num> pivotA, dynamic bodyB, List<num> pivotB,
      [num maxForce, List<num> worldPivot]);

  /// Creates a rotational spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.
  external RotationalSpring createRotationalSpring(dynamic bodyA, dynamic bodyB,
      [num restAngle, num stiffness, num damping]);

  /// Creates a linear spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.
  external Spring createSpring(dynamic bodyA, dynamic bodyB,
      [num restLength,
      num stiffness,
      num damping,
      List<num> worldA,
      List<num> worldB,
      List<num> localA,
      List<num> localB]);

  /// Clears all bodies from the simulation and unlinks World from Game. Should only be called on game shutdown. Call `clear` on a State change.
  external void destroy();

  /// This will create a P2 Physics body on the given game object or array of game objects.
  /// A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.
  /// Note: When the game object is enabled for P2 physics it has its anchor x/y set to 0.5 so it becomes centered.
  external void enable(dynamic object, [bool debug, bool children]);

  /// Creates a P2 Physics body on the given game object.
  /// A game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.
  external void enableBody(dynamic object, bool debug);

  /// Handles a p2 end contact event.
  external void endContactHandler(dynamic event);

  /// Populates and returns an array with references to of all current Bodies in the world.
  external List<P2_Body> getBodies();

  /// Checks the given object to see if it has a p2.Body and if so returns it.
  external P2_Body getBody(dynamic object);

  /// Populates and returns an array of all current Constraints in the world.
  /// You will get an array of p2 constraints back. This can be of mixed types, for example the array may contain
  /// PrismaticConstraints, RevoluteConstraints or any other valid p2 constraint type.
  external List<Constraint> getConstraints();

  /// Populates and returns an array of all current Springs in the world.
  external List<Spring> getSprings();

  /// Gets a Contact Material based on the two given Materials.
  external ContactMaterial getContactMaterial(
      Material materialA, Material materialB);

  /// Test if a world point overlaps bodies. You will get an array of actual P2 bodies back. You can find out which Sprite a Body belongs to
  /// (if any) by checking the Body.parent.sprite property. Body.parent is a Phaser.Physics.P2.Body property.
  external List<P2_Body> hitTest(Point worldPoint,
      [List<dynamic> bodies, num precision, bool filterStatic]);

  /// Convert p2 physics value (meters) to pixel scale.
  /// By default Phaser uses a scale of 20px per meter.
  /// If you need to modify this you can over-ride these functions via the Physics Configuration object.
  external num mpx(num v);

  /// Convert p2 physics value (meters) to pixel scale and inverses it.
  /// By default Phaser uses a scale of 20px per meter.
  /// If you need to modify this you can over-ride these functions via the Physics Configuration object.
  external num mpxi(num v);

  /// Pauses the P2 World independent of the game pause state.
  external void pause();

  /// Called at the start of the core update loop. Purges flagged bodies from the world.
  external void preUpdate();

  /// Convert pixel value to p2 physics scale (meters).
  /// By default Phaser uses a scale of 20px per meter.
  /// If you need to modify this you can over-ride these functions via the Physics Configuration object.
  external num pxm(num v);

  /// Convert pixel value to p2 physics scale (meters) and inverses it.
  /// By default Phaser uses a scale of 20px per meter.
  /// If you need to modify this you can over-ride these functions via the Physics Configuration object.
  external num pxmi(num v);

  /// Removes a body from the world. This will silently fail if the body wasn't part of the world to begin with.
  external P2_Body removeBody(P2_Body body);

  /// This will add a P2 Physics body into the removal list for the next step.
  external void removeBodyNextStep(P2_Body body);

  /// Removes a Constraint from the world.
  external dynamic/*=T*/ removeConstraint/*<T>*/(dynamic/*=T*/ constraint);

  /// Removes a Contact Material from the world.
  external ContactMaterial removeContactMaterial(ContactMaterial material);

  /// Removes a Spring from the world.
  external Spring removeSpring(Spring spring);

  /// Called by Phaser.Physics when a State swap occurs.
  /// Starts the begin and end Contact listeners again.
  external void reset();

  /// Resumes a paused P2 World.
  external void resume();

  /// Sets the bounds of the Physics world to match the given world pixel dimensions.
  /// You can optionally set which 'walls' to create: left, right, top or bottom.
  /// If none of the walls are given it will default to use the walls settings it had previously.
  /// I.e. if you previously told it to not have the left or right walls, and you then adjust the world size
  /// the newly created bounds will also not have the left and right walls.
  /// Explicitly state them in the parameters to override this.
  external void setBounds(num x, num y, num width, num height,
      [bool left, bool right, bool top, bool bottom, bool setCollisionGroup]);
  external void setBoundsToWorld(
      [bool left, bool right, bool top, bool bottom, bool setCollisionGroup]);
  external void setCollisionGroup(dynamic object, CollisionGroup group);

  /// Impact event handling is disabled by default. Enable it before any impact events will be dispatched.
  /// In a busy world hundreds of impact events can be generated every step, so only enable this if you cannot do what you need via beginContact or collision masks.
  external void setImpactEvents(bool state);

  /// Sets the given Material against all Shapes owned by all the Bodies in the given array.
  external void setMaterial(Material material, [List<P2_Body> bodies]);

  /// Sets a callback to be fired after the Broadphase has collected collision pairs in the world.
  /// Just because a pair exists it doesn't mean they *will* collide, just that they potentially could do.
  /// If your calback returns `false` the pair will be removed from the narrowphase. This will stop them testing for collision this step.
  /// Returning `true` from the callback will ensure they are checked in the narrowphase.
  external void setPostBroadphaseCallback(Function callback, dynamic context);
  external void setWorldMaterial(Material material,
      [bool left, bool right, bool top, bool bottom]);

  /// Converts the current world into a JSON object.
  external dynamic toJSON();

  /// Internal P2 update loop.
  external void update();

  /// By default the World will be set to collide everything with everything. The bounds of the world is a Body with 4 shapes, one for each face.
  /// If you start to use your own collision groups then your objects will no longer collide with the bounds.
  /// To fix this you need to adjust the bounds to use its own collision group first BEFORE changing your Sprites collision group.
  external void updateBoundsCollisionGroup([bool setCollisionGroup]);
}

// Module P2
/// The Physics Body is typically linked to a single Sprite and defines properties that determine how the physics body is simulated.
/// These properties affect how the body reacts to forces, what forces it generates on itself (to simulate friction), and how it reacts to collisions in the scene.
/// In most cases, the properties are used to simulate physical effects. Each body also has its own property values that determine exactly how it reacts to forces and collisions in the scene.
/// By default a single Rectangle shape is added to the Body that matches the dimensions of the parent Sprite. See addShape, removeShape, clearShapes to add extra shapes around the Body.
/// Note: When bound to a Sprite to avoid single-pixel jitters on mobile devices we strongly recommend using Sprite sizes that are even on both axis, i.e. 128x128 not 127x127.
/// Note: When a game object is given a P2 body it has its anchor x/y set to 0.5, so it becomes centered.
@JS("Phaser.Physics.P2.Body")
class P2_Body {
  // @Ignore
  P2_Body.fakeConstructor$();

  /// Dynamic body. Dynamic bodies body can move and respond to collisions and forces.
  external static num get DYNAMIC;
  external static set DYNAMIC(num v);

  /// Static body. Static bodies do not move, and they do not respond to forces or collision.
  external static num get STATIC;
  external static set STATIC(num v);

  /// Kinematic body. Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.
  external static num get KINEMATIC;
  external static set KINEMATIC(num v);

  /// The Physics Body is typically linked to a single Sprite and defines properties that determine how the physics body is simulated.
  /// These properties affect how the body reacts to forces, what forces it generates on itself (to simulate friction), and how it reacts to collisions in the scene.
  /// In most cases, the properties are used to simulate physical effects. Each body also has its own property values that determine exactly how it reacts to forces and collisions in the scene.
  /// By default a single Rectangle shape is added to the Body that matches the dimensions of the parent Sprite. See addShape, removeShape, clearShapes to add extra shapes around the Body.
  /// Note: When bound to a Sprite to avoid single-pixel jitters on mobile devices we strongly recommend using Sprite sizes that are even on both axis, i.e. 128x128 not 127x127.
  /// Note: When a game object is given a P2 body it has its anchor x/y set to 0.5, so it becomes centered.
  external factory P2_Body(Game game, [Sprite sprite, num x, num y, num mass]);

  /// -
  external bool get allowSleep;
  external set allowSleep(bool v);

  /// The angle of the Body in degrees from its original orientation. Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.
  /// Values outside this range are added to or subtracted from 360 to obtain a value within the range. For example, the statement Body.angle = 450 is the same as Body.angle = 90.
  /// If you wish to work in radians instead of degrees use the property Body.rotation instead. Working in radians is faster as it doesn't have to convert values. The angle of this Body in degrees.
  external num get angle;
  external set angle(num v);

  /// Damping is specified as a value between 0 and 1, which is the proportion of velocity lost per second. The angular damping acting acting on the body.
  external num get angularDamping;
  external set angularDamping(num v);

  /// The angular force acting on the body.
  external num get angularForce;
  external set angularForce(num v);

  /// The angular velocity of the body.
  external num get angularVelocity;
  external set angularVelocity(num v);

  /// Array of CollisionGroups that this Bodies shapes collide with.
  external List<CollisionGroup> get collidesWith;
  external set collidesWith(List<CollisionGroup> v);

  /// A Body can be set to collide against the World bounds automatically if this is set to true. Otherwise it will leave the World.
  /// Note that this only applies if your World has bounds! The response to the collision should be managed via CollisionMaterials.
  /// Also note that when you set this it will only affect Body shapes that already exist. If you then add further shapes to your Body
  /// after setting this it will *not* proactively set them to collide with the bounds. Should the Body collide with the World bounds?
  /// Default: true
  external bool get collideWorldBounds;
  external set collideWorldBounds(bool v);

  /// Damping is specified as a value between 0 and 1, which is the proportion of velocity lost per second. The linear damping acting on the body in the velocity direction.
  external num get damping;
  external set damping(num v);

  /// The p2 Body data.
  external Body get data;
  external set data(Body v);

  /// Enable or disable debug drawing of this body
  external bool get debug;
  external set debug(bool v);

  /// Reference to the debug body.
  external BodyDebug get debugBody;
  external set debugBody(BodyDebug v);

  /// Returns true if the Body is dynamic. Setting Body.dynamic to 'false' will make it static.
  external bool get JS$dynamic;
  external set JS$dynamic(bool v);

  /// -
  external bool get fixedRotation;
  external set fixedRotation(bool v);

  /// The force applied to the body.
  external InversePointProxy get force;
  external set force(InversePointProxy v);

  /// Returns true if the Body is kinematic. Setting Body.kinematic to 'false' will make it static.
  external bool get kinematic;
  external set kinematic(bool v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// A locally applied gravity force to the Body. Applied directly before the world step. NOTE: Not currently implemented.
  external PhaserPoint get gravity;
  external set gravity(Point v);

  /// The Body ID. Each Body that has been added to the World has a unique ID.
  external num get id;
  external set id(num v);

  /// The inertia of the body around the Z axis..
  external num get inertia;
  external set inertia(num v);

  /// The mass of the body.
  external num get mass;
  external set mass(num v);

  /// The type of motion this body has. Should be one of: Body.STATIC (the body does not move), Body.DYNAMIC (body can move and respond to collisions) and Body.KINEMATIC (only moves according to its .velocity).
  external num get motionState;
  external set motionState(num v);

  /// The offset of the Physics Body from the Sprite x/y position.
  external PhaserPoint get offset;
  external set offset(Point v);

  /// Dispatched when a first contact is created between shapes in two bodies.
  /// This event is fired during the step, so collision has already taken place.
  /// The event will be sent 5 arguments in this order:
  /// The Phaser.Physics.P2.Body it is in contact with. *This might be null* if the Body was created directly in the p2 world.
  /// The p2.Body this Body is in contact with.
  /// The Shape from this body that caused the contact.
  /// The Shape from the contact body.
  /// The Contact Equation data array.
  external Signal get onBeginContact;
  external set onBeginContact(Signal v);

  /// Dispatched when contact ends between shapes in two bodies.
  /// This event is fired during the step, so collision has already taken place.
  /// The event will be sent 4 arguments in this order:
  /// The Phaser.Physics.P2.Body it is in contact with. *This might be null* if the Body was created directly in the p2 world.
  /// The p2.Body this Body has ended contact with.
  /// The Shape from this body that caused the original contact.
  /// The Shape from the contact body.
  external Signal get onEndContact;
  external set onEndContact(Signal v);

  /// The angle of the Body in radians.
  /// If you wish to work in degrees instead of radians use the Body.angle property instead. Working in radians is faster as it doesn't have to convert values. The angle of this Body in radians.
  external num get rotation;
  external set rotation(num v);

  /// To avoid deleting this body during a physics step, and causing all kinds of problems, set removeNextStep to true to have it removed in the next preUpdate.
  external bool get removeNextStep;
  external set removeNextStep(bool v);

  /// Reference to the parent Sprite.
  external Sprite get sprite;
  external set sprite(Sprite v);

  /// .
  external num get sleepSpeedLimit;
  external set sleepSpeedLimit(num v);

  /// Returns true if the Body is static. Setting Body.static to 'false' will make it dynamic.
  external bool get JS$static;
  external set JS$static(bool v);

  /// The type of physics system this body belongs to.
  external num get type;
  external set type(num v);

  /// The velocity of the body. Set velocity.x to a negative value to move to the left, position to the right. velocity.y negative values move up, positive move down.
  external InversePointProxy get velocity;
  external set velocity(InversePointProxy v);

  /// Local reference to the P2 World.
  external P2 get world;
  external set world(P2 v);

  /// The x coordinate of this Body.
  external num get x;
  external set x(num v);

  /// The y coordinate of this Body.
  external num get y;
  external set y(num v);

  /// Adds this physics body to the world.
  external void addToWorld();

  /// Adds a Capsule shape to this Body.
  /// You can control the offset from the center of the body and the rotation.
  external Capsule addCapsule(num length, num radius,
      [num offsetX, num offsetY, num rotation]);

  /// Adds a Circle shape to this Body. You can control the offset from the center of the body and the rotation.
  external Circle addCircle(num radius,
      [num offsetX, num offsetY, num rotation]);

  /// Add a polygon fixture. This is used during #loadPolygon.
  external List<Shape> addFixture(String fixtureData);

  /// Adds a Line shape to this Body.
  /// The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].
  /// You can control the offset from the center of the body and the rotation.
  external Line addLine(num length, [num offsetX, num offsetY, num rotation]);

  /// Adds a Particle shape to this Body. You can control the offset from the center of the body and the rotation.
  external Particle addParticle([num offsetX, num offsetY, num rotation]);

  /// Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points. The shape must be simple and without holes.
  /// This function expects the x.y values to be given in pixels. If you want to provide them at p2 world scales then call Body.data.fromPolygon directly.
  /// Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...]. In the first form **the array will mutate**.
  /// Or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.
  external bool addPolygon(
      dynamic /*{ optimalDecomp?: boolean; skipSimpleCheck?: boolean; removeCollinearPoints?: boolean; }*/ options,
      List<List<num>> points);

  /// Reads the shape data from a physics data file stored in the Game.Cache and adds it as a polygon to this Body.
  /// The shape data format is based on the output of the
  /// [https://github.com/photonstorm/phaser/tree/master/resources/PhysicsEditor%20Exporter|custom phaser exporter] for
  /// [https://www.codeandweb.com/physicseditor|PhysicsEditor]
  external FixtureList addPhaserPolygon(String key, String object);

  /// Adds a Plane shape to this Body. The plane is facing in the Y direction. You can control the offset from the center of the body and the rotation.
  external Plane addPlane([num offsetX, num offsetY, num rotation]);

  /// Adds a Rectangle shape to this Body. You can control the offset from the center of the body and the rotation.
  external Rectangle addRectangle(num width, num height,
      [num offsetX, num offsetY, num rotation]);

  /// Add a shape to the body. You can pass a local transform when adding a shape, so that the shape gets an offset and an angle relative to the body center of mass.
  /// Will automatically update the mass properties and bounding radius.
  /// If this Body had a previously set Collision Group you will need to re-apply it to the new Shape this creates.
  external Shape addShape(Shape shape,
      [num offsetX, num offsetY, num rotation]);

  /// Moves the shape offsets so their center of mass becomes the body center of mass.
  external void adjustCenterOfMass();

  /// Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details.
  external void applyDamping(num dt);

  /// Apply force to a world point.
  /// This could for example be a point on the RigidBody surface. Applying force
  /// this way will add to Body.force and Body.angularForce.
  external void applyForce(List<num> force, num worldX, num worldY);

  /// Apply impulse to a point relative to the body.
  /// This could for example be a point on the Body surface. An impulse is a force added to a body during a short
  /// period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
  external void applyImpulse(List<num> impulse, num worldX, num worldY);

  /// Apply impulse to a point local to the body.
  /// This could for example be a point on the Body surface. An impulse is a force added to a body during a short
  /// period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
  external void applyImpulseLocal(List<num> impulse, num localX, num localY);

  /// Clears the collision data from the shapes in this Body. Optionally clears Group and/or Mask.
  external void clearCollision([bool clearGroup, bool cleanMask, Shape shape]);

  /// Removes all Shapes from this Body.
  external void clearShapes();

  /// Adds the given CollisionGroup, or array of CollisionGroups, to the list of groups that this body will collide with and updates the collision masks.
  external void collides(dynamic group,
      [Function callback, dynamic callbackContext, Shape shape]);

  /// Sets a callback to be fired any time a shape in this Body impacts with a shape in the given Body. The impact test is performed against body.id values.
  /// The callback will be sent 4 parameters: This body, the body that impacted, the Shape in this body and the shape in the impacting body.
  /// Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
  /// It also happens mid-step. So do not destroy a Body during this callback, instead set safeDestroy to true so it will be killed on the next preUpdate.
  external void createBodyCallback(
      dynamic object, Function callback, dynamic callbackContext);

  /// Sets a callback to be fired any time this Body impacts with the given Group. The impact test is performed against shape.collisionGroup values.
  /// The callback will be sent 4 parameters: This body, the body that impacted, the Shape in this body and the shape in the impacting body.
  /// This callback will only fire if this Body has been assigned a collision group.
  /// Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.
  /// It also happens mid-step. So do not destroy a Body during this callback, instead set safeDestroy to true so it will be killed on the next preUpdate.
  external void createGroupCallback(
      CollisionGroup group, Function callback, dynamic callbackContext);

  /// Destroys this Body and all references it holds to other objects.
  external void destroy();

  /// Gets the collision bitmask from the groups this body collides with.
  external num getCollisionMask();

  /// Gets the velocity of a point in the body.
  external List<num> getVelocityAtPoint(
      List<num> result, List<num> relativePoint);

  /// Reads the shape data from a physics data file stored in the Game.Cache and adds it as a polygon to this Body.
  /// As well as reading the data from the Cache you can also pass `null` as the first argument and a
  /// physics data object as the second. When doing this you must ensure the structure of the object is correct in advance.
  /// For more details see the format of the Lime / Corona Physics Editor export.
  /// data as the 2nd argument.
  /// or if key is null pass the actual physics data object itself as this parameter.
  external bool loadPolygon(String key, String object, [num scale]);

  /// Moves the Body backwards based on its current angle and the given speed.
  /// The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
  external void moveBackward(num speed);

  /// If this Body is dynamic then this will move it down by setting its y velocity to the given speed.
  /// The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
  external void moveDown(num speed);

  /// Moves the Body forwards based on its current angle and the given speed.
  /// The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
  external void moveForward(num speed);

  /// If this Body is dynamic then this will move it to the left by setting its x velocity to the given speed.
  /// The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
  external void moveLeft(num speed);

  /// If this Body is dynamic then this will move it to the right by setting its x velocity to the given speed.
  /// The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
  external void moveRight(num speed);

  /// If this Body is dynamic then this will move it up by setting its y velocity to the given speed.
  /// The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
  external void moveUp(num speed);

  /// Internal method. This is called directly before the sprites are sent to the renderer and after the update function has finished.
  external void preUpdate();

  /// Internal method. This is called directly before the sprites are sent to the renderer and after the update function has finished.
  external void postUpdate();

  /// Removes the given CollisionGroup, or array of CollisionGroups, from the list of groups that this body will collide with and updates the collision masks.
  external void removeCollisionGroup(dynamic group,
      [bool clearCallback, Shape shape]);

  /// Removes this physics body from the world.
  external void removeFromWorld();

  /// Remove a shape from the body. Will automatically update the mass properties and bounding radius.
  external bool removeShape(Shape shape);

  /// Applies a force to the Body that causes it to 'thrust' backwards (in reverse), based on its current angle and the given speed.
  /// The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
  external void reverse(num speed);

  /// This will rotate the Body by the given speed to the left (counter-clockwise).
  external void rotateLeft(num speed);

  /// This will rotate the Body by the given speed to the left (clockwise).
  external void rotateRight(num speed);

  /// Resets the Body force, velocity (linear and angular) and rotation. Optionally resets damping and mass.
  external void reset(num x, num y, [bool resetDamping, bool resetMass]);

  /// Updates the debug draw if any body shapes change.
  external void shapeChanged();

  /// Clears any previously set shapes. Then creates a new Circle shape and adds it to this Body.
  /// If this Body had a previously set Collision Group you will need to re-apply it to the new Shape this creates.
  external Circle setCircle(num radius,
      [num offsetX, num offsetY, num rotation]);

  /// Sets the given CollisionGroup to be the collision group for all shapes in this Body, unless a shape is specified.
  /// This also resets the collisionMask.
  external void setCollisionGroup(CollisionGroup group, [Shape shape]);

  /// Clears any previously set shapes. The creates a new Rectangle shape at the given size and offset, and adds it to this Body.
  /// If you wish to create a Rectangle to match the size of a Sprite or Image see Body.setRectangleFromSprite.
  /// If this Body had a previously set Collision Group you will need to re-apply it to the new Shape this creates.
  external Rectangle setRectangle(
      [num width, num height, num offsetX, num offsetY, num rotation]);

  /// Clears any previously set shapes.
  /// Then creates a Rectangle shape sized to match the dimensions and orientation of the Sprite given.
  /// If no Sprite is given it defaults to using the parent of this Body.
  /// If this Body had a previously set Collision Group you will need to re-apply it to the new Shape this creates.
  external Rectangle setRectangleFromSprite(dynamic sprite);

  /// Adds the given Material to all Shapes that belong to this Body.
  /// If you only wish to apply it to a specific Shape in this Body then provide that as the 2nd parameter.
  external void setMaterial(Material material, [Shape shape]);

  /// Sets the Body damping and angularDamping to zero.
  external void setZeroDamping();

  /// Sets the force on the body to zero.
  external void setZeroForce();

  /// If this Body is dynamic then this will zero its angular velocity.
  external void setZeroRotation();

  /// If this Body is dynamic then this will zero its velocity on both axis.
  external void setZeroVelocity();

  /// Transform a world point to local body frame.
  external void toLocalFrame(List<num> out, List<num> worldPoint);

  /// Applies a force to the Body that causes it to 'thrust' forwards, based on its current angle and the given speed.
  /// The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
  external void thrust(num speed);

  /// Applies a force to the Body that causes it to 'thrust' to the left, based on its current angle and the given speed.
  /// The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
  external void thrustLeft(num speed);

  /// Applies a force to the Body that causes it to 'thrust' to the right, based on its current angle and the given speed.
  /// The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).
  external void thrustRight(num speed);

  /// Transform a local point to world frame.
  external void toWorldFrame(List<num> out, List<num> localPoint);

  /// Updates the collisionMask.
  external void updateCollisionMask([Shape shape]);
}

/// Draws a P2 Body to a Graphics instance for visual debugging.
/// Needless to say, for every body you enable debug drawing on, you are adding processor and graphical overhead.
/// So use sparingly and rarely (if ever) in production code.
/// Also be aware that the Debug body is only updated when the Sprite it is connected to changes position. If you
/// manipulate the sprite in any other way (such as moving it to another Group or bringToTop, etc) then you will
/// need to manually adjust its BodyDebug as well.
@JS("Phaser.Physics.P2.BodyDebug")
class BodyDebug extends Group {
  // @Ignore
  BodyDebug.fakeConstructor$() : super.fakeConstructor$();

  /// Draws a P2 Body to a Graphics instance for visual debugging.
  /// Needless to say, for every body you enable debug drawing on, you are adding processor and graphical overhead.
  /// So use sparingly and rarely (if ever) in production code.
  /// Also be aware that the Debug body is only updated when the Sprite it is connected to changes position. If you
  /// manipulate the sprite in any other way (such as moving it to another Group or bringToTop, etc) then you will
  /// need to manually adjust its BodyDebug as well.
  /// The alpha value of the group container.
  external factory BodyDebug(Game game, P2_Body body,
      dynamic /*{ pixelsPerLengthUnit?: number; debugPolygons?: boolean; lineWidth?: number; alpha?: number; }*/ settings);

  /// The P2 Body to display debug data for.
  external P2_Body get body;
  external set body(P2_Body v);

  /// The canvas to render the debug info to.
  external Graphics get canvas;
  external set canvas(Graphics v);

  /// Pixels per Length Unit.
  external num get ppu;
  external set ppu(num v);

  /// Core update.
  external void updateSpriteTransform();

  /// Draws the P2 shapes to the Graphics object.
  external void draw();
}

/// Collision Group
@JS("Phaser.Physics.P2.CollisionGroup")
class CollisionGroup {
  // @Ignore
  CollisionGroup.fakeConstructor$();

  /// Collision Group
  external factory CollisionGroup(num bitmask);

  /// The CollisionGroup bitmask.
  external num get mask;
  external set mask(num v);
}

/// Defines a physics material
@JS("Phaser.Physics.P2.ContactMaterial")
class PhaserContactMaterial extends ContactMaterial {
  // @Ignore
  PhaserContactMaterial.fakeConstructor$() : super.fakeConstructor$();
}

/// A constraint that tries to keep the distance between two bodies constant.
@JS("Phaser.Physics.P2.DistanceConstraint")
class PhaserDistanceConstraint extends DistanceConstraint {
  // @Ignore
  PhaserDistanceConstraint.fakeConstructor$() : super.fakeConstructor$();

  /// A constraint that tries to keep the distance between two bodies constant.
  external factory PhaserDistanceConstraint(
      P2 world, P2_Body bodyA, P2_Body bodyB, num distance, num maxForce);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// Local reference to P2 World.
  external P2 get world;
  external set world(P2 v);
}

/// Allow to access a list of created fixture (coming from Body#addPhaserPolygon)
/// which itself parse the input from PhysicsEditor with the custom phaser exporter.
/// You can access fixtures of a Body by a group index or even by providing a fixture Key.
/// You can set the fixture key and also the group index for a fixture in PhysicsEditor.
/// This gives you the power to create a complex body built of many fixtures and modify them
/// during runtime (to remove parts, set masks, categories & sensor properties)
@JS("Phaser.Physics.P2.FixtureList")
class FixtureList {
  // @Ignore
  FixtureList.fakeConstructor$();

  /// Allow to access a list of created fixture (coming from Body#addPhaserPolygon)
  /// which itself parse the input from PhysicsEditor with the custom phaser exporter.
  /// You can access fixtures of a Body by a group index or even by providing a fixture Key.
  /// You can set the fixture key and also the group index for a fixture in PhysicsEditor.
  /// This gives you the power to create a complex body built of many fixtures and modify them
  /// during runtime (to remove parts, set masks, categories & sensor properties)
  external factory FixtureList(List<dynamic> list);

  /// A helper to flatten arrays. This is very useful as the fixtures are nested from time to time due to the way P2 creates and splits polygons.
  external List<dynamic> flatten(List<dynamic> array);

  /// Accessor to get either a list of specified fixtures by key or the whole fixture list
  external List<dynamic> getFixtures(String keys);

  /// Accessor to get either a single fixture by its key.
  external List<dynamic> getFixtureByKey(String key);

  /// Accessor to get a group of fixtures by its group index.
  external List<dynamic> getGroup(num groupID);
  external void init();

  /// Parser for the output of Phaser.Physics.P2.Body#addPhaserPolygon
  external void parse();
  external void setCategory(num bit, String fictureKey);
  external void setMask(num bit, String fixtureKey);
  external void setMaterial(dynamic material, String fixtureKey);
  external void setSensor(bool value, String fixtureKey);
}

/// Connects two bodies at given offset points, letting them rotate relative to each other around this point.
@JS("Phaser.Physics.P2.GearConstraint")
class PhaserGearConstraint extends GearConstraint {
  // @Ignore
  PhaserGearConstraint.fakeConstructor$() : super.fakeConstructor$();

  /// Connects two bodies at given offset points, letting them rotate relative to each other around this point.
  external factory PhaserGearConstraint(P2 world, P2_Body bodyA, P2_Body bodyB,
      [num angle, num ratio]);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// Local reference to P2 World.
  external P2 get world;
  external set world(P2 v);
}

/// A InversePointProxy is an internal class that allows for direct getter/setter style property access to Arrays and TypedArrays but inverses the values on set.
@JS("Phaser.Physics.P2.InversePointProxy")
class InversePointProxy {
  // @Ignore
  InversePointProxy.fakeConstructor$();

  /// A InversePointProxy is an internal class that allows for direct getter/setter style property access to Arrays and TypedArrays but inverses the values on set.
  external factory InversePointProxy(P2 world, dynamic destination);

  /// The x property of this InversePointProxy get and set in pixels.
  external num get x;
  external set x(num v);

  /// The y property of this InversePointProxy get and set in pixels.
  external num get y;
  external set y(num v);

  /// The x property of this InversePointProxy get and set in meters.
  external num get mx;
  external set mx(num v);

  /// The y property of this InversePointProxy get and set in meters.
  external num get my;
  external set my(num v);
}

/// Locks the relative position between two bodies.
@JS("Phaser.Physics.P2.LockConstraint")
class PhaserLockConstraint extends LockConstraint {
  // @Ignore
  PhaserLockConstraint.fakeConstructor$() : super.fakeConstructor$();

  /// Locks the relative position between two bodies.
  external factory PhaserLockConstraint(P2 world, P2_Body bodyA, P2_Body bodyB,
      [List<num> offset, num angle, num maxForce]);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// Local reference to P2 World.
  external P2 get world;
  external set world(P2 v);
}

/// A P2 Material.
/// \o/ ~ "Because I'm a Material girl"
@JS("Phaser.Physics.P2.Material")
class PhaserMaterial extends Material {
  // @Ignore
  PhaserMaterial.fakeConstructor$() : super.fakeConstructor$();

  /// A P2 Material.
  /// \o/ ~ "Because I'm a Material girl"
  external factory PhaserMaterial(String name);

  /// The user defined name given to this Material.
  external String get name;
  external set name(String v);
}

/// A PointProxy is an internal class that allows for direct getter/setter style property access to Arrays and TypedArrays.
@JS("Phaser.Physics.P2.PointProxy")
class PointProxy {
  // @Ignore
  PointProxy.fakeConstructor$();

  /// A PointProxy is an internal class that allows for direct getter/setter style property access to Arrays and TypedArrays.
  external factory PointProxy(P2 world, dynamic destination);

  /// The x property of this PointProxy get and set in pixels.
  external num get x;
  external set x(num v);

  /// The y property of this PointProxy get and set in pixels.
  external num get y;
  external set y(num v);

  /// The x property of this PointProxy get and set in meters.
  external num get mx;
  external set mx(num v);

  /// The x property of this PointProxy get and set in meters.
  external num get my;
  external set my(num v);
}

/// Connects two bodies at given offset points, letting them rotate relative to each other around this point.
@JS("Phaser.Physics.P2.PrismaticConstraint")
class PhaserPrismaticConstraint extends PrismaticConstraint {
  // @Ignore
  PhaserPrismaticConstraint.fakeConstructor$() : super.fakeConstructor$();

  /// Connects two bodies at given offset points, letting them rotate relative to each other around this point.
  external factory PhaserPrismaticConstraint(P2 world,
      [P2_Body bodyA,
      P2_Body bodyB,
      bool lockRotation,
      List<num> anchorA,
      List<num> anchorB,
      List<num> axis,
      num maxForce]);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// Local reference to P2 World.
  external P2 get world;
  external set world(P2 v);
}

/// Connects two bodies at given offset points, letting them rotate relative to each other around this point.
/// The pivot points are given in world (pixel) coordinates.
@JS("Phaser.Physics.P2.RevoluteConstraint")
class PhaserRevoluteConstraint extends RevoluteConstraint {
  // @Ignore
  PhaserRevoluteConstraint.fakeConstructor$() : super.fakeConstructor$();

  /// Connects two bodies at given offset points, letting them rotate relative to each other around this point.
  /// The pivot points are given in world (pixel) coordinates.
  external factory PhaserRevoluteConstraint(P2 world, P2_Body bodyA, List<num> pivotA,
      P2_Body bodyB, List<num> pivotB,
      [num maxForce]);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// Local reference to P2 World.
  external P2 get world;
  external set world(P2 v);
}

/// Creates a linear spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.
@JS("Phaser.Physics.P2.Spring")
class Spring {
  // @Ignore
  Spring.fakeConstructor$();

  /// Creates a linear spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.
  external factory Spring(P2 world, P2_Body bodyA, P2_Body bodyB,
      [num restLength,
      num stiffness,
      num damping,
      List<num> worldA,
      List<num> worldB,
      List<num> localA,
      List<num> localB]);

  /// The actual p2 spring object.
  external LinearSpring get data;
  external set data(LinearSpring v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// Local reference to P2 World.
  external P2 get world;
  external set world(P2 v);
}

// End module P2

// End module Physics
/// This is a base Plugin template to use for any Phaser plugin development.
/// ##### Callbacks
/// add  | active      | visible     | remove
/// -----|-------------|-------------|--------
/// init |             |             |
/// | preUpdate*  |             |
/// | update*     | render*     |
/// | postUpdate* | postRender* |
/// |             |             | destroy
/// Update and render calls are repeated (*).
@JS("Phaser.Plugin")
class Plugin implements IStateCycle {
  // @Ignore
  Plugin.fakeConstructor$();

  /// This is a base Plugin template to use for any Phaser plugin development.
  /// ##### Callbacks
  /// add  | active      | visible     | remove
  /// -----|-------------|-------------|--------
  /// init |             |             |
  /// | preUpdate*  |             |
  /// | update*     | render*     |
  /// | postUpdate* | postRender* |
  /// |             |             | destroy
  /// Update and render calls are repeated (*).
  external factory Plugin(Game game, PluginManager parent);

  /// A Plugin with active=true has its preUpdate and update methods called by the parent, otherwise they are skipped.
  external bool get active;
  external set active(bool v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// A flag to indicate if this plugin has a postRender method.
  external bool get hasPostRender;
  external set hasPostRender(bool v);

  /// A flag to indicate if this plugin has a postUpdate method.
  external bool get hasPostUpdate;
  external set hasPostUpdate(bool v);

  /// A flag to indicate if this plugin has a preUpdate method.
  external bool get hasPreUpdate;
  external set hasPreUpdate(bool v);

  /// A flag to indicate if this plugin has a render method.
  external bool get hasRender;
  external set hasRender(bool v);

  /// A flag to indicate if this plugin has an update method.
  external bool get hasUpdate;
  external set hasUpdate(bool v);

  /// The parent of this plugin. If added to the PluginManager the parent will be set to that, otherwise it will be null.
  external DisplayObject get parent;
  external set parent(DisplayObject v);

  /// A Plugin with visible=true has its render and postRender methods called by the parent, otherwise they are skipped.
  external bool get visible;
  external set visible(bool v);

  /// Clear down this Plugin and null out references
  external void destroy();

  /// Post-render is called after the Game Renderer and State.render have run.
  /// It is only called if visible is set to true.
  external void postRender();

  /// Pre-update is called at the very start of the update cycle, before any other subsystems have been updated (including Physics).
  /// It is only called if active is set to true.
  external void preUpdate();

  /// Render is called right after the Game Renderer completes, but before the State.render.
  /// It is only called if visible is set to true.
  external void render();

  /// Update is called after all the core subsystems (Input, Tweens, Sound, etc) and the State have updated, but before the render.
  /// It is only called if active is set to true.
  external void update();
}

// Module Plugin
@JS("Phaser.Plugin.SaveCPU")
class SaveCPU extends Plugin {
  // @Ignore
  SaveCPU.fakeConstructor$() : super.fakeConstructor$();
  external num get renderOnFPS;
  external set renderOnFPS(num v);
  external bool get renderOnPointerChange;
  external set renderOnPointerChange(bool v);
  external void forceRender();
}

@JS("Phaser.Plugin.AStar")
class AStar extends Plugin {
  // @Ignore
  AStar.fakeConstructor$() : super.fakeConstructor$();
  external static String get VERSION;
  external static set VERSION(String v);
  external static num get COST_ORTHOGONAL;
  external static set COST_ORTHOGONAL(num v);
  external static num get COST_DIAGONAL;
  external static set COST_DIAGONAL(num v);
  external static String get DISTANCE_MANHATTAN;
  external static set DISTANCE_MANHATTAN(String v);
  external static String get DISTANCE_EUCLIDIAN;
  external static set DISTANCE_EUCLIDIAN(String v);
  external factory AStar(DisplayObject parent);
  external DisplayObject get parent;
  external set parent(DisplayObject v);
  external String get version;
  external set version(String v);
  external AStarPath findPath(Point startPoint, Point goalPoint);
  external bool isWalkable(num x, num y);
  external AStar setAStarMap(Tilemap map, String layerName, String tilesetName);
}

// Module AStar
@JS("Phaser.Plugin.AStar.AStarNode")
class AStarNode {
  // @Ignore
  AStarNode.fakeConstructor$();
  external factory AStarNode(num x, num y, bool isWalkable);
  external num get x;
  external set x(num v);
  external num get y;
  external set y(num v);
  external num get g;
  external set g(num v);
  external num get h;
  external set h(num v);
  external num get f;
  external set f(num v);
  external AStarNode get parent;
  external set parent(AStarNode v);
  external num get travelCost;
  external set travelCost(num v);
  external bool get walkable;
  external set walkable(bool v);
}

@anonymous
@JS()
abstract class AStarNodeArray {
  external num get x;
  external set x(num v);
  external num get y;
  external set y(num v);
  external factory AStarNodeArray({num x, num y});
}

@JS("Phaser.Plugin.AStar.AStarPath")
class AStarPath {
  // @Ignore
  AStarPath.fakeConstructor$();
  external factory AStarPath(
      [List<AStarNodeArray> nodes, AStarNode start, AStarNode goal]);
  external List<AStarNodeArray> get nodes;
  external set nodes(List<AStarNodeArray> v);
  external AStarNode get start;
  external set start(AStarNode v);
  external AStarNode get goal;
  external set goal(AStarNode v);
  external List<AStarNode> get visited;
  external set visited(List<AStarNode> v);
}

// End module AStar
@JS("Phaser.Plugin.ColorHarmony")
class ColorHarmony extends Plugin {
  // @Ignore
  ColorHarmony.fakeConstructor$() : super.fakeConstructor$();
  external dynamic getAnalogousHarmony(num color, [num threshold]);
  external num getComplementHarmony(num color);
  external dynamic getSplitComplementHarmony(num color, num threshold);
  external dynamic getTriadicHarmony(num color);
}

@JS("Phaser.Plugin.CSS3Filters")
class CSS3Filters extends Plugin {
  // @Ignore
  CSS3Filters.fakeConstructor$() : super.fakeConstructor$();
  external factory CSS3Filters(DisplayObject parent);
  external num get blur;
  external set blur(num v);
  external num get brightness;
  external set brightness(num v);
  external num get contrast;
  external set contrast(num v);
  external num get grayscale;
  external set grayscale(num v);
  external num get hueRotate;
  external set hueRotate(num v);
  external num get invert;
  external set invert(num v);
  external num get opacity;
  external set opacity(num v);
  external num get saturate;
  external set saturate(num v);
  external num get sepia;
  external set sepia(num v);
}

@JS("Phaser.Plugin.TilemapWalker")
class TilemapWalker extends Plugin {
  // @Ignore
  TilemapWalker.fakeConstructor$() : super.fakeConstructor$();
  external factory TilemapWalker(Game game, Tilemap map,
      [dynamic layer, num x, num y]);
  external bool get collides;
  external set collides(bool v);
  external Game get game;
  external set game(Game v);
  external bool get history;
  external set history(bool v);
  external num get facing;
  external set facing(num v);
  external Tilemap get map;
  external set map(Tilemap v);
  external PhaserPoint get location;
  external set location(Point v);
  external num get locationLayer;
  external set locationLayer(num v);
  external bool checkTile(num x, num y);
  external Tile getTileFromLocation(num x, num y);
  external List<dynamic> getTiles(num width, num height, [bool center]);
  external Tile getTileBehind([num distance]);
  external Tile getTileBehindLeft([num distance]);
  external Tile getTileBehindRight([num distance]);
  external Tile getTileAhead([num distance]);
  external Tile getTileAheadLeft([num distance]);
  external Tile getTileAheadRight([num distance]);
  external Tile getTileLeft(num distance);
  external Tile getTileRight(num distance);
  external bool moveForward();
  external bool moveBackward();
  external bool moveLeft();
  external bool moveRight();
  external void putTile(num index);
  external bool setLocation(num x, num y, [dynamic layer]);
  external void turnLeft();
  external void turnRight();
  external bool updateLocation(num x, num y);
}

@JS("Phaser.Plugin.SamplePlugin")
class SamplePlugin extends Plugin {
  // @Ignore
  SamplePlugin.fakeConstructor$() : super.fakeConstructor$();
  external factory SamplePlugin(Game game, DisplayObject parent);
  external void addSprite(Sprite sprite);
  external void update();
}

@JS("Phaser.Plugin.VirtualJoystick")
class VirtualJoystick extends Plugin {
  // @Ignore
  VirtualJoystick.fakeConstructor$() : super.fakeConstructor$();
  external factory VirtualJoystick(Game game, dynamic parent);
  external num get angle;
  external set angle(num v);
  external Sprite get base;
  external set base(Sprite v);
  external BitmapData get baseBMD;
  external set baseBMD(BitmapData v);
  external Circle get baseCircle;
  external set baseCircle(Circle v);
  external num get deltaX;
  external set deltaX(num v);
  external num get deltaY;
  external set deltaY(num v);
  external num get distance;
  external set distance(num v);
  external num get force;
  external set force(num v);
  external bool get isDragging;
  external set isDragging(bool v);
  external num get limit;
  external set limit(num v);
  external PhaserPoint get limitPoint;
  external set limitPoint(Point v);
  external PhaserPoint get location;
  external set location(Point v);
  external Sprite get nub;
  external set nub(Sprite v);
  external BitmapData get nubBMD;
  external set nubBMD(BitmapData v);
  external num get speed;
  external set speed(num v);
  external num get x;
  external set x(num v);
  external num get y;
  external set y(num v);
  external void init(num x, num y, [num diameter, num limit]);
  external void move(Pointer pointer, num x, num y);
  external void render();
  external Sprite setVelocity(Sprite sprite, [num minSpeed, num maxSpeed]);
  external void startDrag();
  external void stopDrag(Sprite nub, Pointer pointer);
  external void update();
}

@JS("Phaser.Plugin.Webcam")
class Webcam extends Plugin {
  // @Ignore
  Webcam.fakeConstructor$() : super.fakeConstructor$();
  external factory Webcam(Game game, DisplayObject parent);
  external bool get active;
  external set active(bool v);
  external dynamic get context;
  external set context(dynamic v);
  external dynamic get stream;
  external set stream(dynamic v);
  external VideoElement get video;
  external set video(VideoElement v);
  external VoidFunc1<dynamic> get connectCallback;
  external set connectCallback(VoidFunc1<dynamic> v);
  external VoidFunc1<dynamic> get errorCallback;
  external set errorCallback(VoidFunc1<dynamic> v);
  external VoidFunc3<dynamic, num, num> get grab;
  external set grab(VoidFunc3<dynamic, num, num> v);
  external void start(num width, num height, dynamic context);
  external void stop();
  external void update();
}

@JS("Phaser.Plugin.Juicy")
class Juicy extends Plugin {
  // @Ignore
  Juicy.fakeConstructor$() : super.fakeConstructor$();
  external factory Juicy(Game game);
  external ScreenFlash createScreenFlash([String color]);
  external Trail createTrail([num length, num color]);
  external void overScale(Sprite object, [num scale, Point initialScale]);
  external void jelly(Sprite object,
      [num strength, num delay, Point initialScale]);
  external void mouseStretch(Sprite object, [num strength, Point initialScale]);
  external void update();
  external void shake([num duration, num strength]);
}

// Module Juicy
@JS("Phaser.Plugin.Juicy.Trail")
class Trail {
  // @Ignore
  Trail.fakeConstructor$();
  external factory Trail(Game game, [num trailLength, num color]);
  external Sprite get target;
  external set target(Sprite v);
  external num get trailLength;
  external set trailLength(num v);
  external num get trailWidth;
  external set trailWidth(num v);
  external bool get trailScaling;
  external set trailScaling(bool v);
  external num get trailColor;
  external set trailColor(num v);
  external void update();
  external void addSegment(num x, num y);
  external void redrawSegments(num offsetX, num offsetY);
}

@JS("Phaser.Plugin.Juicy.ScreenFlash")
class ScreenFlash {
  // @Ignore
  ScreenFlash.fakeConstructor$();
  external factory ScreenFlash(Game game, [String color]);
  external void flash([num maxAlpha, num duration]);
}

// End module Juicy

// End module Plugin
@anonymous
@JS()
abstract class PluginConstructorOf<T> {
  // Constructors on anonymous interfaces are not yet supported.
  /*external factory PluginConstructorOf([dynamic parameters1, dynamic parameters2, dynamic parameters3, dynamic parameters4, dynamic parameters5]);*/
}

/// The Plugin Manager is responsible for the loading, running and unloading of Phaser Plugins.
@JS("Phaser.PluginManager")
class PluginManager implements IStateCycle {
  // @Ignore
  PluginManager.fakeConstructor$();

  /// The Plugin Manager is responsible for the loading, running and unloading of Phaser Plugins.
  external factory PluginManager(Game game);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// An array of all the plugins being managed by this PluginManager.
  external List<Plugin> get plugins;
  external set plugins(List<Plugin> v);

  /// Add a new Plugin into the PluginManager.
  /// The Plugin must have 2 properties: game and parent. Plugin.game is set to the game reference the PluginManager uses, and parent is set to the PluginManager.
  external dynamic/*=T*/ add/*<T extends Plugin>*/(
      PluginConstructorOf<dynamic/*=T*/ > plugin,
      [dynamic parameters1,
      dynamic parameters2,
      dynamic parameters3,
      dynamic parameters4,
      dynamic parameters5]);

  /// Clear down this PluginManager, calls destroy on every plugin and nulls out references.
  external void destroy();

  /// Post-render is called after the Game Renderer and State.render have run.
  /// It only calls plugins who have visible=true.
  external void postRender();

  /// PostUpdate is the last thing to be called before the world render.
  /// In particular, it is called after the world postUpdate, which means the camera has been adjusted.
  /// It only calls plugins who have active=true.
  external void postUpdate();

  /// Pre-update is called at the very start of the update cycle, before any other subsystems have been updated (including Physics).
  /// It only calls plugins who have active=true.
  external void preUpdate();

  /// Remove a Plugin from the PluginManager. It calls Plugin.destroy on the plugin before removing it from the manager.
  external void remove(Plugin plugin, [bool destroy]);

  /// Remove all Plugins from the PluginManager. It calls Plugin.destroy on every plugin before removing it from the manager.
  external void removeAll();

  /// Render is called right after the Game Renderer completes, but before the State.render.
  /// It only calls plugins who have visible=true.
  external void render();

  /// Update is called after all the core subsystems (Input, Tweens, Sound, etc) and the State have updated, but before the render.
  /// It only calls plugins who have active=true.
  external void update();
}

/// A Point object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.
/// The following code creates a point at (0,0):
/// `var myPoint = new Phaser.Point();`
/// You can also use them as 2D Vectors and you'll find different vector related methods in this class.
@JS("Phaser.Point")
class PhaserPoint extends Point {
  // @Ignore
  PhaserPoint.fakeConstructor$() : super.fakeConstructor$();

  /// A Point object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.
  /// The following code creates a point at (0,0):
  /// `var myPoint = new Phaser.Point();`
  /// You can also use them as 2D Vectors and you'll find different vector related methods in this class.
  external factory PhaserPoint([num x, num y]);

  /// The x value of the point.
  external num get x;
  external set x(num v);

  /// The y value of the point.
  external num get y;
  external set y(num v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// Adds the given x and y values to this Point.
  /*external static Point add(Point a, Point b, [Point out]);*/
  /// Adds the given x and y values to this Point.
  /*external Point add(num x, num y);*/
  external PhaserPoint add(dynamic /*Point|num*/ a_x, dynamic /*Point|num*/ b_y,
      [Point out]);
  /*external static Point subtract(Point a, Point b, [Point out]);*/
  /// Subtracts the given x and y values from this Point.
  /*external Point subtract(num x, num y);*/
  external PhaserPoint subtract(dynamic /*Point|num*/ a_x, dynamic /*Point|num*/ b_y,
      [Point out]);
  /*external static Point multiply(Point a, Point b, [Point out]);*/
  /*external Point multiply(num x, num y);*/
  external PhaserPoint multiply(dynamic /*Point|num*/ a_x, dynamic /*Point|num*/ b_y,
      [Point out]);
  /*external static Point divide(Point a, Point b, [Point out]);*/
  /*external Point divide(num x, num y);*/
  external PhaserPoint divide(dynamic /*Point|num*/ a_x, dynamic /*Point|num*/ b_y,
      [Point out]);
  /*external static bool equals(Point a, Point b);*/
  /*external bool equals(Point a);*/
  external bool equals(Point a, [Point b]);
  /*external static bool equalsXY(Point a, num x, num y);*/
  /*external bool equalsXY(num x, num y);*/
  external bool equalsXY(dynamic /*Point|num*/ a_x, num x_y, [num y]);
  /*external static bool fuzzyEquals(Point a, Point b, [num epsilon]);*/
  /*external bool fuzzyEquals(Point a, [num epsilon]);*/
  external bool fuzzyEquals(Point a,
      [dynamic /*Point|num*/ b_epsilon, num epsilon]);
  /*external static bool fuzzyEqualsXY(Point a, num x, num y, [num epsilon]);*/
  /*external bool fuzzyEqualsXY(num x, num y, [num epsilon]);*/
  external bool fuzzyEqualsXY(dynamic /*Point|num*/ a_x, num x_y,
      [num y_epsilon, num epsilon]);
  /*external static num angle(Point a, Point b);*/
  /*external num angle(Point a, [bool asDegrees]);*/
  external num angle(Point a, [dynamic /*Point|bool*/ b_asDegrees]);
  /*external static num angleSq(Point a, Point b);*/
  /*external num angleSq(Point a);*/
  external num angleSq(Point a, [Point b]);
  external static PhaserPoint negative(Point a, [Point out]);
  external static PhaserPoint multiplyAdd(Point a, Point b, num scale, [Point out]);
  external static PhaserPoint interpolate(Point a, Point b, num alpha, [Point out]);
  external static PhaserPoint parse(dynamic obj, [String xProp, String yProp]);
  /*external static Point perp(Point a, [Point out]);*/
  /*external Point perp();*/
  external PhaserPoint perp([Point a, Point out]);
  /*external static Point rperp(Point a, [Point out]);*/
  /*external Point rperp();*/
  external PhaserPoint rperp([Point a, Point out]);
  /*external static num distance(dynamic a, dynamic b, [bool round]);*/
  /*external num distance(Point dest, [bool round]);*/
  external num distance(dynamic /*dynamic|Point*/ a_dest,
      [dynamic /*dynamic|bool*/ b_round, bool round]);
  external static PhaserPoint project(Point a, Point b, [Point out]);
  external static PhaserPoint projectUnit(Point a, Point b, [Point out]);
  /*external static Point normalRightHand(Point a, [Point out]);*/
  /*external Point normalRightHand();*/
  external PhaserPoint normalRightHand([Point a, Point out]);
  /*external static Point normalize(Point a, [Point out]);*/
  /*external Point normalize();*/
  external PhaserPoint normalize([Point a, Point out]);
  /*external static PhaserPoint rotate(PhaserPoint a, num x, num y, num angle, [bool asDegrees, num distance]);*/
  /*external PhaserPoint rotate(num x, num y, num angle, [bool asDegrees, num distance]);*/
  external PhaserPoint rotate(dynamic /*PhaserPoint|num*/ a_x, num x_y, num y_angle,
      [dynamic /*num|bool*/ angle_asDegrees,
      dynamic /*bool|num*/ asDegrees_distance,
      num distance]);
  external static PhaserPoint centroid(List<PhaserPoint> PhaserPoints, [PhaserPoint out]);
  external static bool isPhaserPoint(dynamic obj);
  /*external static dynamic JS$set(dynamic obj, num x, num y);*/
  /*external PhaserPoint JS$set(num x, [num y]);*/
  external dynamic /*dynamic|PhaserPoint*/ JS$set(dynamic /*dynamic|num*/ obj_x,
      [num x_y, num y]);
  external static List<dynamic> sortClockwise(List<dynamic> PhaserPoints,
      [PhaserPoint center]);
  external num angleXY(num x, num y, [bool asDegrees]);
  external num atan([bool asDegrees]);
  external PhaserPoint ceil();
  external PhaserPoint clamp(num min, num max);
  external PhaserPoint clampX(num min, num max);
  external PhaserPoint clampY(num min, num max);
  external PhaserPoint clip(dynamic rect);
  external PhaserPoint clone([PhaserPoint output]);
  external PhaserPoint copyFrom(PhaserPoint source);
  external dynamic/*=T*/ copyTo/*<T>*/(dynamic/*=T*/ dest);
  external num cross(PhaserPoint a);
  external num dot(PhaserPoint a);
  external PhaserPoint expand(num min);
  external PhaserPoint floor();
  external num getMagnitude();
  external num getMagnitudeSq();
  external PhaserPoint invert();
  external bool isZero();
  external PhaserPoint limit(num max);
  external PhaserPoint setMagnitude(num magnitude);
  external PhaserPoint setTo(num x, [num y]);
  external PhaserPoint setToPolar(num azimuth, [num radius, bool asDegrees]);

  /// Returns a string representation of this object.
  external String toString();
}

/// A Pointer object is used by the Mouse, Touch and MSPoint managers and represents a single finger on the touch screen.
@JS("Phaser.Pointer")
class Pointer {
  // @Ignore
  Pointer.fakeConstructor$();

  /// A Pointer object is used by the Mouse, Touch and MSPoint managers and represents a single finger on the touch screen.
  external factory Pointer(Game game, num id, [num pointerMode]);

  /// No buttons at all.
  external static num get NO_BUTTON;
  external static set NO_BUTTON(num v);

  /// The Left Mouse button, or in PointerEvent devices a Touch contact or Pen contact.
  external static num get LEFT_BUTTON;
  external static set LEFT_BUTTON(num v);

  /// The Right Mouse button, or in PointerEvent devices a Pen contact with a barrel button.
  external static num get RIGHT_BUTTON;
  external static set RIGHT_BUTTON(num v);

  /// The Middle Mouse button.
  external static num get MIDDLE_BUTTON;
  external static set MIDDLE_BUTTON(num v);

  /// The X1 button. This is typically the mouse Back button, but is often reconfigured.
  /// On Linux (GTK) this is unsupported. On Windows if advanced pointer software (such as IntelliPoint) is installed this doesn't register.
  external static num get BACK_BUTTON;
  external static set BACK_BUTTON(num v);

  /// The X2 button. This is typically the mouse Forward button, but is often reconfigured.
  /// On Linux (GTK) this is unsupported. On Windows if advanced pointer software (such as IntelliPoint) is installed this doesn't register.
  external static num get FORWARD_BUTTON;
  external static set FORWARD_BUTTON(num v);

  /// The Eraser pen button on PointerEvent supported devices only.
  external static num get ERASER_BUTTON;
  external static set ERASER_BUTTON(num v);

  /// An active pointer is one that is currently pressed down on the display. A Mouse is always active.
  external bool get active;
  external set active(bool v);

  /// If this Pointer is a Mouse or Pen / Stylus then you can access its X1 (back) button directly through this property.
  /// The DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained
  /// button control.
  /// Please see the DeviceButton docs for details on browser button limitations.
  external DeviceButton get backButton;
  external set backButton(DeviceButton v);

  /// The button property of the most recent DOM event when this Pointer is started.
  /// You should not rely on this value for accurate button detection, instead use the Pointer properties
  /// `leftButton`, `rightButton`, `middleButton` and so on.
  external dynamic get button;
  external set button(dynamic v);

  /// A Phaser.Circle that is centered on the x/y coordinates of this pointer, useful for hit detection.
  /// The Circle size is 44px (Apples recommended "finger tip" size).
  external Circle get circle;
  external set circle(Circle v);

  /// The horizontal coordinate of the Pointer within the application's client area at which the event occurred (as opposed to the coordinates within the page).
  external num get clientX;
  external set clientX(num v);

  /// The vertical coordinate of the Pointer within the application's client area at which the event occurred (as opposed to the coordinates within the page).
  external num get clientY;
  external set clientY(num v);

  /// A dirty pointer needs to re-poll any interactive objects it may have been over, regardless if it has moved or not.
  external bool get dirty;
  external set dirty(bool v);

  /// How long the Pointer has been depressed on the touchscreen or *any* of the mouse buttons have been held down.
  /// If not currently down it returns -1.
  /// If you need to test a specific mouse or pen button then access the buttons directly, i.e. `Pointer.rightButton.duration`.
  external num get duration;
  external set duration(num v);

  /// If this Pointer is a Pen / Stylus then you can access its eraser button directly through this property.
  /// The DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained
  /// button control.
  /// Please see the DeviceButton docs for details on browser button limitations.
  external DeviceButton get eraserButton;
  external set eraserButton(DeviceButton v);

  /// A Pointer object that exists is allowed to be checked for physics collisions and overlaps.
  /// Default: true
  external bool get exists;
  external set exists(bool v);
  external bool get forceOut;
  external set forceOut(bool v);

  /// If this Pointer is a Mouse or Pen / Stylus then you can access its X2 (forward) button directly through this property.
  /// The DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained
  /// button control.
  /// Please see the DeviceButton docs for details on browser button limitations.
  external DeviceButton get forwardButton;
  external set forwardButton(DeviceButton v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);
  external dynamic /*bool|num*/ get justReleasePreventsOver;
  external set justReleasePreventsOver(dynamic /*bool|num*/ v);

  /// The ID of the Pointer object within the game. Each game can have up to 10 active pointers.
  external num get id;
  external set id(num v);

  /// The identifier property of the Pointer as set by the DOM event when this Pointer is started.
  external num get identifier;
  external set identifier(num v);

  /// This array is erased and re-populated every time this Pointer is updated. It contains references to all
  /// of the Game Objects that were considered as being valid for processing by this Pointer, this frame. To be
  /// valid they must have suitable a `priorityID`, be Input enabled, visible and actually have the Pointer over
  /// them. You can check the contents of this array in events such as `onInputDown`, but beware it is reset
  /// every frame.
  /// Default: []
  external List<InputHandler> get interactiveCandidates;
  external set interactiveCandidates(List<InputHandler> v);

  /// If the Pointer is touching the touchscreen, or *any* mouse or pen button is held down, isDown is set to true.
  /// If you need to check a specific mouse or pen button then use the button properties, i.e. Pointer.rightButton.isDown.
  external bool get isDown;
  external set isDown(bool v);

  /// If the Pointer is a mouse or pen / stylus this is true, otherwise false.
  external bool get isMouse;
  external set isMouse(bool v);

  /// If the Pointer is not touching the touchscreen, or *all* mouse or pen buttons are up, isUp is set to true.
  /// If you need to check a specific mouse or pen button then use the button properties, i.e. Pointer.rightButton.isUp.
  /// Default: true
  external bool get isUp;
  external set isUp(bool v);

  /// If this Pointer is a Mouse or Pen / Stylus then you can access its left button directly through this property.
  /// The DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained
  /// button control.
  external DeviceButton get leftButton;
  external set leftButton(DeviceButton v);

  /// If this Pointer is a Mouse or Pen / Stylus then you can access its middle button directly through this property.
  /// The DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained
  /// button control.
  /// Please see the DeviceButton docs for details on browser button limitations.
  external DeviceButton get middleButton;
  external set middleButton(DeviceButton v);

  /// The horizontal processed relative movement of the Pointer in pixels since last event.
  external num get movementX;
  external set movementX(num v);

  /// The vertical processed relative movement of the Pointer in pixels since last event.
  external num get movementY;
  external set movementY(num v);

  /// The number of milliseconds since the last click or touch event.
  external num get msSinceLastClick;
  external set msSinceLastClick(num v);

  /// The horizontal coordinate of the Pointer relative to whole document.
  external num get pageX;
  external set pageX(num v);

  /// The vertical coordinate of the Pointer relative to whole document.
  external num get pageY;
  external set pageY(num v);

  /// The pointerId property of the Pointer as set by the DOM event when this Pointer is started. The browser can and will recycle this value.
  external num get pointerId;
  external set pointerId(num v);

  /// The operational mode of this pointer.
  external num get pointerMode;
  external set pointerMode(num v);

  /// A Phaser.Point object containing the current x/y values of the pointer on the display.
  external PhaserPoint get position;
  external set position(Point v);

  /// A Phaser.Point object containing the x/y values of the pointer when it was last in a down state on the display.
  external PhaserPoint get positionDown;
  external set positionDown(Point v);

  /// A Phaser.Point object containing the x/y values of the pointer when it was last released.
  external PhaserPoint get positionUp;
  external set positionUp(Point v);

  /// A timestamp representing when the Pointer was last tapped or clicked.
  external num get previousTapTime;
  external set previousTapTime(num v);

  /// The horizontal raw relative movement of the Pointer in pixels since last event.
  external num get rawMovementX;
  external set rawMovementX(num v);

  /// The vertical raw relative movement of the Pointer in pixels since last event.
  external num get rawMovementY;
  external set rawMovementY(num v);

  /// If this Pointer is a Mouse or Pen / Stylus then you can access its right button directly through this property.
  /// The DeviceButton has its own properties such as `isDown`, `duration` and methods like `justReleased` for more fine-grained
  /// button control.
  /// Please see the DeviceButton docs for details on browser button limitations.
  external DeviceButton get rightButton;
  external set rightButton(DeviceButton v);

  /// The horizontal coordinate of the Pointer relative to the screen.
  external num get screenX;
  external set screenX(num v);

  /// The vertical coordinate of the Pointer relative to the screen.
  external num get screenY;
  external set screenY(num v);

  /// The target property of the Pointer as set by the DOM event when this Pointer is started.
  external dynamic get target;
  external set target(dynamic v);

  /// The Game Object this Pointer is currently over / touching / dragging.
  external dynamic get targetObject;
  external set targetObject(dynamic v);

  /// A timestamp representing when the Pointer first touched the touchscreen.
  external num get timeDown;
  external set timeDown(num v);

  /// A timestamp representing when the Pointer left the touchscreen.
  external num get timeUp;
  external set timeUp(num v);

  /// The total number of times this Pointer has been touched to the touchscreen.
  external num get totalTouches;
  external set totalTouches(num v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// true if the Pointer is over the game canvas, otherwise false.
  external bool get withinGame;
  external set withinGame(bool v);

  /// Gets the X value of this Pointer in world coordinates based on the world camera.
  external num get worldX;
  external set worldX(num v);

  /// Gets the Y value of this Pointer in world coordinates based on the world camera.
  external num get worldY;
  external set worldY(num v);

  /// The horizontal coordinate of the Pointer. This value is automatically scaled based on the game scale.
  external num get x;
  external set x(num v);

  /// The vertical coordinate of the Pointer. This value is automatically scaled based on the game scale.
  external num get y;
  external set y(num v);

  /// Add a click trampoline to this pointer.
  /// A click trampoline is a callback that is run on the DOM 'click' event; this is primarily
  /// needed with certain browsers (ie. IE11) which restrict some actions like requestFullscreen
  /// to the DOM 'click' event and rejects it for 'pointer*' and 'mouse*' events.
  /// This is used internally by the ScaleManager; click trampoline usage is uncommon.
  /// Click trampolines can only be added to pointers that are currently down.
  external void addClickTrampoline(
      String name, Function callback, dynamic callbackContext,
      [dynamic callbackArgs1,
      dynamic callbackArgs2,
      dynamic callbackArgs3,
      dynamic callbackArgs4,
      dynamic callbackArgs5]);

  /// The Pointer is considered justPressed if the time it was pressed onto the touchscreen or clicked is less than justPressedRate.
  /// Note that calling justPressed doesn't reset the pressed status of the Pointer, it will return `true` for as long as the duration is valid.
  /// If you wish to check if the Pointer was pressed down just once then see the Sprite.events.onInputDown event.
  external bool justPressed([num duration]);

  /// The Pointer is considered justReleased if the time it left the touchscreen is less than justReleasedRate.
  /// Note that calling justReleased doesn't reset the pressed status of the Pointer, it will return `true` for as long as the duration is valid.
  /// If you wish to check if the Pointer was released just once then see the Sprite.events.onInputUp event.
  external bool justReleased([num duration]);

  /// Called when the Pointer leaves the target area.
  external void leave(dynamic event);

  /// Called when the Pointer is moved.
  external void move(dynamic event, [bool fromClick]);

  /// Resets the Pointer properties. Called by InputManager.reset when you perform a State change.
  external void reset();

  /// Resets the states of all the button booleans.
  external void resetButtons();

  /// Resets the movementX and movementY properties. Use in your update handler after retrieving the values.
  external void resetMovement();

  /// Called when the Pointer is pressed onto the touchscreen.
  external void start(dynamic event);

  /// Called when the Pointer leaves the touchscreen.
  external void stop(dynamic event);

  /// This will change the `Pointer.targetObject` object to be the one provided.
  /// This allows you to have fine-grained control over which object the Pointer is targeting.
  /// Note that even if you set a new Target here, it is still able to be replaced by any other valid
  /// target during the next Pointer update.
  external void swapTarget(InputHandler newTarget, [bool silent]);

  /// Called by the Input Manager.
  external void update();

  /// Called when the event.buttons property changes from zero.
  /// Contains a button bitmask.
  external void updateButtons(MouseEvent event);
}

/// Creates a new Polygon.
/// The points can be set from a variety of formats:
/// - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
/// - An array of objects with public x/y properties: `[obj1, obj2, ...]`
/// - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
/// - As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`
/// - As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`
/// - As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`
@JS("Phaser.Polygon")
class Polygon {
  // @Ignore
  Polygon.fakeConstructor$();

  /// Creates a new Polygon.
  /// The points can be set from a variety of formats:
  /// - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
  /// - An array of objects with public x/y properties: `[obj1, obj2, ...]`
  /// - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
  /// - As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`
  /// - As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`
  /// - As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`
  /*external factory Polygon(List<Point>|List<num> points);*/
  /// Creates a new Polygon.
  /// The points can be set from a variety of formats:
  /// - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
  /// - An array of objects with public x/y properties: `[obj1, obj2, ...]`
  /// - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
  /// - As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`
  /// - As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`
  /// - As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`
  /*external factory Polygon([Point points1, Point points2, Point points3, Point points4, Point points5]);*/
  /// Creates a new Polygon.
  /// The points can be set from a variety of formats:
  /// - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
  /// - An array of objects with public x/y properties: `[obj1, obj2, ...]`
  /// - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
  /// - As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`
  /// - As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`
  /// - As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`
  /*external factory Polygon([num points1, num points2, num points3, num points4, num points5]);*/
  external factory Polygon(List<dynamic> /*List<Point>|List<num>*/ points);

  /// The area of this Polygon.
  external num get area;
  external set area(num v);

  /// Has this Polygon been flattened by a call to `Polygon.flatten` ?
  external bool get flattened;
  external set flattened(bool v);

  /// Sets and modifies the points of this polygon.
  /// See [Phaser.Polygon#setTo setTo] for the different kinds of arrays formats that can be assigned. The array of vertex points.
  external List<dynamic> /*List<num>|List<Point>*/ get points;
  external set points(List<dynamic> /*List<num>|List<Point>*/ v);

  /// The base object type.
  external num get type;
  external set type(num v);

  /// Creates a copy of the given Polygon.
  /// This is a deep clone, the resulting copy contains new Phaser.Point objects
  external Polygon clone(Polygon output);

  /// Checks whether the x and y coordinates are contained within this polygon.
  external bool contains(num x, num y);

  /// Flattens this Polygon so the points are a sequence of numbers.
  /// Any Point objects found are removed and replaced with two numbers.
  /// Also sets the Polygon.flattened property to `true`.
  external Polygon flatten();

  /// Sets this Polygon to the given points.
  /// The points can be set from a variety of formats:
  /// - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
  /// - An array of objects with public x/y properties: `[obj1, obj2, ...]`
  /// - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
  /// - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
  /// - As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`
  /// - As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`
  /// - As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`
  /// `setTo` may also be called without any arguments to remove all points.
  /*external void setTo(List<Point>|List<num> points);*/
  /// Sets this Polygon to the given points.
  /// The points can be set from a variety of formats:
  /// - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
  /// - An array of objects with public x/y properties: `[obj1, obj2, ...]`
  /// - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
  /// - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
  /// - As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`
  /// - As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`
  /// - As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`
  /// `setTo` may also be called without any arguments to remove all points.
  /*external void setTo(
    [Point points1,
    Point points2,
    Point points3,
    Point points4,
    Point points5]);*/
  /// Sets this Polygon to the given points.
  /// The points can be set from a variety of formats:
  /// - An array of Point objects: `[new Phaser.Point(x1, y1), ...]`
  /// - An array of objects with public x/y properties: `[obj1, obj2, ...]`
  /// - An array of paired numbers that represent point coordinates: `[x1,y1, x2,y2, ...]`
  /// - An array of arrays with two elements representing x/y coordinates: `[[x1, y1], [x2, y2], ...]`
  /// - As separate Point arguments: `setTo(new Phaser.Point(x1, y1), ...)`
  /// - As separate objects with public x/y properties arguments: `setTo(obj1, obj2, ...)`
  /// - As separate arguments representing point coordinates: `setTo(x1,y1, x2,y2, ...)`
  /// `setTo` may also be called without any arguments to remove all points.
  /*external void setTo(
    [num points1, num points2, num points3, num points4, num points5]);*/
  external void setTo(List<dynamic> /*List<Point>|List<num>*/ points);

  /// Export the points as an array of flat numbers, following the sequence [ x,y, x,y, x,y ]
  external List<num> toNumberArray([List<num> output]);
}

/// A QuadTree implementation. The original code was a conversion of the Java code posted to GameDevTuts.
/// However I've tweaked it massively to add node indexing, removed lots of temp. var creation and significantly increased performance as a result.
/// Original version at https://github.com/timohausmann/quadtree-js/
@JS("Phaser.QuadTree")
class QuadTree {
  // @Ignore
  QuadTree.fakeConstructor$();

  /// A QuadTree implementation. The original code was a conversion of the Java code posted to GameDevTuts.
  /// However I've tweaked it massively to add node indexing, removed lots of temp. var creation and significantly increased performance as a result.
  /// Original version at https://github.com/timohausmann/quadtree-js/
  external factory QuadTree(num x, num y, num width, num height,
      [num maxObject, num maxLevels, num level]);

  /// Object that contains the quadtree bounds.
  external dynamic
      /*{
            x: number;
            y: number;
            width: number;
            height: number;
            subWidth: number;
            subHeight: number;
            right: number;
            bottom: number;
        }*/
      get bounds;
  external set bounds(
      dynamic /*{
            x: number;
            y: number;
            width: number;
            height: number;
            subWidth: number;
            subHeight: number;
            right: number;
            bottom: number;
        }*/
      v);

  /// The current level.
  external num get level;
  external set level(num v);

  /// The maximum number of objects per node.
  /// Default: 10
  external num get maxObjects;
  external set maxObjects(num v);

  /// The maximum number of levels to break down to.
  /// Default: 4
  external num get maxLevels;
  external set maxLevels(num v);

  /// Array of quadtree children.
  external List<dynamic> get objects;
  external set objects(List<dynamic> v);

  /// Array of associated child nodes.
  external List<dynamic> get nodes;
  external set nodes(List<dynamic> v);

  /// Clear the quadtree.
  external void clear();

  /// Determine which node the object belongs to.
  external num getIndex(dynamic rect);

  /// Insert the object into the node. If the node exceeds the capacity, it will split and add all objects to their corresponding subnodes.
  external void insert(dynamic body);

  /// Populates this quadtree with the children of the given Group. In order to be added the child must exist and have a body property.
  external void populate(Group group);

  /// Handler for the populate method.
  external void populateHandler(Sprite sprite);

  /// Resets the QuadTree.
  external void reset(num x, num y, num width, num height,
      [num maxObject, num maxLevels, num level]);

  /// Return all objects that could collide with the given Sprite or Rectangle.
  external List<dynamic> retrieve(dynamic source);

  /// Split the node into 4 subnodes
  external void split();
}

/// An extremely useful repeatable random data generator.
/// Based on Nonsense by Josh Faul https://github.com/jocafa/Nonsense.
/// The random number genererator is based on the Alea PRNG, but is modified.
/// - https://github.com/coverslide/node-alea
/// - https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
/// - http://baagoe.org/en/wiki/Better_random_numbers_for_javascript (original, perm. 404)
@JS("Phaser.RandomDataGenerator")
class RandomDataGenerator {
  // @Ignore
  RandomDataGenerator.fakeConstructor$();

  /// An extremely useful repeatable random data generator.
  /// Based on Nonsense by Josh Faul https://github.com/jocafa/Nonsense.
  /// The random number genererator is based on the Alea PRNG, but is modified.
  /// - https://github.com/coverslide/node-alea
  /// - https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
  /// - http://baagoe.org/en/wiki/Better_random_numbers_for_javascript (original, perm. 404)
  external factory RandomDataGenerator(
      [dynamic /*List<dynamic>|String*/ seeds]);

  /// Returns a random angle between -180 and 180.
  external num angle();

  /// Returns a random integer between and including min and max.
  /// This method is an alias for RandomDataGenerator.integerInRange.
  external num between(num min, num max);

  /// Returns a random real number between 0 and 1.
  external num frac();

  /// Returns a random integer between 0 and 2^32.
  external num integer();

  /// Returns a random integer between and including min and max.
  external num integerInRange(num min, num max);

  /// Returns a random real number between -1 and 1.
  external num normal();

  /// Returns a random member of `array`.
  external dynamic/*=T*/ pick/*<T>*/(List<dynamic/*=T*/ > ary);

  /// Returns a random real number between 0 and 2^32.
  external num real();

  /// Returns a random real number between min and max.
  external num realInRange(num min, num max);

  /// Returns a sign to be used with multiplication operator.
  external num sign();

  /// Reset the seed of the random data generator.
  /// _Note_: the seed array is only processed up to the first `undefined` (or `null`) value, should such be present.
  external void sow(List<dynamic> seeds);

  /// Gets or Sets the state of the generator. This allows you to retain the values
  /// that the generator is using between games, i.e. in a game save file.
  /// To seed this generator with a previously saved state you can pass it as the
  /// `seed` value in your game config, or call this method directly after Phaser has booted.
  /// Call this method with no parameters to return the current state.
  /// If providing a state it should match the same format that this method
  /// returns, which is a string with a header `!rnd` followed by the `c`,
  /// `s0`, `s1` and `s2` values respectively, each comma-delimited.
  external String state([String state]);

  /// Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.
  external num timestamp(num min, num max);

  /// Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368
  external String uuid();

  /// Returns a random member of `array`, favoring the earlier entries.
  external dynamic/*=T*/ weightedPick/*<T>*/(List<dynamic/*=T*/ > ary);
}

/// Creates a new Rectangle object with the top-left corner specified by the x and y parameters and with the specified width and height parameters.
/// If you call this function without parameters, a Rectangle with x, y, width, and height properties set to 0 is created.
@JS("Phaser.Rectangle")
class Rectangle {
  // @Ignore
  Rectangle.fakeConstructor$();

  /// Creates a new Rectangle object with the top-left corner specified by the x and y parameters and with the specified width and height parameters.
  /// If you call this function without parameters, a Rectangle with x, y, width, and height properties set to 0 is created.
  external factory Rectangle(num x, num y, num width, num height);

  /// The sum of the y and height properties. Changing the bottom property of a Rectangle object has no effect on the x, y and width properties, but does change the height property.
  external num get bottom;
  external set bottom(num v);

  /// The location of the Rectangles bottom right corner as a Point object. Gets or sets the location of the Rectangles bottom right corner as a Point object.
  external PhaserPoint get bottomRight;
  external set bottomRight(Point v);

  /// The location of the Rectangles bottom left corner as a Point object. Gets or sets the location of the Rectangles bottom left corner as a Point object.
  external PhaserPoint get bottomLeft;
  external set bottomLeft(Point v);

  /// The x coordinate of the center of the Rectangle.
  external num get centerX;
  external set centerX(num v);

  /// The y coordinate of the center of the Rectangle.
  external num get centerY;
  external set centerY(num v);

  /// Determines whether or not this Rectangle object is empty. A Rectangle object is empty if its width or height is less than or equal to 0.
  /// If set to true then all of the Rectangle properties are set to 0. Gets or sets the Rectangles empty state.
  external bool get empty;
  external set empty(bool v);

  /// Half of the height of the Rectangle.
  external num get halfHeight;
  external set halfHeight(num v);

  /// Half of the width of the Rectangle.
  external num get halfWidth;
  external set halfWidth(num v);

  /// The height of the Rectangle. This value should never be set to a negative.
  external num get height;
  external set height(num v);

  /// The x coordinate of the left of the Rectangle. Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.
  external num get left;
  external set left(num v);

  /// The perimeter size of the Rectangle. This is the sum of all 4 sides.
  external num get perimeter;
  external set perimeter(num v);

  /// A random value between the left and right values (inclusive) of the Rectangle.
  external num get randomX;
  external set randomX(num v);

  /// A random value between the top and bottom values (inclusive) of the Rectangle.
  external num get randomY;
  external set randomY(num v);

  /// The sum of the x and width properties. Changing the right property of a Rectangle object has no effect on the x, y and height properties, however it does affect the width property.
  external num get right;
  external set right(num v);

  /// The y coordinate of the top of the Rectangle. Changing the top property of a Rectangle object has no effect on the x and width properties.
  /// However it does affect the height property, whereas changing the y value does not affect the height property.
  external num get top;
  external set top(num v);

  /// The location of the Rectangles top left corner as a Point object.
  external PhaserPoint get topLeft;
  external set topLeft(Point v);

  /// The location of the Rectangles top right corner as a Point object. The location of the Rectangles top left corner as a Point object.
  external PhaserPoint get topRight;
  external set topRight(Point v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// The volume of the Rectangle derived from width * height.
  external num get volume;
  external set volume(num v);

  /// The width of the Rectangle. This value should never be set to a negative.
  external num get width;
  external set width(num v);

  /// The x coordinate of the top-left corner of the Rectangle.
  external num get x;
  external set x(num v);

  /// The y coordinate of the top-left corner of the Rectangle.
  external num get y;
  external set y(num v);

  /// Calculates the Axis Aligned Bounding Box (or aabb) from an array of points.
  external static Rectangle aabb(List<Point> points, [Rectangle out]);

  /// Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.
  /*external static Rectangle clone(Rectangle a, [Rectangle output]);*/
  /// Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.
  /*external Rectangle clone(Rectangle output);*/
  external Rectangle clone(Rectangle a_output, [Rectangle output]);
  /*external static bool contains(Rectangle a, num x, num y);*/
  /// Determines whether the specified coordinates are contained within the region defined by this Rectangle object.
  /*external bool contains(num x, num y);*/
  external bool contains(dynamic /*Rectangle|num*/ a_x, num x_y, [num y]);
  external static bool containsPoint(Rectangle a, Point point);
  external static bool containsRaw(
      num rx, num ry, num rw, num rh, num x, num y);
  /*external static bool containsRect(Rectangle a, Rectangle b);*/
  /// Determines whether the first Rectangle object is fully contained within the second Rectangle object.
  /// A Rectangle object is said to contain another if the second Rectangle object falls entirely within the boundaries of the first.
  /*external bool containsRect(Rectangle b);*/
  external bool containsRect(Rectangle a_b, [Rectangle b]);
  external static Rectangle createFromBounds(dynamic a, [Rectangle output]);
  /*external static bool equals(Rectangle a, Rectangle b);*/
  /// Determines whether the two Rectangles are equal.
  /// This method compares the x, y, width and height properties of each Rectangle.
  /*external bool equals(Rectangle b);*/
  external bool equals(Rectangle a_b, [Rectangle b]);
  /*external static Rectangle inflate(Rectangle a, num dx, num dy);*/
  /// Increases the size of the Rectangle object by the specified amounts. The center point of the Rectangle object stays the same, and its size increases to the left and right by the dx value, and to the top and the bottom by the dy value.
  /*external Rectangle inflate(num dx, num dy);*/
  external Rectangle inflate(dynamic /*Rectangle|num*/ a_dx, num dx_dy,
      [num dy]);
  external static Rectangle inflatePoint(Rectangle a, Point point);
  /*external static Rectangle intersection(Rectangle a, Rectangle b, [Rectangle out]);*/
  /// If the Rectangle object specified in the toIntersect parameter intersects with this Rectangle object, returns the area of intersection as a Rectangle object. If the Rectangles do not intersect, this method returns an empty Rectangle object with its properties set to 0.
  /*external Rectangle intersection(Rectangle b, Rectangle out);*/
  external Rectangle intersection(Rectangle a_b, Rectangle b_out,
      [Rectangle out]);
  /*external static bool intersects(Rectangle a, Rectangle b);*/
  /// Determines whether this Rectangle and another given Rectangle intersect with each other.
  /// This method checks the x, y, width, and height properties of the two Rectangles.
  /*external bool intersects(Rectangle b, num tolerance);*/
  external bool intersects(
      Rectangle a_b, dynamic /*Rectangle|num*/ b_tolerance);
  /*external static bool intersectsRaw(num left, num right, num top, num bottom, num tolerance);*/
  /// Determines whether the coordinates given intersects (overlaps) with this Rectangle.
  /*external bool intersectsRaw(
    num left, num right, num top, num bottom, num tolerance);*/
  external bool intersectsRaw(
      num left, num right, num top, num bottom, num tolerance);
  /*external static Point size(Rectangle a, [Point output]);*/
  /// The size of the Rectangle object, expressed as a Point object with the values of the width and height properties.
  /*external Point size([Point output]);*/
  external Point size([dynamic /*Rectangle|Point*/ a_output, Point output]);
  /*external static Rectangle union(Rectangle a, Rectangle b, [Rectangle out]);*/
  /// Adds two Rectangles together to create a new Rectangle object, by filling in the horizontal and vertical space between the two Rectangles.
  /*external Rectangle union(Rectangle b, [Rectangle out]);*/
  external Rectangle union(Rectangle a_b, [Rectangle b_out, Rectangle out]);
  external void ceil();
  external void ceilAll();
  external Rectangle centerOn(num x, num y);
  external Rectangle copyFrom(dynamic source);
  external Rectangle copyFromBounds(dynamic source);
  external dynamic copyTo(dynamic dest);
  external void floor();
  external void floorAll();
  external PhaserPoint getPoint(num position, Point out);
  external Rectangle offset(num dx, num dy);
  external Rectangle offsetPoint(Point point);
  external Point random([Point out]);
  external Rectangle resize(num width, num height);
  external Rectangle setTo(num x, num y, num width, num height);
  external Rectangle scale(num x, [num y]);
  external List<Line> sides([Line top, Line right, Line bottom, Line left]);
  external String toString();
}

/// A RenderTexture is a special texture that allows any displayObject to be rendered to it. It allows you to take many complex objects and
/// render them down into a single quad (on WebGL) which can then be used to texture other display objects with. A way of generating textures at run-time.
@JS("Phaser.RenderTexture")
class PhaserRenderTexture extends RenderTexture {
  // @Ignore
  PhaserRenderTexture.fakeConstructor$() : super.fakeConstructor$();

  /// A RenderTexture is a special texture that allows any displayObject to be rendered to it. It allows you to take many complex objects and
  /// render them down into a single quad (on WebGL) which can then be used to texture other display objects with. A way of generating textures at run-time.
  external factory PhaserRenderTexture(Game game,
      [num width,
      num height,
      String key,
      num /*enum Phaser.scaleModes*/ scaleMode,
      num resolution]);

  /// This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
  /// irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
  external get crop;
  external set crop(@checked dynamic v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// The key of the RenderTexture in the Cache, if stored there.
  external String get key;
  external set key(String v);

  /// Base Phaser object type.
  external num get type;
  external set type(num v);

  /// This function will draw the display object to the RenderTexture.
  /// In versions of Phaser prior to 2.4.0 the second parameter was a Phaser.Point object.
  /// This is now a Matrix allowing you much more control over how the Display Object is rendered.
  /// If you need to replicate the earlier behavior please use Phaser.RenderTexture.renderXY instead.
  /// If you wish for the displayObject to be rendered taking its current scale, rotation and translation into account then either
  /// pass `null`, leave it undefined or pass `displayObject.worldTransform` as the matrix value.
  external void render(@checked displayObject,
      [@checked matrix, bool clear]);

  /// This function will draw the display object to the RenderTexture at the given coordinates.
  /// When the display object is drawn it takes into account scale and rotation.
  /// If you don't want those then use RenderTexture.renderRawXY instead.
  external void renderXY(DisplayObject displayObject, num x, num y,
      [bool clear]);

  /// This function will draw the display object to the RenderTexture at the given coordinates.
  /// When the display object is drawn it doesn't take into account scale, rotation or translation.
  /// If you need those then use RenderTexture.renderXY instead.
  external void renderRawXY(DisplayObject displayObject, num x, num y,
      [bool clear]);
}

/// Abstracts away the use of RAF or setTimeOut for the core game update loop.
@JS("Phaser.RequestAnimationFrame")
class RequestAnimationFrame {
  // @Ignore
  RequestAnimationFrame.fakeConstructor$();

  /// Abstracts away the use of RAF or setTimeOut for the core game update loop.
  external factory RequestAnimationFrame(Game game, [bool forceSetTimeOut]);

  /// Tell Phaser to use setTimeOut even if raf is available.
  external bool get forceSetTimeOut;
  external set forceSetTimeOut(bool v);

  /// The currently running game.
  external Game get game;
  external set game(Game v);

  /// true if RequestAnimationFrame is running, otherwise false.
  external bool get isRunning;
  external set isRunning(bool v);

  /// Is the browser using requestAnimationFrame?
  external bool isRAF();

  /// Is the browser using setTimeout?
  external bool isSetTimeOut();

  /// Starts the requestAnimationFrame running or setTimeout if unavailable in browser
  external bool start();

  /// Stops the requestAnimationFrame from running.
  external void stop();

  /// The update method for the requestAnimationFrame
  external void updateRAF(num rafTime);

  /// The update method for the setTimeout.
  external void updateSetTimeout(num time);
}

/// A Retro Font is similar to a BitmapFont, in that it uses a texture to render the text. However unlike a BitmapFont every character in a RetroFont
/// is the same size. This makes it similar to a sprite sheet. You typically find font sheets like this from old 8/16-bit games and demos.
@JS("Phaser.RetroFont")
class RetroFont extends PhaserRenderTexture {
  // @Ignore
  RetroFont.fakeConstructor$() : super.fakeConstructor$();

  /// A Retro Font is similar to a BitmapFont, in that it uses a texture to render the text. However unlike a BitmapFont every character in a RetroFont
  /// is the same size. This makes it similar to a sprite sheet. You typically find font sheets like this from old 8/16-bit games and demos.
  external factory RetroFont(Game game, String key, num characterWidth,
      num characterHeight, String chars,
      [num charsPerRow, num xSpacing, num ySpacing, num xOffset, num yOffset]);

  /// Align each line of multi-line text in the center.
  external static String get ALIGN_CENTER;
  external static set ALIGN_CENTER(String v);

  /// Align each line of multi-line text to the left.
  external static String get ALIGN_LEFT;
  external static set ALIGN_LEFT(String v);

  /// Align each line of multi-line text to the right.
  external static String get ALIGN_RIGHT;
  external static set ALIGN_RIGHT(String v);

  /// Text Set 1 =  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
  external static String get TEXT_SET1;
  external static set TEXT_SET1(String v);

  /// Text Set 2 =  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ
  external static String get TEXT_SET2;
  external static set TEXT_SET2(String v);

  /// Text Set 3 = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789
  external static String get TEXT_SET3;
  external static set TEXT_SET3(String v);

  /// Text Set 4 = ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789
  external static String get TEXT_SET4;
  external static set TEXT_SET4(String v);

  /// Text Set 5 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789
  external static String get TEXT_SET5;
  external static set TEXT_SET5(String v);

  /// Text Set 6 = ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789"(),-.'
  external static String get TEXT_SET6;
  external static set TEXT_SET6(String v);

  /// Text Set 7 = AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW")28FLRX-'39
  external static String get TEXT_SET7;
  external static set TEXT_SET7(String v);

  /// Text Set 8 = 0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ
  external static String get TEXT_SET8;
  external static set TEXT_SET8(String v);

  /// Text Set 9 = ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'"?!
  external static String get TEXT_SET9;
  external static set TEXT_SET9(String v);

  /// Text Set 10 = ABCDEFGHIJKLMNOPQRSTUVWXYZ
  external static String get TEXT_SET10;
  external static set TEXT_SET10(String v);

  /// Text Set 11 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,"-+!?()':;0123456789
  external static String get TEXT_SET11;
  external static set TEXT_SET11(String v);

  /// Alignment of the text when multiLine = true or a fixedWidth is set. Set to RetroFont.ALIGN_LEFT (default), RetroFont.ALIGN_RIGHT or RetroFont.ALIGN_CENTER.
  external String get align;
  external set align(String v);

  /// Automatically convert any text to upper case. Lots of old bitmap fonts only contain upper-case characters, so the default is true.
  /// Default: true
  external bool get autoUpperCase;
  external set autoUpperCase(bool v);

  /// The height of each character in the font set.
  external num get characterHeight;
  external set characterHeight(num v);

  /// The number of characters per row in the font set.
  external num get characterPerRow;
  external set characterPerRow(num v);

  /// If the characters in the font set have horizontal spacing between them set the required amount here.
  external num get characterSpacingX;
  external set characterSpacingX(num v);

  /// If the characters in the font set have vertical spacing between them set the required amount here.
  external num get characterSpacingY;
  external set characterSpacingY(num v);

  /// The width of each character in the font set.
  external num get characterWidth;
  external set characterWidth(num v);

  /// Adds horizontal spacing between each character of the font, in pixels.
  external num get customSpacingX;
  external set customSpacingX(num v);

  /// Adds vertical spacing between each line of multi-line text, set in pixels.
  external num get customSpacingY;
  external set customSpacingY(num v);

  /// If you need this RetroFont image to have a fixed width you can set the width in this value.
  /// If text is wider than the width specified it will be cropped off.
  external num get fixedWidth;
  external set fixedWidth(num v);

  /// A reference to the image stored in the Game.Cache that contains the font.
  external Image get fontSet;
  external set fontSet(Image v);

  /// The FrameData representing this Retro Font.
  external FrameData get frameData;
  external set frameData(FrameData v);

  /// If set to true all carriage-returns in text will form new lines (see align). If false the font will only contain one single line of text (the default)
  external bool get multiLine;
  external set multiLine(bool v);

  /// If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.
  external num get offsetX;
  external set offsetX(num v);

  /// If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.
  external num get offsetY;
  external set offsetY(num v);

  /// Sets if the stamp is smoothed or not.
  external bool get smoothed;
  external set smoothed(bool v);

  /// The image that is stamped to the RenderTexture for each character in the font.
  external Image get stamp;
  external set stamp(Image v);

  /// Set this value to update the text in this sprite. Carriage returns are automatically stripped out if multiLine is false. Text is converted to upper case if autoUpperCase is true.
  external String get text;
  external set text(String v);

  /// Updates the texture with the new text.
  external void buildRetroFontText();

  /// Works out the longest line of text in _text and returns its length
  external num getLongestLine();

  /// Internal function that takes a single line of text (2nd parameter) and pastes it into the BitmapData at the given coordinates.
  /// Used by getLine and getMultiLine
  external void pasteLine(String line, num x, num y, num customSpacingX);

  /// Internal helper function that removes all unsupported characters from the _text String, leaving only characters contained in the font set.
  external String removeUnsupportedCharacters([bool stripCR]);

  /// If you need this RetroFont to have a fixed width and custom alignment you can set the width here.
  /// If text is wider than the width specified it will be cropped off.
  external void setFixedWidth(num width, [String lineAlignment]);

  /// A helper function that quickly sets lots of variables at once, and then updates the text.
  external void setText(String content,
      [bool multiLine,
      num characterSpacing,
      num lineSpacing,
      String lineAlignment,
      bool allowLowerCase]);

  /// Updates the x and/or y offset that the font is rendered from. This updates all of the texture frames, so be careful how often it is called.
  /// Note that the values given for the x and y properties are either ADDED to or SUBTRACTED from (if negative) the existing offsetX/Y values of the characters.
  /// So if the current offsetY is 8 and you want it to start rendering from y16 you would call updateOffset(0, 8) to add 8 to the current y offset.
  external void updateOffset([num x, num y]);
}

/// A Rope is a Sprite that has a repeating texture.
/// The texture will automatically wrap on the edges as it moves.
/// Please note that Ropes cannot have an input handler.
@JS("Phaser.Rope")
class PhaserRope extends Rope {
  // @Ignore
  PhaserRope.fakeConstructor$() : super.fakeConstructor$();

  /// A Rope is a Sprite that has a repeating texture.
  /// The texture will automatically wrap on the edges as it moves.
  /// Please note that Ropes cannot have an input handler.
  external factory PhaserRope(Game game, num x, num y,
      dynamic /*String|RenderTexture|BitmapData|Texture|Video*/ key,
      [dynamic /*String|num*/ frame, List<Point> points]);

  /// The angle property is the rotation of the Game Object in *degrees* from its original orientation.
  /// Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.
  /// Values outside this range are added to or subtracted from 360 to obtain a value within the range.
  /// For example, the statement player.angle = 450 is the same as player.angle = 90.
  /// If you wish to work in radians instead of degrees you can use the property `rotation` instead.
  /// Working in radians is slightly faster as it doesn't have to perform any calculations.
  external num get angle;
  external set angle(num v);

  /// If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.
  /// Through it you can create, play, pause and stop animations.
  external AnimationManager get animations;
  external set animations(AnimationManager v);

  /// A useful flag to control if the Game Object is alive or dead.
  /// This is set automatically by the Health components `damage` method should the object run out of health.
  /// Or you can toggle it via your game code.
  /// This property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.
  /// However you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.
  /// Default: true
  external bool get alive;
  external set alive(bool v);

  /// A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.
  /// If it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.
  /// This keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.
  /// This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,
  /// or you have tested performance and find it acceptable.
  external bool get autoCull;
  external set autoCull(bool v);

  /// `body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated
  /// properties and methods via it.
  /// By default Game Objects won't add themselves to any physics system and their `body` property will be `null`.
  /// To enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object
  /// and `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.
  /// You can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.
  /// Important: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5,
  /// so the physics body is centered on the Game Object.
  /// If you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.
  external dynamic /*Body|P2_Body|Ninja_Body|dynamic*/ get body;
  external set body(dynamic /*Body|P2_Body|Ninja_Body|dynamic*/ v);

  /// The sum of the y and height properties.
  /// This is the same as `y + height - offsetY`.
  external num get bottom;
  external set bottom(num v);

  /// The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.
  /// The values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.
  external PhaserPoint get cameraOffset;
  external set cameraOffset(Point v);

  /// If this is set to `true` the Game Object checks if it is within the World bounds each frame.
  /// When it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.
  /// If it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.
  /// It also optionally kills the Game Object if `outOfBoundsKill` is `true`.
  /// When `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.
  /// This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,
  /// or you have tested performance and find it acceptable.
  external bool get checkWorldBounds;
  external set checkWorldBounds(bool v);

  /// The Rectangle used to crop the texture this Game Object uses.
  /// Set this property via `crop`.
  /// If you modify this property directly you must call `updateCrop` in order to have the change take effect.
  external Rectangle get cropRect;
  external set cropRect(Rectangle v);

  /// The components this Game Object has installed.
  external dynamic get components;
  external set components(dynamic v);

  /// Does this texture require a custom render call? (as set by BitmapData, Video, etc)
  external bool get customRender;
  external set customRender(bool v);

  /// A debug flag designed for use with `Game.enableStep`.
  external bool get debug;
  external set debug(bool v);

  /// Returns the delta x value. The difference between world.x now and in the previous frame.
  /// The value will be positive if the Game Object has moved to the right or negative if to the left.
  external num get deltaX;
  external set deltaX(num v);

  /// Returns the delta y value. The difference between world.y now and in the previous frame.
  /// The value will be positive if the Game Object has moved down or negative if up.
  external num get deltaY;
  external set deltaY(num v);

  /// Returns the delta z value. The difference between rotation now and in the previous frame. The delta value.
  external num get deltaZ;
  external set deltaZ(num v);

  /// As a Game Object runs through its destroy method this flag is set to true,
  /// and can be checked in any sub-systems or plugins it is being destroyed from.
  external bool get destroyPhase;
  external set destroyPhase(bool v);

  /// Controls if this Game Object is processed by the core game loop.
  /// If this Game Object has a physics body it also controls if its physics body is updated or not.
  /// When `exists` is set to `false` it will remove its physics body from the physics world if it has one.
  /// It also toggles the `visible` property to false as well.
  /// Setting `exists` to true will add its physics body back in to the physics world, if it has one.
  /// It will also set the `visible` property to `true`.
  external bool get exists;
  external set exists(bool v);

  /// All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this
  /// Game Object, or any of its components.
  external Events get events;
  external set events(Events v);

  /// A Game Object that is "fixed" to the camera is rendered at a given x/y offsets from the top left of the camera. The offsets
  /// are stored in the `cameraOffset` property, which is initialized with the current object coordinates.
  /// The values are adjusted at the rendering stage, overriding the Game Objects actual world position.
  /// The end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world
  /// the camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times
  /// regardless where in the world the camera is.
  /// Note that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.
  /// Be careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.
  external bool get fixedToCamera;
  external set fixedToCamera(bool v);

  /// Gets or sets the current frame index of the texture being used to render this Game Object.
  /// To change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,
  /// for example: `player.frame = 4`.
  /// If the frame index given doesn't exist it will revert to the first frame found in the texture.
  /// If you are using a texture atlas then you should use the `frameName` property instead.
  /// If you wish to fully replace the texture being used see `loadTexture`.
  external dynamic /*String|num*/ get frame;
  external set frame(dynamic /*String|num*/ v);

  /// Gets or sets the current frame name of the texture being used to render this Game Object.
  /// To change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use,
  /// for example: `player.frameName = "idle"`.
  /// If the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.
  /// If you are using a sprite sheet then you should use the `frame` property instead.
  /// If you wish to fully replace the texture being used see `loadTexture`.
  external String get frameName;
  external set frameName(String v);

  /// A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.
  /// This property is mostly used internally by the physics systems, but is exposed for the use of plugins.
  external bool get fresh;
  external set fresh(bool v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// Checks if the Game Objects bounds intersect with the Game Camera bounds.
  /// Returns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.
  external bool get inCamera;
  external set inCamera(bool v);
  external InputHandler get input;
  external set input(InputHandler v);
  external bool get inputEnabled;
  external set inputEnabled(bool v);

  /// Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.
  external bool get inWorld;
  external set inWorld(bool v);

  /// The left coordinate of the Game Object.
  /// This is the same as `x - offsetX`.
  external num get left;
  external set left(num v);

  /// The lifespan allows you to give a Game Object a lifespan in milliseconds.
  /// Once the Game Object is 'born' you can set this to a positive value.
  /// It is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.
  /// When it reaches zero it will call the `kill` method.
  /// Very handy for particles, bullets, collectibles, or any other short-lived entity.
  external num get lifespan;
  external set lifespan(num v);

  /// The key of the image or texture used by this Game Object during rendering.
  /// If it is a string it's the string used to retrieve the texture from the Phaser Image Cache.
  /// It can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
  /// If a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.
  /// If a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.
  external dynamic /*String|RenderTexture|BitmapData|Texture|Video*/ get key;
  external set key(dynamic /*String|RenderTexture|BitmapData|Texture|Video*/ v);

  /// A user defined name given to this Game Object.
  /// This value isn't ever used internally by Phaser, it is meant as a game level property.
  external String get name;
  external set name(String v);

  /// The amount the Game Object is visually offset from its x coordinate.
  /// This is the same as `width * anchor.x`.
  /// It will only be > 0 if anchor.x is not equal to zero.
  external num get offsetX;
  external set offsetX(num v);

  /// The amount the Game Object is visually offset from its y coordinate.
  /// This is the same as `height * anchor.y`.
  /// It will only be > 0 if anchor.y is not equal to zero.
  external num get offsetY;
  external set offsetY(num v);

  /// If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.
  external bool get outOfBoundsKill;
  external set outOfBoundsKill(bool v);

  /// Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object,
  /// which can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.
  /// This check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.
  /// Therefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.
  /// It should be fine for low-volume testing where physics isn't required.
  external bool overlap(
      dynamic /*Sprite|Image|TileSprite|Button|DisplayObject*/ displayObject);

  /// A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.
  /// You can set it directly to allow you to flag an object to be destroyed on its next update.
  /// This is extremely useful if you wish to destroy an object from within one of its own callbacks
  /// such as with Buttons or other Input events.
  external bool get pendingDestroy;
  external set pendingDestroy(bool v);
  external List<Point> get points;
  external set points(List<Point> v);

  /// The coordinates, in pixels, of this DisplayObject, relative to its parent container.
  /// The value of this property does not reflect any positioning happening further up the display list.
  /// To obtain that value please see the `worldPosition` property.
  external PhaserPoint get position;
  external set position(Point v);

  /// The position the Game Object was located in the previous frame.
  external PhaserPoint get previousPosition;
  external set previousPosition(Point v);

  /// The rotation the Game Object was in set to in the previous frame. Value is in radians.
  external num get previousRotation;
  external set previousRotation(num v);

  /// The right coordinate of the Game Object.
  /// This is the same as `x + width - offsetX`.
  external num get right;
  external set right(num v);

  /// The render order ID is used internally by the renderer and Input Manager and should not be modified.
  /// This property is mostly used internally by the renderers, but is exposed for the use of plugins.
  external num get renderOrderID;
  external set renderOrderID(num v);

  /// The segments that make up the rope body as an array of Phaser.Rectangles
  external List<Rectangle> get segments;
  external set segments(List<Rectangle> v);

  /// Enable or disable texture smoothing for this Game Object.
  /// It only takes effect if the Game Object is using an image based texture.
  /// Smoothing is enabled by default.
  external bool get smoothed;
  external set smoothed(bool v);

  /// The y coordinate of the Game Object.
  /// This is the same as `y - offsetY`.
  external num get top;
  external set top(num v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// The callback that will apply any scale limiting to the worldTransform.
  external Function get transformCallback;
  external set transformCallback(Function v);

  /// The context under which `transformCallback` is called.
  external dynamic get transformCallbackContext;
  external set transformCallbackContext(dynamic v);

  /// The minimum scale this Game Object will scale down to.
  /// It allows you to prevent a parent from scaling this Game Object lower than the given value.
  /// Set it to `null` to remove the limit.
  external PhaserPoint get scaleMin;
  external set scaleMin(Point v);

  /// The maximum scale this Game Object will scale up to.
  /// It allows you to prevent a parent from scaling this Game Object higher than the given value.
  /// Set it to `null` to remove the limit.
  external PhaserPoint get scaleMax;
  external set scaleMax(Point v);

  /// A Rope will call its updateAnimation function on each update loop if it has one. Set to a function if you'd like the rope to animate during the update phase. Set to false or null to remove it.
  external Function get updateAnimation;
  external set updateAnimation(Function v);

  /// The world coordinates of this Game Object in pixels.
  /// Depending on where in the display list this Game Object is placed this value can differ from `position`,
  /// which contains the x/y coordinates relative to the Game Objects parent.
  external PhaserPoint get world;
  external set world(Point v);

  /// The horizontal position of the DisplayObject, in pixels, relative to its parent.
  /// If you need the world position of the DisplayObject, use `DisplayObject.worldPosition` instead.
  external num get x;
  external set x(num v);

  /// The vertical position of the DisplayObject, in pixels, relative to its parent.
  /// If you need the world position of the DisplayObject, use `DisplayObject.worldPosition` instead.
  external num get y;
  external set y(num v);

  /// The z depth of this Game Object within its parent Group.
  /// No two objects in a Group can have the same z value.
  /// This value is adjusted automatically whenever the Group hierarchy changes.
  /// If you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.
  external num get z;
  external set z(num v);

  /// Brings this Game Object to the top of its parents display list.
  /// Visually this means it will render over the top of any old child in the same Group.
  /// If this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World,
  /// because the World is the root Group from which all Game Objects descend.
  external Rope bringToTop();

  /// Adjust scaling limits, if set, to this Game Object.
  external void checkTransform(Matrix wt);

  /// Crop allows you to crop the texture being used to display this Game Object.
  /// Setting a crop rectangle modifies the core texture frame. The Game Object width and height properties will be adjusted accordingly.
  /// Cropping takes place from the top-left and can be modified in real-time either by providing an updated rectangle object to this method,
  /// or by modifying `cropRect` property directly and then calling `updateCrop`.
  /// The rectangle object given to this method can be either a `Phaser.Rectangle` or any other object
  /// so long as it has public `x`, `y`, `width`, `height`, `right` and `bottom` properties.
  /// A reference to the rectangle is stored in `cropRect` unless the `copy` parameter is `true`,
  /// in which case the values are duplicated to a local object.
  external void crop(Rectangle rect, [bool copy]);

  /// Destroy this DisplayObject.
  /// Removes any cached sprites, sets renderable flag to false, and nulls filters, bounds and mask.
  /// Also iteratively calls `destroy` on any children.
  external void destroy([bool destroyChildren]);

  /// Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.
  /// It will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.
  /// Note that killing a Game Object is a way for you to quickly recycle it in an object pool,
  /// it doesn't destroy the object or free it up from memory.
  /// If you don't need this Game Object any more you should call `destroy` instead.
  external Rope kill();

  /// Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.
  /// If your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.
  /// You should only use `loadTexture` if you want to replace the base texture entirely.
  /// Calling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.
  /// You can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite.
  /// Doing this then sets the key to be the `frame` argument (the frame is set to zero).
  /// This allows you to create sprites using `load.image` during development, and then change them
  /// to use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS'
  /// and swapping it to be the key of the atlas data.
  /// Note: You cannot use a RenderTexture as a texture for a TileSprite.
  external void loadTexture(
      dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ key,
      [dynamic /*String|num*/ frame,
      bool stopAnimation]);

  /// Moves this Game Object up one place in its parents display list.
  /// This call has no effect if the Game Object is already at the top of the display list.
  /// If this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World,
  /// because the World is the root Group from which all Game Objects descend.
  external Rope moveUp();

  /// Moves this Game Object down one place in its parents display list.
  /// This call has no effect if the Game Object is already at the bottom of the display list.
  /// If this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World,
  /// because the World is the root Group from which all Game Objects descend.
  external Rope moveDown();

  /// Plays an Animation.
  /// The animation should have previously been created via `animations.add`.
  /// If the animation is already playing calling this again won't do anything.
  /// If you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.
  external Animation play(String name,
      [num frameRate, bool loop, bool killOnComplete]);

  /// Automatically called by World.preUpdate.
  external void preUpdate();

  /// Internal method called by the World postUpdate cycle.
  external void postUpdate();

  /// Resets the Rope. This places the Rope at the given x/y world coordinates and then
  /// sets alive, exists, visible and renderable all to true. Also resets the outOfBounds state.
  /// If the Rope has a physics body that too is reset.
  external Rope reset(num x, num y, [num health]);

  /// Resizes the Frame dimensions that the Game Object uses for rendering.
  /// You shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData
  /// it can be useful to adjust the dimensions directly in this way.
  external void resizeFrame(dynamic parent, num width, num height);

  /// Resets the texture frame dimensions that the Game Object uses for rendering.
  external void resetFrame();

  /// Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.
  /// A resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.
  /// It will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.
  external Rope revive([num health]);

  /// Sends this Game Object to the bottom of its parents display list.
  /// Visually this means it will render below all other children in the same Group.
  /// If this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World,
  /// because the World is the root Group from which all Game Objects descend.
  external Rope sendToBack();

  /// Sets the texture frame the Game Object uses for rendering.
  /// This is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.
  external void setFrame(Frame frame);

  /// Sets the scaleMin and scaleMax values. These values are used to limit how far this Game Object will scale based on its parent.
  /// For example if this Game Object has a `minScale` value of 1 and its parent has a `scale` value of 0.5, the 0.5 will be ignored
  /// and the scale value of 1 will be used, as the parents scale is lower than the minimum scale this Game Object should adhere to.
  /// By setting these values you can carefully control how Game Objects deal with responsive scaling.
  /// If only one parameter is given then that value will be used for both scaleMin and scaleMax:
  /// `setScaleMinMax(1)` = scaleMin.x, scaleMin.y, scaleMax.x and scaleMax.y all = 1
  /// If only two parameters are given the first is set as scaleMin.x and y and the second as scaleMax.x and y:
  /// `setScaleMinMax(0.5, 2)` = scaleMin.x and y = 0.5 and scaleMax.x and y = 2
  /// If you wish to set `scaleMin` with different values for x and y then either modify Game Object.scaleMin directly,
  /// or pass `null` for the `maxX` and `maxY` parameters.
  /// Call `setScaleMinMax(null)` to clear all previously set values.
  external void setScaleMinMax([num minX, num minY, num maxX, num maxY]);

  /// If you have set a crop rectangle on this Game Object via `crop` and since modified the `cropRect` property,
  /// or the rectangle it references, then you need to update the crop frame by calling this method.
  external void updateCrop();

  /// Override and use this function in your own custom objects to handle any update requirements you may have.
  external void update();
}

/// The Rounded Rectangle object is an area defined by its position and has nice rounded corners,
/// as indicated by its top-left corner point (x, y) and by its width and its height.
@JS("Phaser.RoundedRectangle")
class RoundedRectangle {
  // @Ignore
  RoundedRectangle.fakeConstructor$();

  /// The x coordinate of the top-left corner of the Rectangle.
  external num get x;
  external set x(num v);

  /// The y coordinate of the top-left corner of the Rectangle.
  external num get y;
  external set y(num v);

  /// The width of the Rectangle. This value should never be set to a negative.
  external num get width;
  external set width(num v);

  /// The height of the Rectangle. This value should never be set to a negative.
  external num get height;
  external set height(num v);

  /// The radius of the rounded corners.
  external num get radius;
  external set radius(num v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// Returns a new RoundedRectangle object with the same values for the x, y, width, height and
  /// radius properties as this RoundedRectangle object.
  external RoundedRectangle clone();

  /// Determines whether the specified coordinates are contained within the region defined by this Rounded Rectangle object.
  external bool contains(num x, num y);
}

/// Signals are what Phaser uses to handle events and event dispatching.
/// You can listen for a Signal by binding a callback / function to it.
/// This is done by using either `Signal.add` or `Signal.addOnce`.
/// For example you can listen for a touch or click event from the Input Manager
/// by using its `onDown` Signal:
/// `game.input.onDown.add(function() { ... });`
/// Rather than inline your function, you can pass a reference:
/// `game.input.onDown.add(clicked, this);`
/// `function clicked () { ... }`
/// In this case the second argument (`this`) is the context in which your function should be called.
/// Now every time the InputManager dispatches the `onDown` signal (or event), your function
/// will be called.
/// Multiple callbacks can be bound to the same signal.
/// They're ordered first by their `priority` arguments and then by the order in which they were added.
/// If a callback calls [Phaser.Signal#halt halt] or returns `false`, any remaining callbacks are skipped.
/// Very often a Signal will send arguments to your function.
/// This is specific to the Signal itself.
/// If you're unsure then check the documentation, or failing that simply do:
/// `Signal.add(function() { console.log(arguments); })`
/// and it will log all of the arguments your function received from the Signal.
/// Sprites have lots of default signals you can listen to in their Events class, such as:
/// `sprite.events.onKilled`
/// Which is called automatically whenever the Sprite is killed.
/// There are lots of other events, see the Events component for a list.
/// As well as listening to pre-defined Signals you can also create your own:
/// `var mySignal = new Phaser.Signal();`
/// This creates a new Signal. You can bind a callback to it:
/// `mySignal.add(myCallback, this);`
/// and then finally when ready you can dispatch the Signal:
/// `mySignal.dispatch(your arguments);`
/// And your callback will be invoked. See the dispatch method for more details.
@JS("Phaser.Signal")
class Signal {
  // @Ignore
  Signal.fakeConstructor$();

  /// Is the Signal active? Only active signals will broadcast dispatched events.
  /// Setting this property during a dispatch will only affect the next dispatch. To stop the propagation of a signal from a listener use [Phaser.Signal#halt halt].
  /// Default: true
  external bool get active;
  external set active(bool v);
  external Function get boundDispatch;
  external set boundDispatch(Function v);

  /// Memorize the previously dispatched event?
  /// If an event has been memorized it is automatically dispatched when a new listener is added with [Phaser.Signal#add add] or [Phaser.Signal#addOnce addOnce].
  /// Use [Phaser.Signal#forget forget] to clear any currently memorized event.
  external bool get memorize;
  external set memorize(bool v);

  /// Add an event listener for this signal.
  /// An event listener is a callback with a related context and priority.
  /// You can optionally provide extra arguments which will be passed to the callback after any internal parameters.
  /// For example: `Phaser.Key.onDown` when dispatched will send the Phaser.Key object that caused the signal as the first parameter.
  /// Any arguments you've specified after `priority` will be sent as well:
  /// `fireButton.onDown.add(shoot, this, 0, 'lazer', 100);`
  /// When onDown dispatches it will call the `shoot` callback passing it: `Phaser.Key, 'lazer', 100`.
  /// Where the first parameter is the one that Key.onDown dispatches internally and 'lazer',
  /// and the value 100 were the custom arguments given in the call to 'add'.
  /// If the callback calls [Phaser.Signal#halt halt] or returns `false`, any remaining callbacks bound to this Signal are skipped.
  external SignalBinding add(Function listener,
      [dynamic listenerContext,
      num priority,
      dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Add a one-time listener - the listener is automatically removed after the first execution.
  /// If there is as [Phaser.Signal#memorize memorized] event then it will be dispatched and
  /// the listener will be removed immediately.
  external SignalBinding addOnce(Function listener,
      [dynamic listenerContext,
      num priority,
      dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Dispatch / broadcast the event to all listeners.
  /// To create an instance-bound dispatch for this Signal, use [Phaser.Signal#boundDispatch boundDispatch].
  external void dispatch(
      [dynamic params1,
      dynamic params2,
      dynamic params3,
      dynamic params4,
      dynamic params5]);

  /// Dispose the signal - no more events can be dispatched.
  /// This removes all event listeners and clears references to external objects.
  /// Calling methods on a disposed objects results in undefined behavior.
  external void dispose();

  /// Forget the currently [Phaser.Signal#memorize memorized] event, if any.
  external void forget();

  /// Gets the total number of listeners attached to this Signal.
  external num getNumListeners();

  /// Stop propagation of the event, blocking the dispatch to next listener on the queue.
  /// This should be called only during event dispatch as calling it before/after dispatch won't affect another broadcast.
  /// See [Phaser.Signal#active active] to enable/disable the signal entirely.
  external void halt();

  /// Check if a specific listener is attached.
  external bool has(Function listener, [dynamic context]);

  /// Remove a single event listener.
  external Function remove(Function listener, [dynamic context]);

  /// Remove all event listeners.
  external void removeAll([dynamic context]);

  /// A string representation of the object.
  external String toString();
  external void validateListener(Function listener, String fnName);
}

/// Object that represents a binding between a Signal and a listener function.
/// This is an internal constructor and shouldn't be created directly.
/// Inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
@JS("Phaser.SignalBinding")
class SignalBinding {
  // @Ignore
  SignalBinding.fakeConstructor$();

  /// Object that represents a binding between a Signal and a listener function.
  /// This is an internal constructor and shouldn't be created directly.
  /// Inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.
  external factory SignalBinding(Signal signal, Function listener, bool isOnce,
      [dynamic listenerContext,
      num priority,
      dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// If binding is active and should be executed.
  /// Default: true
  external bool get active;
  external set active(bool v);

  /// The number of times the handler function has been called.
  external num get callCount;
  external set callCount(num v);

  /// Context on which listener will be executed (object that should represent the `this` variable inside listener function).
  external dynamic get context;
  external set context(dynamic v);

  /// Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute` (curried parameters).
  external List<dynamic> get params;
  external set params(List<dynamic> v);

  /// Call listener passing arbitrary parameters.
  /// If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.
  external void execute([List<dynamic> paramsArr]);

  /// Detach binding from signal.
  /// alias to: @see mySignal.remove(myBinding.getListener());
  external Function detach();
  external bool isBound();
  external bool isOnce();
  external Function getListener();
  external Signal getSignal();
  external String toString();
}

/// A single Phaser Gamepad
@JS("Phaser.SinglePad")
class SinglePad {
  // @Ignore
  SinglePad.fakeConstructor$();

  /// A single Phaser Gamepad
  external factory SinglePad(Game game, dynamic padParent);

  /// The context under which the callbacks are run.
  external dynamic get callbackContext;
  external set callbackContext(dynamic v);

  /// Whether or not this particular gamepad is connected or not.
  external bool get connected;
  external set connected(bool v);

  /// Dead zone for axis feedback - within this value you won't trigger updates.
  external num get deadZone;
  external set deadZone(num v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// The gamepad index as per browsers data
  external num get index;
  external set index(num v);

  /// This callback is invoked every time an axis is changed.
  external Function get onAxisCallback;
  external set onAxisCallback(Function v);

  /// This callback is invoked every time this gamepad is connected
  external Function get onConnectCallback;
  external set onConnectCallback(Function v);

  /// This callback is invoked every time this gamepad is disconnected
  external Function get onDisconnectCallback;
  external set onDisconnectCallback(Function v);

  /// This callback is invoked every time a button is pressed down.
  external Function get onDownCallback;
  external set onDownCallback(Function v);

  /// This callback is invoked every time a button is changed to a value where value > 0 and value < 1.
  external Function get onFloatCallback;
  external set onFloatCallback(Function v);

  /// This callback is invoked every time a gamepad button is released.
  external Function get onUpCallback;
  external set onUpCallback(Function v);

  /// Returns value of requested axis.
  external num axis(num axisCode);

  /// Add callbacks to this Gamepad to handle connect / disconnect / button down / button up / axis change / float value buttons.
  /// onConnectCallback, onDisconnectCallback, onDownCallback, onUpCallback, onAxisCallback, onFloatCallback
  external void addCallbacks(dynamic context, dynamic callbacks);

  /// Returns the value of a gamepad button. Intended mainly for cases when you have floating button values, for example
  /// analog trigger buttons on the XBOX 360 controller.
  external num buttonValue(num buttonCode);

  /// Gamepad connect function, should be called by Phaser.Gamepad.
  external void connect(dynamic rawPad);

  /// Destroys this object and associated callback references.
  external void destroy();

  /// Gamepad disconnect function, should be called by Phaser.Gamepad.
  external void disconnect();

  /// Gets a DeviceButton object from this controller to be stored and referenced locally.
  /// The DeviceButton object can then be polled, have events attached to it, etc.
  external DeviceButton getButton(num buttonCode);

  /// Returns true if the button is pressed down.
  external bool isDown(num buttonCode);

  /// Returns true if the button is not currently pressed.
  external bool isUp(num buttonCode);

  /// Returns the "just pressed" state of a button from this gamepad. Just pressed is considered true if the button was pressed down within the duration given (default 250ms).
  external bool justPressed(num buttonCode, [num duration]);

  /// Returns the "just released" state of a button from this gamepad. Just released is considered as being true if the button was released within the duration given (default 250ms).
  external bool justReleased(num buttonCode, [num duration]);

  /// Main update function called by Phaser.Gamepad.
  external void pollStatus();

  /// Handles changes in axis.
  external void processAxisChange(dynamic axisState);

  /// Handles button down press.
  external void processButtonDown(num buttonCode, dynamic value);

  /// Handles buttons with floating values (like analog buttons that acts almost like an axis but still registers like a button)
  external void processButtonFloat(num buttonCode, dynamic value);

  /// Handles button release.
  external void processButtonUp(num buttonCode, dynamic value);

  /// Reset all buttons/axes of this gamepad.
  external void reset();
}

/// The Sound class constructor.
@JS("Phaser.Sound")
class Sound {
  // @Ignore
  Sound.fakeConstructor$();

  /// The Sound class constructor.
  external factory Sound(Game game, String key,
      [num volume, bool loop, bool connect]);

  /// Boolean indicating whether the sound should start automatically.
  external bool get autoplay;
  external set autoplay(bool v);

  /// This will allow you to have multiple instances of this Sound playing at once. This is only useful when running under Web Audio, and we recommend you implement a local pooling system to not flood the sound channels.
  external bool get allowMultiple;
  external set allowMultiple(bool v);

  /// Reference to the AudioContext instance.
  external dynamic get context;
  external set context(dynamic v);

  /// The string ID of the currently playing marker, if any.
  external String get currentMarker;
  external set currentMarker(String v);

  /// The current time of sound playback in ms.
  external num get currentTime;
  external set currentTime(num v);

  /// Destroys this sound and all associated events and removes it from the SoundManager.
  /*external void destroy([bool remove]);*/
  /// Destroys this sound and all associated events and removes it from the SoundManager.
  /*external void destroy();*/
  external void destroy([bool remove]);
  external num get duration;
  external set duration(num v);
  external num get durationMS;
  external set durationMS(num v);
  external dynamic get externalNode;
  external set externalNode(dynamic v);
  external Tween get fadeTween;
  external set fadeTween(Tween v);
  external Game get game;
  external set game(Game v);
  external dynamic get gainNode;
  external set gainNode(dynamic v);
  external bool get isDecoded;
  external set isDecoded(bool v);
  external bool get isDecoding;
  external set isDecoding(bool v);
  external bool get isPlaying;
  external set isPlaying(bool v);
  external String get key;
  external set key(String v);
  external bool get loop;
  external set loop(bool v);
  external dynamic get markers;
  external set markers(dynamic v);
  external dynamic get masterGainNode;
  external set masterGainNode(dynamic v);
  external bool get mute;
  external set mute(bool v);
  external String get name;
  external set name(String v);
  external Signal get onDecoded;
  external set onDecoded(Signal v);
  external VoidFunc0 get onEndedHandler;
  external set onEndedHandler(VoidFunc0 v);
  external Signal get onFadeComplete;
  external set onFadeComplete(Signal v);
  external Signal get onLoop;
  external set onLoop(Signal v);
  external Signal get onMarkerComplete;
  external set onMarkerComplete(Signal v);
  external Signal get onMute;
  external set onMute(Signal v);
  external Signal get onPause;
  external set onPause(Signal v);
  external Signal get onPlay;
  external set onPlay(Signal v);
  external Signal get onResume;
  external set onResume(Signal v);
  external Signal get onStop;
  external set onStop(Signal v);
  external bool get override;
  external set override(bool v);
  external bool get paused;
  external set paused(bool v);
  external num get pausedPosition;
  external set pausedPosition(num v);
  external num get pausedTime;
  external set pausedTime(num v);
  external bool get pendingPlayback;
  external set pendingPlayback(bool v);
  external num get position;
  external set position(num v);
  external num get startTime;
  external set startTime(num v);
  external num get stopTime;
  external set stopTime(num v);
  external num get totalDuration;
  external set totalDuration(num v);
  external bool get usingAudioTag;
  external set usingAudioTag(bool v);
  external bool get usingWebAudio;
  external set usingWebAudio(bool v);
  external num get volume;
  external set volume(num v);
  external void addMarker(String name, num start, num duration,
      [num volume, bool loop]);

  /// Starts this sound playing (or restarts it if already doing so) and sets the volume to zero.
  /// Then increases the volume from 0 to 1 over the duration specified.
  /// At the end of the fade Sound.onFadeComplete is dispatched with this Sound object as the first parameter,
  /// and the final volume (1) as the second parameter.
  external void fadeIn([num duration, bool loop, String marker]);

  /// Decreases the volume of this Sound from its current value to 0 over the duration specified.
  /// At the end of the fade Sound.onFadeComplete is dispatched with this Sound object as the first parameter,
  /// and the final volume (0) as the second parameter.
  external void fadeOut([num duration]);

  /// Fades the volume of this Sound from its current value to the given volume over the duration specified.
  /// At the end of the fade Sound.onFadeComplete is dispatched with this Sound object as the first parameter,
  /// and the final volume (volume) as the second parameter.
  external void fadeTo([num duration, num volume]);

  /// Loops this entire sound. If you need to loop a section of it then use Sound.play and the marker and loop parameters.
  external Sound loopFull([num volume]);

  /// Pauses the sound.
  external void pause();

  /// Play this sound, or a marked section of it.
  external Sound play(
      [String marker, num position, num volume, bool loop, bool forceRestart]);

  /// Removes a marker from the sound.
  external void removeMarker(String name);

  /// Restart the sound, or a marked section of it.
  external void restart(String marker, num position, [num volume, bool loop]);

  /// Resumes the sound.
  external void resume();

  /// Called automatically when this sound is unlocked.
  external void soundHasUnlocked(String key);

  /// Stop playing this sound.
  external void stop();

  /// Called automatically by Phaser.SoundManager.
  external void update();
}

/// The Sound Manager is responsible for playing back audio via either the Legacy HTML Audio tag or via Web Audio if the browser supports it.
/// Note: On Firefox 25+ on Linux if you have media.gstreamer disabled in about:config then it cannot play back mp3 or m4a files.
/// The audio file type and the encoding of those files are extremely important. Not all browsers can play all audio formats.
/// There is a good guide to what's supported here: http://hpr.dogphilosophy.net/test/
/// If you are reloading a Phaser Game on a page that never properly refreshes (such as in an AngularJS project) then you will quickly run out
/// of AudioContext nodes. If this is the case create a global var called [PhaserGlobal] on the window object before creating the game. The active
/// AudioContext will then be saved to `window.PhaserGlobal.audioContext` when the Phaser game is destroyed, and re-used when it starts again.
/// Mobile warning: There are some mobile devices (certain iPad 2 and iPad Mini revisions) that cannot play 48000 Hz audio.
/// When they try to play the audio becomes extremely distorted and buzzes, eventually crashing the sound system.
/// The solution is to use a lower encoding rate such as 44100 Hz. Sometimes the audio context will
/// be created with a sampleRate of 48000. If this happens and audio distorts you should re-create the context.
@JS("Phaser.SoundManager")
class SoundManager {
  // @Ignore
  SoundManager.fakeConstructor$();

  /// The Sound Manager is responsible for playing back audio via either the Legacy HTML Audio tag or via Web Audio if the browser supports it.
  /// Note: On Firefox 25+ on Linux if you have media.gstreamer disabled in about:config then it cannot play back mp3 or m4a files.
  /// The audio file type and the encoding of those files are extremely important. Not all browsers can play all audio formats.
  /// There is a good guide to what's supported here: http://hpr.dogphilosophy.net/test/
  /// If you are reloading a Phaser Game on a page that never properly refreshes (such as in an AngularJS project) then you will quickly run out
  /// of AudioContext nodes. If this is the case create a global var called [PhaserGlobal] on the window object before creating the game. The active
  /// AudioContext will then be saved to `window.PhaserGlobal.audioContext` when the Phaser game is destroyed, and re-used when it starts again.
  /// Mobile warning: There are some mobile devices (certain iPad 2 and iPad Mini revisions) that cannot play 48000 Hz audio.
  /// When they try to play the audio becomes extremely distorted and buzzes, eventually crashing the sound system.
  /// The solution is to use a lower encoding rate such as 44100 Hz. Sometimes the audio context will
  /// be created with a sampleRate of 48000. If this happens and audio distorts you should re-create the context.
  external factory SoundManager(Game game);

  /// The number of audio channels to use in playback.
  /// Default: 32
  external num get channels;
  external set channels(num v);

  /// Used in conjunction with Sound.externalNode this allows you to stop a Sound node being connected to the SoundManager master gain node.
  /// Default: true
  external bool get connectToMaster;
  external set connectToMaster(bool v);

  /// The AudioContext being used for playback.
  external dynamic get context;
  external set context(dynamic v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// Gets or sets the muted state of the SoundManager. This effects all sounds in the game.
  external bool get mute;
  external set mute(bool v);

  /// Set to true to have all sound muted when the Phaser game pauses (such as on loss of focus),
  /// or set to false to keep audio playing, regardless of the game pause state. You may need to
  /// do this should you wish to control audio muting via external DOM buttons or similar.
  /// Default: true
  external bool get muteOnPause;
  external set muteOnPause(bool v);

  /// True if audio been disabled via the PhaserGlobal (useful if you need to use a 3rd party audio library) or the device doesn't support any audio.
  external bool get noAudio;
  external set noAudio(bool v);

  /// The event dispatched when a sound decodes (typically only for mp3 files)
  external Signal get onSoundDecode;
  external set onSoundDecode(Signal v);

  /// This signal is dispatched whenever the global volume changes. The new volume is passed as the only parameter to your callback.
  external Signal get onVolumeChange;
  external set onVolumeChange(Signal v);

  /// This signal is dispatched when the SoundManager is globally muted, either directly via game code or as a result of the game pausing.
  external Signal get onMute;
  external set onMute(Signal v);

  /// This signal is dispatched when the SoundManager is globally un-muted, either directly via game code or as a result of the game resuming from a pause.
  external Signal get onUnMute;
  external set onUnMute(Signal v);

  /// true if the audio system is currently locked awaiting a touch event.
  external bool get touchLocked;
  external set touchLocked(bool v);

  /// True the SoundManager and device are both using the Audio tag instead of Web Audio.
  external bool get usingAudioTag;
  external set usingAudioTag(bool v);

  /// True the SoundManager and device are both using Web Audio.
  external bool get usingWebAudio;
  external set usingWebAudio(bool v);

  /// Gets or sets the global volume of the SoundManager, a value between 0 and 1. The value given is clamped to the range 0 to 1.
  external num get volume;
  external set volume(num v);

  /// Adds a new Sound into the SoundManager.
  external Sound add(String key, [num volume, bool loop, bool connect]);

  /// Adds a new AudioSprite into the SoundManager.
  external AudioSprite addSprite(String key);

  /// Initialises the sound manager.
  external void boot();

  /// Decode a sound by its asset key.
  external void decode(String key, [Sound sound]);

  /// Stops all the sounds in the game, then destroys them and finally clears up any callbacks.
  external void destroy();

  /// Pauses all the sounds in the game.
  external void pauseAll();

  /// Adds a new Sound into the SoundManager and starts it playing.
  external Sound play(String key, [num volume, bool loop]);

  /// Removes a Sound from the SoundManager. The removed Sound is destroyed before removal.
  external bool remove(Sound sound);

  /// Removes all Sounds from the SoundManager that have an asset key matching the given value.
  /// The removed Sounds are destroyed before removal.
  external num removeByKey(String key);

  /// Resumes every sound in the game.
  external void resumeAll();

  /// This method allows you to give the SoundManager a list of Sound files, or keys, and a callback.
  /// Once all of the Sound files have finished decoding the callback will be invoked.
  /// The amount of time spent decoding depends on the codec used and file size.
  /// If all of the files given have already decoded the callback is triggered immediately.
  external void setDecodedCallback(
      List<dynamic> /*List<String>|List<Sound>*/ files,
      Function callback,
      dynamic callbackContext);

  /// Sets the Input Manager touch callback to be SoundManager.unlock.
  /// Required for iOS audio device unlocking. Mostly just used internally.
  external void setTouchLock();

  /// Stops all the sounds in the game.
  external void stopAll();

  /// Enables the audio, usually after the first touch.
  external bool unlock();

  /// Updates every sound in the game, checks for audio unlock on mobile and monitors the decoding watch list.
  external void update();
}

/// Sprites are the lifeblood of your game, used for nearly everything visual.
/// At its most basic a Sprite consists of a set of coordinates and a texture that is rendered to the canvas.
/// They also contain additional properties allowing for physics motion (via Sprite.body), input handling (via Sprite.input),
/// events (via Sprite.events), animation (via Sprite.animations), camera culling and more. Please see the Examples for use cases.
@JS("Phaser.Sprite")
class PhaserSprite extends Sprite {
  // @Ignore
  PhaserSprite.fakeConstructor$() : super.fakeConstructor$();

  /// Sprites are the lifeblood of your game, used for nearly everything visual.
  /// At its most basic a Sprite consists of a set of coordinates and a texture that is rendered to the canvas.
  /// They also contain additional properties allowing for physics motion (via Sprite.body), input handling (via Sprite.input),
  /// events (via Sprite.events), animation (via Sprite.animations), camera culling and more. Please see the Examples for use cases.
  external factory PhaserSprite(Game game, num x, num y,
      [dynamic /*String|RenderTexture|BitmapData|Texture*/ key,
      dynamic /*String|num*/ frame]);

  /// A useful flag to control if the Game Object is alive or dead.
  /// This is set automatically by the Health components `damage` method should the object run out of health.
  /// Or you can toggle it via your game code.
  /// This property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.
  /// However you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.
  /// Default: true
  external bool get alive;
  external set alive(bool v);

  /// The anchor sets the origin point of the texture.
  /// The default (0, 0) is the top left.
  /// (0.5, 0.5) is the center.
  /// (1, 1) is the bottom right.
  /// You can modify the default values in PIXI.Sprite.defaultAnchor.
  external PhaserPoint get anchor;
  external set anchor(Point v);

  /// The angle property is the rotation of the Game Object in *degrees* from its original orientation.
  /// Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.
  /// Values outside this range are added to or subtracted from 360 to obtain a value within the range.
  /// For example, the statement player.angle = 450 is the same as player.angle = 90.
  /// If you wish to work in radians instead of degrees you can use the property `rotation` instead.
  /// Working in radians is slightly faster as it doesn't have to perform any calculations.
  external num get angle;
  external set angle(num v);

  /// If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.
  /// Through it you can create, play, pause and stop animations.
  external AnimationManager get animations;
  external set animations(AnimationManager v);

  /// A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.
  /// If it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.
  /// This keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.
  /// This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,
  /// or you have tested performance and find it acceptable.
  external bool get autoCull;
  external set autoCull(bool v);

  /// `body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated
  /// properties and methods via it.
  /// By default Game Objects won't add themselves to any physics system and their `body` property will be `null`.
  /// To enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object
  /// and `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.
  /// You can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.
  /// Important: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5,
  /// so the physics body is centered on the Game Object.
  /// If you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.
  external dynamic /*Body|P2_Body|Ninja_Body|dynamic*/ get body;
  external set body(dynamic /*Body|P2_Body|Ninja_Body|dynamic*/ v);

  /// The sum of the y and height properties.
  /// This is the same as `y + height - offsetY`.
  external num get bottom;
  external set bottom(num v);

  /// The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.
  /// The values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.
  external PhaserPoint get cameraOffset;
  external set cameraOffset(Point v);

  /// The local center x coordinate of the Game Object.
  /// This is the same as `(x - offsetX) + (width / 2)`.
  external num get centerX;
  external set centerX(num v);

  /// The local center y coordinate of the Game Object.
  /// This is the same as `(y - offsetY) + (height / 2)`.
  external num get centerY;
  external set centerY(num v);

  /// If this is set to `true` the Game Object checks if it is within the World bounds each frame.
  /// When it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.
  /// If it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.
  /// It also optionally kills the Game Object if `outOfBoundsKill` is `true`.
  /// When `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.
  /// This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,
  /// or you have tested performance and find it acceptable.
  external bool get checkWorldBounds;
  external set checkWorldBounds(bool v);

  /// The components this Game Object has installed.
  external dynamic get components;
  external set components(dynamic v);

  /// The Rectangle used to crop the texture this Game Object uses.
  /// Set this property via `crop`.
  /// If you modify this property directly you must call `updateCrop` in order to have the change take effect.
  external Rectangle get cropRect;
  external set cropRect(Rectangle v);

  /// Does this texture require a custom render call? (as set by BitmapData, Video, etc)
  external bool get customRender;
  external set customRender(bool v);

  /// An empty Object that belongs to this Game Object.
  /// This value isn't ever used internally by Phaser, but may be used by your own code, or
  /// by Phaser Plugins, to store data that needs to be associated with the Game Object,
  /// without polluting the Game Object directly.
  /// Default: {}
  external dynamic get data;
  external set data(dynamic v);

  /// A debug flag designed for use with `Game.enableStep`.
  external bool get debug;
  external set debug(bool v);

  /// Returns the delta x value. The difference between world.x now and in the previous frame.
  /// The value will be positive if the Game Object has moved to the right or negative if to the left.
  external num get deltaX;
  external set deltaX(num v);

  /// Returns the delta y value. The difference between world.y now and in the previous frame.
  /// The value will be positive if the Game Object has moved down or negative if up.
  external num get deltaY;
  external set deltaY(num v);

  /// Returns the delta z value. The difference between rotation now and in the previous frame. The delta value.
  external num get deltaZ;
  external set deltaZ(num v);

  /// As a Game Object runs through its destroy method this flag is set to true,
  /// and can be checked in any sub-systems or plugins it is being destroyed from.
  external bool get destroyPhase;
  external set destroyPhase(bool v);

  /// All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this
  /// Game Object, or any of its components.
  external Events get events;
  external set events(Events v);

  /// Controls if this Sprite is processed by the core Phaser game loops and Group loops (except [Phaser.Group#update]).
  /// Default: true
  external bool get exists;
  external set exists(bool v);

  /// A Game Object that is "fixed" to the camera is rendered at a given x/y offsets from the top left of the camera. The offsets
  /// are stored in the `cameraOffset` property, which is initialized with the current object coordinates.
  /// The values are adjusted at the rendering stage, overriding the Game Objects actual world position.
  /// The end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world
  /// the camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times
  /// regardless where in the world the camera is.
  /// Note that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.
  /// Be careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.
  external bool get fixedToCamera;
  external set fixedToCamera(bool v);

  /// Gets or sets the current frame index of the texture being used to render this Game Object.
  /// To change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,
  /// for example: `player.frame = 4`.
  /// If the frame index given doesn't exist it will revert to the first frame found in the texture.
  /// If you are using a texture atlas then you should use the `frameName` property instead.
  /// If you wish to fully replace the texture being used see `loadTexture`.
  external dynamic /*String|num*/ get frame;
  external set frame(dynamic /*String|num*/ v);

  /// Gets or sets the current frame name of the texture being used to render this Game Object.
  /// To change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use,
  /// for example: `player.frameName = "idle"`.
  /// If the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.
  /// If you are using a sprite sheet then you should use the `frame` property instead.
  /// If you wish to fully replace the texture being used see `loadTexture`.
  external String get frameName;
  external set frameName(String v);

  /// A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.
  /// This property is mostly used internally by the physics systems, but is exposed for the use of plugins.
  external bool get fresh;
  external set fresh(bool v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// The Game Objects health value. This is a handy property for setting and manipulating health on a Game Object.
  /// It can be used in combination with the `damage` method or modified directly.
  /// Default: 1
  external num get health;
  external set health(num v);

  /// Checks if the Game Objects bounds intersect with the Game Camera bounds.
  /// Returns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.
  external bool get inCamera;
  external set inCamera(bool v);

  /// The Input Handler for this Game Object.
  /// By default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.
  /// After you have done this, this property will be a reference to the Phaser InputHandler.
  external InputHandler get input;
  external set input(InputHandler v);

  /// By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created
  /// for this Game Object and it will then start to process click / touch events and more.
  /// You can then access the Input Handler via `this.input`.
  /// Note that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.
  /// If you set this property to false it will stop the Input Handler from processing any more input events.
  /// If you want to _temporarily_ disable input for a Game Object, then it's better to set
  /// `input.enabled = false`, as it won't reset any of the Input Handlers internal properties.
  /// You can then toggle this back on as needed.
  external bool get inputEnabled;
  external set inputEnabled(bool v);

  /// Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.
  external bool get inWorld;
  external set inWorld(bool v);

  /// The key of the image or texture used by this Game Object during rendering.
  /// If it is a string it's the string used to retrieve the texture from the Phaser Image Cache.
  /// It can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
  /// If a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.
  /// If a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.
  external dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ get key;
  external set key(dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ v);

  /// The left coordinate of the Game Object.
  /// This is the same as `x - offsetX`.
  external num get left;
  external set left(num v);

  /// The lifespan allows you to give a Game Object a lifespan in milliseconds.
  /// Once the Game Object is 'born' you can set this to a positive value.
  /// It is automatically decremented by the millisecond equivalent of `game.time.physicsElapsed` each frame.
  /// When it reaches zero it will call the `kill` method.
  /// Very handy for particles, bullets, collectibles, or any other short-lived entity.
  external num get lifespan;
  external set lifespan(num v);

  /// The Game Objects maximum health value. This works in combination with the `heal` method to ensure
  /// the health value never exceeds the maximum.
  /// Default: 100
  external num get maxHealth;
  external set maxHealth(num v);

  /// A user defined name given to this Game Object.
  /// This value isn't ever used internally by Phaser, it is meant as a game level property.
  external String get name;
  external set name(String v);

  /// The amount the Game Object is visually offset from its x coordinate.
  /// This is the same as `width * anchor.x`.
  /// It will only be > 0 if anchor.x is not equal to zero.
  external num get offsetX;
  external set offsetX(num v);

  /// The amount the Game Object is visually offset from its y coordinate.
  /// This is the same as `height * anchor.y`.
  /// It will only be > 0 if anchor.y is not equal to zero.
  external num get offsetY;
  external set offsetY(num v);

  /// If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.
  external bool get outOfBoundsKill;
  external set outOfBoundsKill(bool v);

  /// If this and the `autoCull` property are both set to `true`, then the `kill` method
  /// is called as soon as the Game Object leaves the camera bounds.
  external bool get outOfCameraBoundsKill;
  external set outOfCameraBoundsKill(bool v);

  /// A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.
  /// You can set it directly to allow you to flag an object to be destroyed on its next update.
  /// This is extremely useful if you wish to destroy an object from within one of its own callbacks
  /// such as with Buttons or other Input events.
  external bool get pendingDestroy;
  external set pendingDestroy(bool v);

  /// The position the Game Object was located in the previous frame.
  external PhaserPoint get previousPosition;
  external set previousPosition(Point v);

  /// The rotation the Game Object was in set to in the previous frame. Value is in radians.
  external num get previousRotation;
  external set previousRotation(num v);

  /// The coordinates, in pixels, of this DisplayObject, relative to its parent container.
  /// The value of this property does not reflect any positioning happening further up the display list.
  /// To obtain that value please see the `worldPosition` property.
  external PhaserPoint get position;
  external set position(Point v);
  external bool get physicsEnabled;
  external set physicsEnabled(bool v);

  /// The const physics body type of this object.
  external num get physicsType;
  external set physicsType(num v);

  /// The render order ID is used internally by the renderer and Input Manager and should not be modified.
  /// This property is mostly used internally by the renderers, but is exposed for the use of plugins.
  external num get renderOrderID;
  external set renderOrderID(num v);

  /// The right coordinate of the Game Object.
  /// This is the same as `x + width - offsetX`.
  external num get right;
  external set right(num v);

  /// The scale of this DisplayObject. A scale of 1:1 represents the DisplayObject
  /// at its default size. A value of 0.5 would scale this DisplayObject by half, and so on.
  /// The value of this property does not reflect any scaling happening further up the display list.
  /// To obtain that value please see the `worldScale` property.
  external PhaserPoint get scale;
  external set scale(Point v);

  /// The minimum scale this Game Object will scale down to.
  /// It allows you to prevent a parent from scaling this Game Object lower than the given value.
  /// Set it to `null` to remove the limit.
  external PhaserPoint get scaleMin;
  external set scaleMin(Point v);

  /// The maximum scale this Game Object will scale up to.
  /// It allows you to prevent a parent from scaling this Game Object higher than the given value.
  /// Set it to `null` to remove the limit.
  external PhaserPoint get scaleMax;
  external set scaleMax(Point v);

  /// Enable or disable texture smoothing for this Game Object.
  /// It only takes effect if the Game Object is using an image based texture.
  /// Smoothing is enabled by default.
  external bool get smoothed;
  external set smoothed(bool v);

  /// The y coordinate of the Game Object.
  /// This is the same as `y - offsetY`.
  external num get top;
  external set top(num v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)
  /// Default: null
  external CanvasElement get tintedTexture;
  external set tintedTexture(CanvasElement v);

  /// The callback that will apply any scale limiting to the worldTransform.
  external Function get transformCallback;
  external set transformCallback(Function v);

  /// The context under which `transformCallback` is called.
  external dynamic get transformCallbackContext;
  external set transformCallbackContext(dynamic v);

  /// The world coordinates of this Game Object in pixels.
  /// Depending on where in the display list this Game Object is placed this value can differ from `position`,
  /// which contains the x/y coordinates relative to the Game Objects parent.
  external PhaserPoint get world;
  external set world(Point v);

  /// The horizontal position of the DisplayObject, in pixels, relative to its parent.
  /// If you need the world position of the DisplayObject, use `DisplayObject.worldPosition` instead.
  external num get x;
  external set x(num v);

  /// The vertical position of the DisplayObject, in pixels, relative to its parent.
  /// If you need the world position of the DisplayObject, use `DisplayObject.worldPosition` instead.
  external num get y;
  external set y(num v);

  /// The z depth of this Game Object within its parent Group.
  /// No two objects in a Group can have the same z value.
  /// This value is adjusted automatically whenever the Group hierarchy changes.
  /// If you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.
  external num get z;
  external set z(num v);

  /// Aligns this Game Object within another Game Object, or Rectangle, known as the
  /// 'container', to one of 9 possible positions.
  /// The container must be a Game Object, or Phaser.Rectangle object. This can include properties
  /// such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world
  /// and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,
  /// TileSprites or Buttons.
  /// Please note that aligning a Sprite to another Game Object does **not** make it a child of
  /// the container. It simply modifies its position coordinates so it aligns with it.
  /// The position constants you can use are:
  /// `Phaser.TOP_LEFT`, `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`,
  /// `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`,
  /// `Phaser.BOTTOM_CENTER` and `Phaser.BOTTOM_RIGHT`.
  /// The Game Objects are placed in such a way that their _bounds_ align with the
  /// container, taking into consideration rotation, scale and the anchor property.
  /// This allows you to neatly align Game Objects, irrespective of their position value.
  /// The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final
  /// aligned position of the Game Object. For example:
  /// `sprite.alignIn(background, Phaser.BOTTOM_RIGHT, -20, -20)`
  /// Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.
  /// Think of the offsets as applying an adjustment to the containers bounds before the alignment takes place.
  /// So providing a negative offset will 'shrink' the container bounds by that amount, and providing a positive
  /// one expands it.
  external dynamic alignIn(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// Aligns this Game Object to the side of another Game Object, or Rectangle, known as the
  /// 'parent', in one of 11 possible positions.
  /// The parent must be a Game Object, or Phaser.Rectangle object. This can include properties
  /// such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world
  /// and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,
  /// TileSprites or Buttons.
  /// Please note that aligning a Sprite to another Game Object does **not** make it a child of
  /// the parent. It simply modifies its position coordinates so it aligns with it.
  /// The position constants you can use are:
  /// `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_TOP`,
  /// `Phaser.LEFT_CENTER`, `Phaser.LEFT_BOTTOM`, `Phaser.RIGHT_TOP`, `Phaser.RIGHT_CENTER`,
  /// `Phaser.RIGHT_BOTTOM`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER`
  /// and `Phaser.BOTTOM_RIGHT`.
  /// The Game Objects are placed in such a way that their _bounds_ align with the
  /// parent, taking into consideration rotation, scale and the anchor property.
  /// This allows you to neatly align Game Objects, irrespective of their position value.
  /// The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final
  /// aligned position of the Game Object. For example:
  /// `sprite.alignTo(background, Phaser.BOTTOM_RIGHT, -20, -20)`
  /// Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.
  /// Think of the offsets as applying an adjustment to the parents bounds before the alignment takes place.
  /// So providing a negative offset will 'shrink' the parent bounds by that amount, and providing a positive
  /// one expands it.
  external dynamic alignTo(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// Brings this Game Object to the top of its parents display list.
  /// Visually this means it will render over the top of any old child in the same Group.
  /// If this Game Object hasn't been added to a custom Group then this method will bring it to the top of the Game World,
  /// because the World is the root Group from which all Game Objects descend.
  external Sprite bringToTop();

  /// Crop allows you to crop the texture being used to display this Game Object.
  /// Setting a crop rectangle modifies the core texture frame. The Game Object width and height properties will be adjusted accordingly.
  /// Cropping takes place from the top-left and can be modified in real-time either by providing an updated rectangle object to this method,
  /// or by modifying `cropRect` property directly and then calling `updateCrop`.
  /// The rectangle object given to this method can be either a `Phaser.Rectangle` or any other object
  /// so long as it has public `x`, `y`, `width`, `height`, `right` and `bottom` properties.
  /// A reference to the rectangle is stored in `cropRect` unless the `copy` parameter is `true`,
  /// in which case the values are duplicated to a local object.
  external void crop(Rectangle rect, bool copy);

  /// Adjust scaling limits, if set, to this Game Object.
  external void checkTransform(Matrix wt);

  /// Damages the Game Object. This removes the given amount of health from the `health` property.
  /// If health is taken below or is equal to zero then the `kill` method is called.
  external Sprite damage(num amount);

  /// Destroy this DisplayObject.
  /// Removes any cached sprites, sets renderable flag to false, and nulls filters, bounds and mask.
  /// Also iteratively calls `destroy` on any children.
  external void destroy([bool destroyChildren]);
  external void drawPolygon();

  /// Heal the Game Object. This adds the given amount of health to the `health` property.
  external Sprite heal(num amount);

  /// Kills a Game Object. A killed Game Object has its `alive`, `exists` and `visible` properties all set to false.
  /// It will dispatch the `onKilled` event. You can listen to `events.onKilled` for the signal.
  /// Note that killing a Game Object is a way for you to quickly recycle it in an object pool,
  /// it doesn't destroy the object or free it up from memory.
  /// If you don't need this Game Object any more you should call `destroy` instead.
  external Sprite kill();

  /// Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.
  /// If your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.
  /// You should only use `loadTexture` if you want to replace the base texture entirely.
  /// Calling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.
  /// You can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite.
  /// Doing this then sets the key to be the `frame` argument (the frame is set to zero).
  /// This allows you to create sprites using `load.image` during development, and then change them
  /// to use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS'
  /// and swapping it to be the key of the atlas data.
  /// Note: You cannot use a RenderTexture as a texture for a TileSprite.
  external void loadTexture(
      dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ key,
      [dynamic /*String|num*/ frame,
      bool stopAnimation]);

  /// Moves this Game Object up one place in its parents display list.
  /// This call has no effect if the Game Object is already at the top of the display list.
  /// If this Game Object hasn't been added to a custom Group then this method will move it one object up within the Game World,
  /// because the World is the root Group from which all Game Objects descend.
  external Sprite moveUp();

  /// Moves this Game Object down one place in its parents display list.
  /// This call has no effect if the Game Object is already at the bottom of the display list.
  /// If this Game Object hasn't been added to a custom Group then this method will move it one object down within the Game World,
  /// because the World is the root Group from which all Game Objects descend.
  external Sprite moveDown();

  /// Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object,
  /// which can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.
  /// This check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.
  /// Therefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.
  /// It should be fine for low-volume testing where physics isn't required.
  external bool overlap(
      dynamic /*Sprite|Image|TileSprite|Button|DisplayObject*/ displayObject);

  /// Plays an Animation.
  /// The animation should have previously been created via `animations.add`.
  /// If the animation is already playing calling this again won't do anything.
  /// If you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.
  external Animation play(String name,
      [num frameRate, bool loop, bool killOnComplete]);

  /// Internal method called by the World postUpdate cycle.
  external void postUpdate();

  /// Automatically called by World.preUpdate.
  external void preUpdate();

  /// Resets the Game Object.
  /// This moves the Game Object to the given x/y world coordinates and sets `fresh`, `exists`,
  /// `visible` and `renderable` to true.
  /// If this Game Object has the LifeSpan component it will also set `alive` to true and `health` to the given value.
  /// If this Game Object has a Physics Body it will reset the Body.
  external Sprite reset(num x, num y, [num health]);

  /// Resets the texture frame dimensions that the Game Object uses for rendering.
  external void resetFrame();

  /// Resizes the Frame dimensions that the Game Object uses for rendering.
  /// You shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData
  /// it can be useful to adjust the dimensions directly in this way.
  external void resizeFrame(dynamic parent, num width, num height);

  /// Brings a 'dead' Game Object back to life, optionally resetting its health value in the process.
  /// A resurrected Game Object has its `alive`, `exists` and `visible` properties all set to true.
  /// It will dispatch the `onRevived` event. Listen to `events.onRevived` for the signal.
  external Sprite revive([num health]);

  /// Sends this Game Object to the bottom of its parents display list.
  /// Visually this means it will render below all other children in the same Group.
  /// If this Game Object hasn't been added to a custom Group then this method will send it to the bottom of the Game World,
  /// because the World is the root Group from which all Game Objects descend.
  external Sprite sendToBack();

  /// Sets the texture frame the Game Object uses for rendering.
  /// This is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.
  external void setFrame(Frame frame);

  /// Sets the scaleMin and scaleMax values. These values are used to limit how far this Game Object will scale based on its parent.
  /// For example if this Game Object has a `minScale` value of 1 and its parent has a `scale` value of 0.5, the 0.5 will be ignored
  /// and the scale value of 1 will be used, as the parents scale is lower than the minimum scale this Game Object should adhere to.
  /// By setting these values you can carefully control how Game Objects deal with responsive scaling.
  /// If only one parameter is given then that value will be used for both scaleMin and scaleMax:
  /// `setScaleMinMax(1)` = scaleMin.x, scaleMin.y, scaleMax.x and scaleMax.y all = 1
  /// If only two parameters are given the first is set as scaleMin.x and y and the second as scaleMax.x and y:
  /// `setScaleMinMax(0.5, 2)` = scaleMin.x and y = 0.5 and scaleMax.x and y = 2
  /// If you wish to set `scaleMin` with different values for x and y then either modify Game Object.scaleMin directly,
  /// or pass `null` for the `maxX` and `maxY` parameters.
  /// Call `setScaleMinMax(null)` to clear all previously set values.
  external void setScaleMinMax([num minX, num minY, num maxX, num maxY]);

  /// Override this method in your own custom objects to handle any update requirements.
  /// It is called immediately after `preUpdate` and before `postUpdate`.
  /// Remember if this Game Object has any children you should call update on those too.
  external void update();

  /// If you have set a crop rectangle on this Game Object via `crop` and since modified the `cropRect` property,
  /// or the rectangle it references, then you need to update the crop frame by calling this method.
  external void updateCrop();
}

/// The SpriteBatch class is a really fast version of the DisplayObjectContainer built purely for speed, so use when you need a lot of sprites or particles.
/// It's worth mentioning that by default sprite batches are used through-out the renderer, so you only really need to use a SpriteBatch if you have over
/// 1000 sprites that all share the same texture (or texture atlas). It's also useful if running in Canvas mode and you have a lot of un-rotated or un-scaled
/// Sprites as it skips all of the Canvas setTransform calls, which helps performance, especially on mobile devices.
/// Please note that any Sprite that is part of a SpriteBatch will not have its bounds updated, so will fail checks such as outOfBounds.
@JS("Phaser.SpriteBatch")
class SpriteBatch extends Group {
  // @Ignore
  SpriteBatch.fakeConstructor$() : super.fakeConstructor$();

  /// The SpriteBatch class is a really fast version of the DisplayObjectContainer built purely for speed, so use when you need a lot of sprites or particles.
  /// It's worth mentioning that by default sprite batches are used through-out the renderer, so you only really need to use a SpriteBatch if you have over
  /// 1000 sprites that all share the same texture (or texture atlas). It's also useful if running in Canvas mode and you have a lot of un-rotated or un-scaled
  /// Sprites as it skips all of the Canvas setTransform calls, which helps performance, especially on mobile devices.
  /// Please note that any Sprite that is part of a SpriteBatch will not have its bounds updated, so will fail checks such as outOfBounds.
  external factory SpriteBatch(Game game, DisplayObjectContainer parent,
      [String name, bool addedToStage]);

  /// Internal Phaser Type value.
  external num get type;
  external set type(num v);
}

/// The Stage controls root level display objects upon which everything is displayed.
/// It also handles browser visibility handling and the pausing due to loss of focus.
@JS("Phaser.Stage")
class Stage extends DisplayObjectContainer {
  // @Ignore
  Stage.fakeConstructor$() : super.fakeConstructor$();

  /// The Stage controls root level display objects upon which everything is displayed.
  /// It also handles browser visibility handling and the pausing due to loss of focus.
  external factory Stage(Game game);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// The name of this object.
  /// Default: _stage_root
  external String get name;
  external set name(String v);

  /// By default if the browser tab loses focus the game will pause.
  /// You can stop that behavior by setting this property to true.
  /// Note that the browser can still elect to pause your game if it wishes to do so,
  /// for example swapping to another browser tab. This will cause the RAF callback to halt,
  /// effectively pausing your game, even though no in-game pause event is triggered if you enable this property.
  external bool get disableVisibilityChange;
  external set disableVisibilityChange(bool v);

  /// If exists is true the Stage and all children are updated, otherwise it is skipped.
  /// Default: true
  external bool get exists;
  external set exists(bool v);

  /// Reset each frame, keeps a count of the total number of objects updated.
  external num get currentRenderOrderID;
  external set currentRenderOrderID(num v);

  /// Gets and sets the background color of the stage. The color can be given as a number: 0xff0000 or a hex string: '#ff0000'
  external dynamic get backgroundColor;
  external set backgroundColor(dynamic v);

  /// Enable or disable texture smoothing for all objects on this Stage. Only works for bitmap/image textures. Smoothing is enabled by default. Set to true to smooth all sprites rendered on this Stage, or false to disable smoothing (great for pixel art)
  external bool get smoothed;
  external set smoothed(bool v);

  /// Adds an existing object to the Stage.
  /// The child is automatically added to the front of the Stage, and is displayed above every previous child.
  /// Or if the _optional_ `index` is specified, the child is added at the location specified by the index value,
  /// this allows you to control child ordering.
  /// If the object was already on the Stage, it is simply returned, and nothing else happens to it.
  external dynamic add(dynamic child, [bool silent, num index]);

  /// Parses a Game configuration object.
  external void parseConfig(dynamic config);

  /// This is called automatically after the plugins preUpdate and before the State.update.
  /// Most objects have preUpdate methods and it's where initial movement and positioning is done.
  external void preUpdate();

  /// This is called automatically after the State.update, but before particles or plugins update.
  external void update();

  /// This is called automatically before the renderer runs and after the plugins have updated.
  /// In postUpdate this is where all the final physics calculations and object positioning happens.
  /// The objects are processed in the order of the display list.
  external void postUpdate();

  /// Updates the transforms for all objects on the display list.
  /// This overrides the Pixi default as we don't need the interactionManager, but do need the game property check.
  external void updateTransform([container]);

  /// Starts a page visibility event listener running, or window.onpagehide/onpageshow if not supported by the browser.
  /// Also listens for window.onblur and window.onfocus.
  external void checkVisibility();

  /// This method is called when the document visibility is changed.
  /// - `blur` and `pagehide` events trigger [Phaser.Game#onBlur]. They [Phaser.Game#gamePaused pause the game] unless [Phaser.Stage#disableVisibilityChange disableVisibilityChange] is on.
  /// - `click`, `focus`, and `pageshow` trigger [Phaser.Game#onFocus]. They [Phaser.Game#gameResumed resume the game] unless [Phaser.Stage#disableVisibilityChange disableVisibilityChange] is on.
  /// - `visibilitychange` (hidden) and CocoonJS's `onSuspended` [Phaser.Game#gamePaused pause the game] unless [Phaser.Stage#disableVisibilityChange disableVisibilityChange] is on.
  /// - `visibilitychange` (visible) and CocoonJS's `onActivated` [Phaser.Game#gameResumed resume the game] unless [Phaser.Stage#disableVisibilityChange disableVisibilityChange] is on.
  external void visibilityChange(Event event);

  /// Sets the background color for the Stage.
  /// The color can be given as a hex string (`'#RRGGBB'`), a CSS color string (`'rgb(r,g,b)'`), or a numeric value (`0xRRGGBB`).
  /// An alpha channel is _not_ supported and will be ignored.
  /// If you've set your game to be [Phaser.Game#transparent transparent] then calls to setBackgroundColor are ignored.
  /// If [Phaser.Game#clearBeforeRender] is off then the background color won't appear.
  external void setBackgroundColor(dynamic /*num|String*/ backgroundColor);

  /// Destroys the Stage and removes event listeners.
  external void destroy();
}

typedef dynamic ResizeCallback(ScaleManager scale, Rectangle parentBounds);

/// The ScaleManager object handles the the scaling, resizing, and alignment of the
/// Game size and the game Display canvas.
/// The Game size is the logical size of the game; the Display canvas has size as an HTML element.
/// The calculations of these are heavily influenced by the bounding Parent size which is the computed
/// dimensions of the Display canvas's Parent container/element - the _effective CSS rules of the
/// canvas's Parent element play an important role_ in the operation of the ScaleManager.
/// The Display canvas - or Game size, depending [Phaser.ScaleManager#scaleMode scaleMode] - is updated to best utilize the Parent size.
/// When in Fullscreen mode or with [Phaser.ScaleManager#parentIsWindow parentIsWindow] the Parent size is that of the visual viewport (see [Phaser.ScaleManager#getParentBounds getParentBounds]).
/// #### Parent and Display canvas containment guidelines:
/// - Style the Parent element (of the game canvas) to control the Parent size and
/// thus the Display canvas's size and layout.
/// - The Parent element's CSS styles should _effectively_ apply maximum (and minimum) bounding behavior.
/// - The Parent element should _not_ apply a padding as this is not accounted for.
/// If a padding is required apply it to the Parent's parent or apply a margin to the Parent.
/// If you need to add a border, margin or any other CSS around your game container, then use a parent element and
/// apply the CSS to this instead, otherwise you'll be constantly resizing the shape of the game container.
/// - The Display canvas layout CSS styles (i.e. margins, size) should not be altered/specified as
/// they may be updated by the ScaleManager.
/// #### Example Uses
/// -  ##### Fixed game size; scale canvas proportionally to fill its container
/// Use `scaleMode` SHOW_ALL.
/// -  ##### Fixed game size; stretch canvas to fill its container (uncommon)
/// Use `scaleMode` EXACT_FIT.
/// -  ##### Fixed game size; scale canvas proportionally by some other criteria
/// Use `scaleMode` USER_SCALE. Examine `parentBounds` in the [#setResizeCallback resize callback] and call [Phaser.ScaleManager#setUserScale setUserScale] if necessary.
/// -  ##### Fluid game/canvas size
/// Use `scaleMode` RESIZE. Examine the game or canvas size from the [Phaser.ScaleManager#onSizeChange onSizeChange] signal **or** the [Phaser.State#resize] callback and reposition game objects if necessary.
/// -  ##### Preferred orientation
/// Call [Phaser.ScaleManager#forceOrientation forceOrientation] with the preferred orientation and use any of the [Phaser.ScaleManager#onOrientationChange onOrientationChange], [Phaser.ScaleManager#enterIncorrectOrientation enterIncorrectOrientation], or [Phaser.ScaleManager#leaveIncorrectOrientation leaveIncorrectOrientation] signals.
@JS("Phaser.ScaleManager")
class ScaleManager {
  // @Ignore
  ScaleManager.fakeConstructor$();

  /// Create a new ScaleManager object - this is done automatically by [Phaser.Game]
  /// The `width` and `height` constructor parameters can either be a number which represents pixels or a string that represents a percentage: e.g. `800` (for 800 pixels) or `"80%"` for 80%.
  external factory ScaleManager(
      Game game, dynamic /*num|String*/ width, dynamic /*num|String*/ height);

  /// A scale mode that stretches content to fill all available space - see [Phaser.ScaleManager#scaleMode scaleMode].
  external static num get EXACT_FIT;
  external static set EXACT_FIT(num v);

  /// A scale mode that prevents any scaling - see [Phaser.ScaleManager#scaleMode scaleMode].
  external static num get NO_SCALE;
  external static set NO_SCALE(num v);

  /// A scale mode that shows the entire game while maintaining proportions - see [Phaser.ScaleManager#scaleMode scaleMode].
  external static num get SHOW_ALL;
  external static set SHOW_ALL(num v);

  /// A scale mode that causes the Game size to change - see [Phaser.ScaleManager#scaleMode scaleMode].
  external static num get RESIZE;
  external static set RESIZE(num v);

  /// A scale mode that allows a custom scale factor - see [Phaser.ScaleManager#scaleMode scaleMode].
  external static num get USER_SCALE;
  external static set USER_SCALE(num v);

  /// The aspect ratio of the scaled Display canvas.
  external num get aspectRatio;
  external set aspectRatio(num v);

  /// The bounds of the scaled game. The x/y will match the offset of the canvas element and the width/height the scaled width and height.
  external Rectangle get bounds;
  external set bounds(Rectangle v);

  /// The DOM element that is considered the Parent bounding element, if any.
  /// This `null` if [Phaser.ScaleManager#parentIsWindow parentIsWindow] is true or if fullscreen mode is entered and [Phaser.ScaleManager#fullScreenTarget fullScreenTarget] is specified.
  /// It will also be null if there is no game canvas or if the game canvas has no parent.
  external HtmlElement get boundingParent;
  external set boundingParent(HtmlElement v);

  /// Various compatibility settings.
  /// A value of "(auto)" indicates the setting is configured based on device and runtime information.
  /// A [Phaser.ScaleManager#refresh refresh] may need to be performed after making changes.
  external dynamic
      /*{
            canExpandParent: boolean;
            clickTrampoline: string;
            forceMinimumDocumentHeight: boolean;
            noMargins: boolean;
            orientationFallback: boolean;
            scrollTo: Point;
            supportsFullScreen: boolean;
        }*/
      get compatibility;
  external set compatibility(
      dynamic /*{
            canExpandParent: boolean;
            clickTrampoline: string;
            forceMinimumDocumentHeight: boolean;
            noMargins: boolean;
            orientationFallback: boolean;
            scrollTo: Point;
            supportsFullScreen: boolean;
        }*/
      v);

  /// Returns the current scale mode - for normal or fullscreen operation.
  /// See [Phaser.ScaleManager#scaleMode scaleMode] for the different modes allowed.
  external num get currentScaleMode;
  external set currentScaleMode(num v);

  /// Provides access to some cross-device DOM functions.
  external DOM get dom;
  external set dom(DOM v);

  /// This signal is dispatched when the browser enters an incorrect orientation, as defined by [Phaser.ScaleManager#forceOrientation forceOrientation].
  /// This is signaled from `preUpdate` (or `pauseUpdate`) _even when_ the game is paused.
  external Signal get enterIncorrectOrientation;
  external set enterIncorrectOrientation(Signal v);

  /// The native browser events from Fullscreen API changes.
  external dynamic get event;
  external set event(dynamic v);

  /// If true, the game should only run in a landscape orientation.
  /// Change with [Phaser.ScaleManager#forceOrientation forceOrientation].
  external bool get forceLandscape;
  external set forceLandscape(bool v);

  /// If true, the game should only run in a portrait
  /// Change with [Phaser.ScaleManager#forceOrientation forceOrientation].
  external bool get forcePortrait;
  external set forcePortrait(bool v);

  /// The scaling method used by the ScaleManager when in fullscreen.
  /// See [Phaser.ScaleManager#scaleMode scaleMode] for the different modes allowed.
  external num get fullScreenScaleMode;
  external set fullScreenScaleMode(num v);

  /// If specified, this is the DOM element on which the Fullscreen API enter request will be invoked.
  /// The target element must have the correct CSS styling and contain the Display canvas.
  /// The elements style will be modified (ie. the width and height might be set to 100%)
  /// but it will not be added to, removed from, or repositioned within the DOM.
  /// An attempt is made to restore relevant style changes when fullscreen mode is left.
  /// For pre-2.2.0 behavior set `game.scale.fullScreenTarget = game.canvas`.
  external HtmlElement get fullScreenTarget;
  external set fullScreenTarget(HtmlElement v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// _EXPERIMENTAL:_ A responsive grid on which you can align game objects.
  external FlexGrid get grid;
  external set grid(FlexGrid v);

  /// This boolean provides you with a way to determine if the browser is in Full Screen
  /// mode (via the Full Screen API), and Phaser was the one responsible for activating it.
  /// It's possible that ScaleManager.isFullScreen returns `true` even if Phaser wasn't the
  /// one that made the browser go full-screen, so this flag lets you determine that.
  external bool get hasPhaserSetFullScreen;
  external set hasPhaserSetFullScreen(bool v);

  /// Target height (in pixels) of the Display canvas.
  external num get height;
  external set height(num v);

  /// True if [Phaser.ScaleManager#forceLandscape forceLandscape] or [Phaser.ScaleManager#forcePortrait forcePortrait] are set and do not agree with the browser orientation.
  /// This value is not updated immediately.
  external bool get incorrectOrientation;
  external set incorrectOrientation(bool v);

  /// Returns true if the browser is in fullscreen mode, otherwise false.
  external bool get isFullScreen;
  external set isFullScreen(bool v);

  /// Returns true if the game dimensions are landscape (width > height).
  /// This is especially useful to check when using the RESIZE scale mode
  /// but wanting to maintain game orientation on desktop browsers,
  /// where typically the screen orientation will always be landscape regardless of the browser viewport.
  external bool get isGameLandscape;
  external set isGameLandscape(bool v);

  /// Returns true if the game dimensions are portrait (height > width).
  /// This is especially useful to check when using the RESIZE scale mode
  /// but wanting to maintain game orientation on desktop browsers,
  /// where typically the screen orientation will always be landscape regardless of the browser viewport.
  external bool get isGamePortrait;
  external set isGamePortrait(bool v);

  /// Returns true if the screen orientation is in portrait mode.
  external bool get isPortrait;
  external set isPortrait(bool v);

  /// Returns true if the screen orientation is in landscape mode.
  external bool get isLandscape;
  external set isLandscape(bool v);

  /// This signal is dispatched when the browser leaves an incorrect orientation, as defined by [Phaser.ScaleManager#forceOrientation forceOrientation].
  /// This is signaled from `preUpdate` (or `pauseUpdate`) _even when_ the game is paused.
  external Signal get leaveIncorrectOrientation;
  external set leaveIncorrectOrientation(Signal v);

  /// The Display canvas is aligned by adjusting the margins; the last margins are stored here.
  external dynamic /*{ left: number; top: number; right: number; bottom: number; x: number; y: number; }*/ get margin;
  external set margin(
      dynamic /*{ left: number; top: number; right: number; bottom: number; x: number; y: number; }*/ v);

  /// Maximum height the canvas should be scaled to (in pixels).
  /// If null it will scale to whatever height the browser can handle.
  /// Change with [Phaser.ScaleManager#setMinMax setMinMax].
  external num get maxHeight;
  external set maxHeight(num v);

  /// Maximum width the canvas should be scaled to (in pixels).
  /// If null it will scale to whatever width the browser can handle.
  /// Change with [Phaser.ScaleManager#setMinMax setMinMax].
  external num get maxWidth;
  external set maxWidth(num v);

  /// Minimum height the canvas should be scaled to (in pixels).
  /// Change with [Phaser.ScaleManager#setMinMax setMinMax].
  external num get minHeight;
  external set minHeight(num v);

  /// Minimum width the canvas should be scaled to (in pixels).
  /// Change with [Phaser.ScaleManager#setMinMax setMinMax].
  external num get minWidth;
  external set minWidth(num v);

  /// The offset coordinates of the Display canvas from the top-left of the browser window.
  /// The is used internally by Phaser.Pointer (for Input) and possibly other types.
  external PhaserPoint get offset;
  external set offset(Point v);

  /// This signal is dispatched when fullscreen mode is ready to be initialized but
  /// before the fullscreen request.
  /// The signal is passed two arguments: `scale` (the ScaleManager), and an object in the form `{targetElement: DOMElement}`.
  /// The `targetElement` is the [Phaser.ScaleManager#fullScreenTarget fullScreenTarget] element,
  /// if such is assigned, or a new element created by [Phaser.ScaleManager#createFullScreenTarget createFullScreenTarget].
  /// Custom CSS styling or resets can be applied to `targetElement` as required.
  /// If `targetElement` is _not_ the same element as [Phaser.ScaleManager#fullScreenTarget fullScreenTarget]:
  /// - After initialization the Display canvas is moved onto the `targetElement` for
  /// the duration of the fullscreen mode, and restored to it's original DOM location when fullscreen is exited.
  /// - The `targetElement` is moved/re-parented within the DOM and may have its CSS styles updated.
  /// The behavior of a pre-assigned target element is covered in [Phaser.ScaleManager#fullScreenTarget fullScreenTarget].
  external Signal get onFullScreenInit;
  external set onFullScreenInit(Signal v);

  /// This signal is dispatched when the browser enters or leaves fullscreen mode, if supported.
  /// The signal is supplied with a single argument: `scale` (the ScaleManager). Use `scale.isFullScreen` to determine
  /// if currently running in Fullscreen mode.
  external Signal get onFullScreenChange;
  external set onFullScreenChange(Signal v);

  /// This signal is dispatched when the browser fails to enter fullscreen mode;
  /// or if the device does not support fullscreen mode and `startFullScreen` is invoked.
  /// The signal is supplied with a single argument: `scale` (the ScaleManager).
  external Signal get onFullScreenError;
  external set onFullScreenError(Signal v);

  /// This signal is dispatched when the orientation changes _or_ the validity of the current orientation changes.
  /// The signal is supplied with the following arguments:
  /// - `scale` - the ScaleManager object
  /// - `prevOrientation`, a string - The previous orientation as per [Phaser.ScaleManager#screenOrientation screenOrientation].
  /// - `wasIncorrect`, a boolean - True if the previous orientation was last determined to be incorrect.
  /// Access the current orientation and validity with `scale.screenOrientation` and `scale.incorrectOrientation`.
  /// Thus the following tests can be done:
  /// // The orientation itself changed:
  /// scale.screenOrientation !== prevOrientation
  /// // The orientation just became incorrect:
  /// scale.incorrectOrientation && !wasIncorrect
  /// It is possible that this signal is triggered after [Phaser.ScaleManager#forceOrientation forceOrientation] so the orientation
  /// correctness changes even if the orientation itself does not change.
  /// This is signaled from `preUpdate` (or `pauseUpdate`) _even when_ the game is paused.
  external Signal get onOrientationChange;
  external set onOrientationChange(Signal v);

  /// This signal is dispatched when the size of the Display canvas changes _or_ the size of the Game changes.
  /// When invoked this is done _after_ the Canvas size/position have been updated.
  /// The callback is supplied with three arguments: the Scale Manager, canvas [Phaser.ScaleManager#width width], and canvas [Phaser.ScaleManager#height height]. (Game dimensions can be found in `scale.game.width` and `scale.game.height`.)
  /// This signal is _only_ called when a change occurs and a reflow may be required.
  /// For example, if the canvas does not change sizes because of CSS settings (such as min-width)
  /// then this signal will _not_ be triggered.
  /// Use this to handle responsive game layout options.
  /// This is signaled from `preUpdate` (or `pauseUpdate`) _even when_ the game is paused.
  external Signal get onSizeChange;
  external set onSizeChange(Signal v);

  /// When enabled the Display canvas will be horizontally-aligned _in the Parent container_ (or [Phaser.ScaleManager#parentIsWindow window]).
  /// To align horizontally across the page the Display canvas should be added directly to page;
  /// or the parent container should itself be horizontally aligned.
  /// Horizontal alignment is not applicable with the [Phaser.ScaleManager.RESIZE RESIZE] scaling mode.
  /// Default: false
  external bool get pageAlignHorizontally;
  external set pageAlignHorizontally(bool v);

  /// When enabled the Display canvas will be vertically-aligned _in the Parent container_ (or [Phaser.ScaleManager#parentIsWindow window]).
  /// To align vertically the Parent element should have a _non-collapsible_ height, such that it will maintain
  /// a height _larger_ than the height of the contained Game canvas - the game canvas will then be scaled vertically
  /// _within_ the remaining available height dictated by the Parent element.
  /// One way to prevent the parent from collapsing is to add an absolute "min-height" CSS property to the parent element.
  /// If specifying a relative "min-height/height" or adjusting margins, the Parent height must still be non-collapsible (see note).
  /// _Note_: In version 2.2 the minimum document height is _not_ automatically set to the viewport/window height.
  /// To automatically update the minimum document height set [Phaser.ScaleManager#compatibility compatibility.forceMinimumDocumentHeight] to true.
  /// Vertical alignment is not applicable with the [Phaser.ScaleManager.RESIZE RESIZE] scaling mode.
  /// Default: false
  external bool get pageAlignVertically;
  external set pageAlignVertically(bool v);

  /// The _original_ DOM element for the parent of the Display canvas.
  /// This may be different in fullscreen - see [Phaser.ScaleManager#createFullScreenTarget createFullScreenTarget].
  /// This is set automatically based on the `parent` argument passed to [Phaser.Game].
  /// This should only be changed after moving the Game canvas to a different DOM parent.
  external HtmlElement get parentNode;
  external set parentNode(HtmlElement v);

  /// True if the the browser window (instead of the display canvas's DOM parent) should be used as the bounding parent.
  /// This is set automatically based on the `parent` argument passed to [Phaser.Game].
  /// The [Phaser.ScaleManager#parentNode parentNode] property is generally ignored while this is in effect.
  external bool get parentIsWindow;
  external set parentIsWindow(bool v);

  /// The scale of the game in relation to its parent container.
  external PhaserPoint get parentScaleFactor;
  external set parentScaleFactor(Point v);

  /// The _current_ scale factor based on the game dimensions vs. the scaled dimensions.
  external PhaserPoint get scaleFactor;
  external set scaleFactor(Point v);

  /// The _current_ inversed scale factor. The displayed dimensions divided by the game dimensions.
  external PhaserPoint get scaleFactorInversed;
  external set scaleFactorInversed(Point v);

  /// The scaling method used by the ScaleManager when not in fullscreen.
  /// <dl>
  /// <dt>[Phaser.ScaleManager.NO_SCALE]</dt>
  /// <dd>
  /// The Game display area will not be scaled - even if it is too large for the canvas/screen.
  /// This mode _ignores_ any applied scaling factor and displays the canvas at the Game size.
  /// </dd>
  /// <dt>[Phaser.ScaleManager.EXACT_FIT]</dt>
  /// <dd>
  /// The Game display area will be _stretched_ to fill the entire size of the canvas's parent element and/or screen.
  /// Proportions are not maintained.
  /// </dd>
  /// <dt>[Phaser.ScaleManager.SHOW_ALL]</dt>
  /// <dd>
  /// Show the entire game display area while _maintaining_ the original aspect ratio.
  /// </dd>
  /// <dt>[Phaser.ScaleManager.RESIZE]</dt>
  /// <dd>
  /// The dimensions of the game display area are changed to match the size of the parent container.
  /// That is, this mode _changes the Game size_ to match the display size.
  /// <p>
  /// Any manually set Game size (see [Phaser.ScaleManager#setGameSize setGameSize]) is ignored while in effect.
  /// </dd>
  /// <dt>[Phaser.ScaleManager.USER_SCALE]</dt>
  /// <dd>
  /// The game Display is scaled according to the user-specified scale set by [Phaser.ScaleManager#setUserScale setUserScale].
  /// <p>
  /// This scale can be adjusted in the [Phaser.ScaleManager#setResizeCallback resize callback]
  /// for flexible custom-sizing needs.
  /// </dd>
  /// </dl>
  external num get scaleMode;
  external set scaleMode(num v);

  /// The _last known_ orientation of the screen, as defined in the Window Screen Web API.
  /// See [Phaser.DOM.getScreenOrientation] for possible values.
  external String get screenOrientation;
  external set screenOrientation(String v);

  /// The aspect ratio of the original game dimensions.
  external num get sourceAspectRatio;
  external set sourceAspectRatio(num v);

  /// The maximum time (in ms) between dimension update checks for the Canvas's parent element (or window).
  /// Update checks normally happen quicker in response to other events.
  /// Default: 2000
  external num get trackParentInterval;
  external set trackParentInterval(num v);

  /// Target width (in pixels) of the Display canvas.
  external num get width;
  external set width(num v);

  /// The edges on which to constrain the game Display/canvas in _addition_ to the restrictions of the parent container.
  /// The properties are strings and can be '', 'visual', 'layout', or 'layout-soft'.
  /// - If 'visual', the edge will be constrained to the Window / displayed screen area
  /// - If 'layout', the edge will be constrained to the CSS Layout bounds
  /// - An invalid value is treated as 'visual'
  /// Default: {"right":"layout","bottom":""}
  external dynamic
      /*{
            bottom: string;
            right: string;
        }*/
      get windowConstraints;
  external set windowConstraints(
      dynamic /*{
            bottom: string;
            right: string;
        }*/
      v);

  /// Shorthand for setting [Phaser.ScaleManager#pageAlignHorizontally pageAlignHorizontally] and [Phaser.ScaleManager#pageAlignVertically pageAlignVertically].
  external void align([bool horizontal, bool vertical]);

  /// Start the ScaleManager.
  external void boot();

  /// Creates a fullscreen target. This is called automatically as as needed when entering
  /// fullscreen mode and the resulting element is supplied to [Phaser.ScaleManager#onFullScreenInit onFullScreenInit].
  /// Use [Phaser.ScaleManager#onFullScreenInit onFullScreenInit] to customize the created object.
  external DivElement createFullScreenTarget();

  /// Destroys the ScaleManager and removes any event listeners.
  /// This should probably only be called when the game is destroyed.
  external void destroy();

  /// Force the game to run in only one orientation.
  /// This enables generation of incorrect orientation signals and affects resizing but does not otherwise rotate or lock the orientation.
  /// Orientation checks are performed via the Screen Orientation API, if available in browser. This means it will check your monitor
  /// orientation on desktop, or your device orientation on mobile, rather than comparing actual game dimensions. If you need to check the
  /// viewport dimensions instead and bypass the Screen Orientation API then set: `ScaleManager.compatibility.orientationFallback = 'viewport'`
  external void forceOrientation(bool forceLandscape, [bool forcePortrait]);

  /// Returns the computed Parent size/bounds that the Display canvas is allowed/expected to fill.
  /// If in fullscreen mode or without parent (see [Phaser.ScaleManager#parentIsWindow parentIsWindow]),
  /// this will be the bounds of the visual viewport itself.
  /// This function takes the [Phaser.ScaleManager#windowConstraints windowConstraints] into consideration - if the parent is partially outside
  /// the viewport then this function may return a smaller than expected size.
  /// Values are rounded to the nearest pixel.
  external Rectangle getParentBounds([Rectangle target]);

  /// Load configuration settings.
  external void parseConfig(dynamic config);

  /// The ScaleManager.preUpdate is called automatically by the core Game loop.
  external void preUpdate();

  /// Update method while paused.
  external void pauseUpdate();

  /// The "refresh" methods informs the ScaleManager that a layout refresh is required.
  /// The ScaleManager automatically queues a layout refresh (eg. updates the Game size or Display canvas layout)
  /// when the browser is resized, the orientation changes, or when there is a detected change
  /// of the Parent size. Refreshing is also done automatically when public properties,
  /// such as [Phaser.ScaleManager#scaleMode scaleMode], are updated or state-changing methods are invoked.
  /// The "refresh" method _may_ need to be used in a few (rare) situtations when
  /// - a device change event is not correctly detected; or
  /// - the Parent size changes (and an immediate reflow is desired); or
  /// - the ScaleManager state is updated by non-standard means; or
  /// - certain [Phaser.ScaleManager#compatibility compatibility] properties are manually changed.
  /// The queued layout refresh is not immediate but will run promptly in an upcoming `preRender`.
  external void refresh();

  /// Set the actual Game size.
  /// Use this instead of directly changing `game.width` or `game.height`.
  /// The actual physical display (Canvas element size) depends on various settings including
  /// - Scale mode
  /// - Scaling factor
  /// - Size of Canvas's parent element or CSS rules such as min-height/max-height;
  /// - The size of the Window
  external void setGameSize(num width, num height);

  /// Sets the callback that will be invoked before sizing calculations.
  /// Typically this is triggered when the Scale Manager has detected a change to the canvas's boundaries:
  /// the browser window has been resized, the device has been rotated, or the parent container's size has changed.
  /// At this point the Scale Manager has not resized the game or canvas yet (and may not resize them at all
  /// after it makes its sizing calculations). You can read the size of the parent container from the
  /// `parentBounds` argument to the callback.
  /// This is the appropriate place to call [Phaser.ScaleManager#setUserScale setUserScale] if needing custom dynamic scaling.
  /// The callback is supplied with two arguments `scale` and `parentBounds` where `scale` is the ScaleManager
  /// and `parentBounds`, a Phaser.Rectangle, is the size of the Parent element.
  /// This callback
  /// - May be invoked even though the parent container or canvas sizes have not changed
  /// - Unlike [Phaser.ScaleManager#onSizeChange onSizeChange], it runs _before_ the canvas is guaranteed to be updated
  /// - Will be invoked from `preUpdate`, _even when_ the game is paused
  /// See [Phaser.ScaleManager#onSizeChange onSizeChange] for a better way of reacting to layout updates.
  external void setResizeCallback(ResizeCallback callback, dynamic context);

  /// Set a User scaling factor used in the USER_SCALE scaling mode.
  /// The target canvas size is computed by:
  /// canvas.width = (game.width * hScale) - hTrim
  /// canvas.height = (game.height * vScale) - vTrim
  /// This method can be used in the [Phaser.ScaleManager#setResizeCallback resize callback]. Set `queueUpdate` and `force` to false if the resize callback is being called repeatedly.
  external void setUserScale(num hScale, num vScale,
      [num hTrim, num vTrim, bool queueUpdate, bool force]);

  /// Set the min and max dimensions for the Display canvas.
  /// _Note:_ The min/max dimensions are only applied in some cases
  /// - When the device is not in an incorrect orientation; or
  /// - The scale mode is EXACT_FIT when not in fullscreen
  external void setMinMax(num minWidth, num minHeight,
      [num maxWidth, num maxHeight]);

  /// Calculates and sets the game dimensions based on the given width and height.
  /// This should _not_ be called when in fullscreen mode.
  /*external void setupScale(num width, num height);*/
  /// Calculates and sets the game dimensions based on the given width and height.
  /// This should _not_ be called when in fullscreen mode.
  /*external void setupScale(String width, String height);*/
  external void setupScale(
      dynamic /*num|String*/ width, dynamic /*num|String*/ height);

  /// Takes a Sprite or Image object and scales it to fit the given dimensions.
  /// Scaling happens proportionally without distortion to the sprites texture.
  /// The letterBox parameter controls if scaling will produce a letter-box effect or zoom the
  /// sprite until it fills the given values. Note that with letterBox set to false the scaled sprite may spill out over either
  /// the horizontal or vertical sides of the target dimensions. If you wish to stop this you can crop the Sprite.
  /*external Sprite scaleSprite(Sprite sprite,
    [num width, num height, bool letterBox]);*/
  /// Takes a Sprite or Image object and scales it to fit the given dimensions.
  /// Scaling happens proportionally without distortion to the sprites texture.
  /// The letterBox parameter controls if scaling will produce a letter-box effect or zoom the
  /// sprite until it fills the given values. Note that with letterBox set to false the scaled sprite may spill out over either
  /// the horizontal or vertical sides of the target dimensions. If you wish to stop this you can crop the Sprite.
  /*external Sprite scaleSprite(Image sprite,
    [num width, num height, bool letterBox]);*/
  external Sprite scaleSprite(dynamic /*Sprite|Image*/ sprite,
      [num width, num height, bool letterBox]);

  /// Display the game in the browser's fullscreen mode.
  /// This _must_ be called from a user-input Pointer or Mouse event (and possibly a [https://www.chromestatus.com/feature/6131337345892352 "user gesture"]), e.g.,
  /// - [Phaser.Events#onInputUp]
  /// - [Phaser.Input#onUp] or [Phaser.Input#onTap]
  /// - `click`, `mousedown`, `mouseup`, `pointerup`, or `touchend`
  /// Games within an iframe will also be blocked from fullscreen unless the iframe has the `allowfullscreen` attribute.
  /// The [https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API Fullscreen API] must be [http://caniuse.com/#search=fullscreen supported by the browser] for this to work - it is not the same as setting
  /// the game size to fill the browser window. See [Phaser.ScaleManager#compatibility compatibility.supportsFullScreen] to check if the current
  /// device is reported to support fullscreen mode.
  /// The [Phaser.ScaleManager#fullScreenFailed fullScreenFailed] signal will be dispatched if the fullscreen change request failed or the game does not support the Fullscreen API.
  /// Safari blocks access to keyboard events in fullscreen mode (as a security measure).
  external bool startFullScreen([bool antialias, bool allowTrampoline]);

  /// Stops / exits fullscreen mode, if active.
  external bool stopFullScreen();
}

/// DOM utility class.
/// Provides a useful Window and Element functions as well as cross-browser compatibility buffer.
/// Some code originally derived from [https://github.com/ryanve/verge verge].
/// Some parts were inspired by the research of Ryan Van Etten, released under MIT License 2013.
@JS("Phaser.DOM")
class DOM {
  // @Ignore
  DOM.fakeConstructor$();

  /// The bounds of the Visual viewport, as discussed in
  /// [http://www.quirksmode.org/mobile/viewports.html A tale of two viewports  part one]
  /// with one difference: the viewport size _excludes_ scrollbars, as found on some desktop browsers.
  /// Supported mobile:
  /// iOS/Safari, Android 4, IE10, Firefox OS (maybe not Firefox Android), Opera Mobile 16
  /// The properties change dynamically.
  external static Rectangle get visualBounds;
  external static set visualBounds(Rectangle v);

  /// The bounds of the Layout viewport, as discussed in
  /// [http://www.quirksmode.org/mobile/viewports2.html A tale of two viewports  part two];
  /// but honoring the constraints as specified applicable viewport meta-tag.
  /// The bounds returned are not guaranteed to be fully aligned with CSS media queries (see
  /// [http://www.matanich.com/2013/01/07/viewport-size/ What size is my viewport?]).
  /// This is _not_ representative of the Visual bounds: in particular the non-primary axis will
  /// generally be significantly larger than the screen height on mobile devices when running with a
  /// constrained viewport.
  /// The properties change dynamically.
  external static Rectangle get layoutBounds;
  external static set layoutBounds(Rectangle v);

  /// The size of the document / Layout viewport.
  /// This incorrectly reports the dimensions in IE.
  /// The properties change dynamically.
  external static Rectangle get documentBounds;
  external static set documentBounds(Rectangle v);

  /// Calibrates element coordinates for `inLayoutViewport` checks.
  external static dynamic calibrate(dynamic coords, [num cushion]);

  /// Get the Visual viewport aspect ratio (or the aspect ratio of an object or element)
  external static num getAspectRatio(dynamic object);

  /// Returns the device screen orientation.
  /// Orientation values: 'portrait-primary', 'landscape-primary', 'portrait-secondary', 'landscape-secondary'.
  /// Order of resolving:
  /// - Screen Orientation API, or variation of - Future track. Most desktop and mobile browsers.
  /// - Screen size ratio check - If fallback is 'screen', suited for desktops.
  /// - Viewport size ratio check - If fallback is 'viewport', suited for mobile.
  /// - window.orientation - If fallback is 'window.orientation', works iOS and probably most Android; non-recommended track.
  /// - Media query
  /// - Viewport size ratio check (probably only IE9 and legacy mobile gets here..)
  /// See
  /// - https://w3c.github.io/screen-orientation/ (conflicts with mozOrientation/msOrientation)
  /// - https://developer.mozilla.org/en-US/docs/Web/API/Screen.orientation (mozOrientation)
  /// - http://msdn.microsoft.com/en-us/library/ie/dn342934(v=vs.85).aspx
  /// - https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Testing_media_queries
  /// - http://stackoverflow.com/questions/4917664/detect-viewport-orientation
  /// - http://www.matthewgifford.com/blog/2011/12/22/a-misconception-about-window-orientation
  external static String getScreenOrientation([String primaryFallback]);

  /// A cross-browser element.getBoundingClientRect method with optional cushion.
  /// Returns a plain object containing the properties `top/bottom/left/right/width/height` with respect to the top-left corner of the current viewport.
  /// Its properties match the native rectangle.
  /// The cushion parameter is an amount of pixels (+/-) to cushion the element.
  /// It adjusts the measurements such that it is possible to detect when an element is near the viewport.
  external static dynamic getBounds(dynamic element, [num cushion]);

  /// Get the [absolute] position of the element relative to the Document.
  /// The value may vary slightly as the page is scrolled due to rounding errors.
  external static PhaserPoint getOffset(dynamic element, [Point point]);

  /// Tests if the given DOM element is within the Layout viewport.
  /// The optional cushion parameter allows you to specify a distance.
  /// inLayoutViewport(element, 100) is `true` if the element is in the viewport or 100px near it.
  /// inLayoutViewport(element, -100) is `true` if the element is in the viewport or at least 100px near it.
  external static bool inLayoutViewport(dynamic element, [num cushion]);
}

/// This is a base State class which can be extended if you are creating your own game.
/// It provides quick access to common functions such as the camera, cache, input, match, sound and more.
/// #### Callbacks
/// | start | preload     | loaded     | paused       | stop     |
/// |-------|-------------|------------|--------------|----------|
/// | init  |             |            |              |          |
/// |       | preload     | create     | paused       |          |
/// |       | loadUpdate* | update*    | pauseUpdate* |          |
/// |       |             | preRender* |              |          |
/// |       | loadRender* | render*    | render*      |          |
/// |       |             |            | resumed      |          |
/// |       |             |            |              | shutdown |
/// Update and render calls (*) are repeated.
/// If your State has a constructor, it will be invoked exactly once, during [{@link Phaser.StateManager#add].
@JS("Phaser.State")
class State {
  // @Ignore
  State.fakeConstructor$();

  /// A reference to the GameObjectFactory which can be used to add new objects to the World.
  external GameObjectFactory get add;
  external set add(GameObjectFactory v);

  /// A reference to the game cache which contains any loaded or generated assets, such as images, sound and more.
  external Cache get cache;
  external set cache(Cache v);

  /// A handy reference to World.camera.
  external Camera get camera;
  external set camera(Camera v);

  /// This is a reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// A reference to the Input Manager.
  external Input get input;
  external set input(Input v);

  /// The string based identifier given to the State when added into the State Manager.
  external String get key;
  external set key(String v);

  /// A reference to the Loader, which you mostly use in the preload method of your state to load external assets.
  external Loader get load;
  external set load(Loader v);

  /// A reference to the GameObjectCreator which can be used to make new objects.
  external GameObjectCreator get make;
  external set make(GameObjectCreator v);

  /// The Particle Manager. It is called during the core gameloop and updates any Particle Emitters it has created.
  external Particles get particles;
  external set particles(Particles v);

  /// A reference to the physics manager which looks after the different physics systems available within Phaser.
  external Physics get physics;
  external set physics(Physics v);

  /// A reference to the seeded and repeatable random data generator.
  external RandomDataGenerator get rnd;
  external set rnd(RandomDataGenerator v);

  /// A reference to the Scale Manager which controls the way the game scales on different displays.
  external ScaleManager get scale;
  external set scale(ScaleManager v);

  /// A reference to the Sound Manager which can create, play and stop sounds, as well as adjust global volume.
  external SoundManager get sound;
  external set sound(SoundManager v);

  /// A reference to the Stage.
  external Stage get stage;
  external set stage(Stage v);

  /// A reference to the State Manager, which controls state changes.
  external StateManager get state;
  external set state(StateManager v);

  /// A reference to the game clock and timed events system.
  external Time get time;
  external set time(Time v);

  /// A reference to the tween manager.
  external TweenManager get tweens;
  external set tweens(TweenManager v);

  /// A reference to the game world. All objects live in the Game World and its size is not bound by the display resolution.
  external World get world;
  external set world(World v);

  /// create is called once preload has completed, this includes the loading of any assets from the Loader.
  /// If you don't have a preload method then create is the first method called in your State.
  external void create(Game game);

  /// init is the very first function called when your State starts up. It's called before preload, create or anything else.
  /// If you need to route the game away to another State you could do so here, or if you need to prepare a set of variables
  /// or objects before the preloading starts.
  external void init(
      [dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// loadRender is called during the Loader process. This only happens if you've set one or more assets to load in the preload method.
  /// The difference between loadRender and render is that any objects you render in this method you must be sure their assets exist.
  external void loadRender(Game game);

  /// loadUpdate is called during the Loader process. This only happens if you've set one or more assets to load in the preload method.
  external void loadUpdate(Game game);

  /// This method will be called if the core game loop is paused.
  external void paused(Game game);

  /// pauseUpdate is called while the game is paused instead of preUpdate, update and postUpdate.
  external void pauseUpdate(Game game);

  /// preload is called first. Normally you'd use this to load your game assets (or those needed for the current State)
  /// You shouldn't create any objects in this method that require assets that you're also loading in this method, as
  /// they won't yet be available.
  external void preload(Game game);

  /// The preRender method is called after all Game Objects have been updated, but before any rendering takes place.
  external void preRender(Game game, num elapsedTime);

  /// Nearly all display objects in Phaser render automatically, you don't need to tell them to render.
  /// However the render method is called AFTER the game renderer and plugins have rendered, so you're able to do any
  /// final post-processing style effects here. Note that this happens before plugins postRender takes place.
  external void render(Game game);

  /// If your game is set to Scalemode RESIZE then each time the browser resizes it will call this function, passing in the new width and height.
  external void resize(num width, num height);

  /// This method will be called when the core game loop resumes from a paused state.
  external void resumed(Game game);

  /// This method will be called when the State is shutdown (i.e. you switch to another state from this one).
  external void shutdown(Game game);

  /// The update method is left empty for your own use.
  /// It is called during the core game loop AFTER debug, physics, plugins and the Stage have had their preUpdate methods called.
  /// It is called BEFORE Stage, Tweens, Sounds, Input, Physics, Particles and Plugins have had their postUpdate methods called.
  external void update(Game game);
}

@anonymous
@JS()
abstract class IStateCycle {
  external void preUpdate();
  external void update();
  external void render();
  external void postRender();
  external void destroy();
}

/// The State Manager is responsible for loading, setting up and switching game states.
@JS("Phaser.StateManager")
class StateManager {
  // @Ignore
  StateManager.fakeConstructor$();

  /// The State Manager is responsible for loading, setting up and switching game states.
  external factory StateManager(Game game, [State pendingState]);

  /// True if the current state has had its `create` method run (if it has one, if not this is true by default).
  external bool get created;
  external set created(bool v);

  /// The current active State object.
  external String get current;
  external set current(String v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// This is called when the state preload has finished and creation begins.
  external Function get onCreateCallback;
  external set onCreateCallback(Function v);

  /// This is called when the state is set as the active state.
  external Function get onInitCallback;
  external set onInitCallback(Function v);

  /// This is called when the State is rendered during the preload phase.
  external Function get onLoadRenderCallback;
  external set onLoadRenderCallback(Function v);

  /// This is called when the State is updated during the preload phase.
  external Function get onLoadUpdateCallback;
  external set onLoadUpdateCallback(Function v);

  /// This is called when the game is paused.
  external Function get onPausedCallback;
  external set onPausedCallback(Function v);

  /// This is called every frame while the game is paused.
  external Function get onPauseUpdateCallback;
  external set onPauseUpdateCallback(Function v);

  /// This is called when the state starts to load assets.
  external Function get onPreloadCallback;
  external set onPreloadCallback(Function v);

  /// This is called before the state is rendered and before the stage is cleared but after all game objects have had their final properties adjusted.
  external Function get onPreRenderCallback;
  external set onPreRenderCallback(Function v);

  /// This is called post-render. It doesn't happen during preload (see onLoadRenderCallback).
  external Function get onRenderCallback;
  external set onRenderCallback(Function v);

  /// This is called when the game is resumed from a paused state.
  external Function get onResumedCallback;
  external set onResumedCallback(Function v);

  /// This is called if ScaleManager.scalemode is RESIZE and a resize event occurs. It's passed the new width and height.
  external Function get onResizeCallback;
  external set onResizeCallback(Function v);

  /// This is called when the state is shut down (i.e. swapped to another state).
  external Function get onShutDownCallback;
  external set onShutDownCallback(Function v);

  /// This is called when the state is updated, every game loop. It doesn't happen during preload (@see onLoadUpdateCallback).
  external Function get onUpdateCallback;
  external set onUpdateCallback(Function v);

  /// The object containing Phaser.States.
  external dynamic get states;
  external set states(dynamic v);

  /// onStateChange is a Phaser.Signal that is dispatched whenever the game changes state.
  /// It is dispatched only when the new state is started, which isn't usually at the same time as StateManager.start
  /// is called because state swapping is done in sync with the game loop. It is dispatched *before* any of the new states
  /// methods (such as preload and create) are called, and *after* the previous states shutdown method has been run.
  /// The callback you specify is sent two parameters: the string based key of the new state,
  /// and the second parameter is the string based key of the old / previous state.
  external Signal get onStateChange;
  external set onStateChange(Signal v);

  /// Adds a new State into the StateManager. You must give each State a unique key by which you'll identify it.
  /// The State can be any of
  /// - a plain JavaScript object containing at least one required callback (see [Phaser.StateManager#checkState checkState])
  /// - an instance of [Phaser.State]
  /// - an instance of a class extending Phaser.State
  /// - a constructor function (class)
  /// If a function is given a new state object will be created by calling it, passing the current [Phaser.Game game] as the first argument.
  external void add(String key, dynamic state, [bool autoStart]);

  /// Checks if a given phaser state is valid. A State is considered valid if it has at least one of the core functions: preload, create, update or render.
  external bool checkState(String key);

  /// This method clears the current State, calling its shutdown callback. The process also removes any active tweens,
  /// resets the camera, resets input, clears physics, removes timers and if set clears the world and cache too.
  external void clearCurrentState();

  /// Removes all StateManager callback references to the State object, nulls the game reference and clears the States object.
  /// You don't recover from this without rebuilding the Phaser instance again.
  external void destroy();

  /// Gets the current State.
  external State getCurrentState();

  /// Links game properties to the State given by the key.
  external void link(String key);
  external void loadComplete();
  external void preRender(num elapsedTime);

  /// preUpdate is called right at the start of the game loop. It is responsible for changing to a new state that was requested previously.
  external void preUpdate();
  external void render();

  /// Delete the given state.
  external void remove(String key);
  external void resume();

  /// Restarts the current State. State.shutDown will be called (if it exists) before the State is restarted.
  external void restart(
      [bool clearWorld,
      bool clearCache,
      dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);
  external void resize(num width, num height);

  /// Start the given State. If a State is already running then State.shutDown will be called (if it exists) before switching to the new State.
  external void start(String key,
      [bool clearWorld,
      bool clearCache,
      dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);
  external void update();

  /// Nulls all State level Phaser properties, including a reference to Game.
  external void unlink(String key);
}

@anonymous
@JS()
abstract class PhaserTextStyle {
  external String get font;
  external set font(String v);
  external dynamic get fill;
  external set fill(dynamic v);
  external String get align;
  external set align(String v);
  external String get stroke;
  external set stroke(String v);
  external num get strokeThickness;
  external set strokeThickness(num v);
  external bool get wordWrap;
  external set wordWrap(bool v);
  external num get wordWrapWidth;
  external set wordWrapWidth(num v);
  external num get maxLines;
  external set maxLines(num v);
  external num get shadowOffsetX;
  external set shadowOffsetX(num v);
  external num get shadowOffsetY;
  external set shadowOffsetY(num v);
  external String get shadowColor;
  external set shadowColor(String v);
  external num get shadowBlur;
  external set shadowBlur(num v);
  external String get valign;
  external set valign(String v);
  external num get tab;
  external set tab(num v);
  external num get tabs;
  external set tabs(num v);
  external num get fontSize;
  external set fontSize(num v);
  external String get fontStyle;
  external set fontStyle(String v);
  external String get fontVariant;
  external set fontVariant(String v);
  external dynamic /*String|num*/ get fontWeight;
  external set fontWeight(dynamic /*String|num*/ v);
  external String get backgroundColor;
  external set backgroundColor(String v);
  external String get boundsAlignH;
  external set boundsAlignH(String v);
  external String get boundsAlignV;
  external set boundsAlignV(String v);
  external factory PhaserTextStyle(
      {String font,
      dynamic fill,
      String align,
      String stroke,
      num strokeThickness,
      bool wordWrap,
      num wordWrapWidth,
      num maxLines,
      num shadowOffsetX,
      num shadowOffsetY,
      String shadowColor,
      num shadowBlur,
      String valign,
      num tab,
      num tabs,
      num fontSize,
      String fontStyle,
      String fontVariant,
      dynamic /*String|num*/ fontWeight,
      String backgroundColor,
      String boundsAlignH,
      String boundsAlignV});
}

/// Create a new game object for displaying Text.
/// This uses a local hidden Canvas object and renders the type into it. It then makes a texture from this for rendering to the view.
/// Because of this you can only display fonts that are currently loaded and available to the browser: fonts must be pre-loaded.
/// See [http://www.jordanm.co.uk/tinytype this compatibility table] for the available default fonts across mobile browsers.
@JS("Phaser.Text")
class Text extends Sprite {
  // @Ignore
  Text.fakeConstructor$() : super.fakeConstructor$();

  /// Create a new game object for displaying Text.
  /// This uses a local hidden Canvas object and renders the type into it. It then makes a texture from this for rendering to the view.
  /// Because of this you can only display fonts that are currently loaded and available to the browser: fonts must be pre-loaded.
  /// See [http://www.jordanm.co.uk/tinytype this compatibility table] for the available default fonts across mobile browsers.
  external factory Text(Game game, num x, num y, String text,
      [PhaserTextStyle style]);
  external static dynamic get fontPropertiesCanvas;
  external static set fontPropertiesCanvas(dynamic v);
  external static dynamic get fontPropertiesContext;
  external static set fontPropertiesContext(dynamic v);
  external static dynamic get fontPropertiesCache;
  external static set fontPropertiesCache(dynamic v);

  /// Controls the horizontal alignment for multiline text.
  /// Can be: 'left', 'center' or 'right'.
  /// Does not affect single lines of text. For that please see `setTextBounds`.
  external String get align;
  external set align(String v);

  /// The angle property is the rotation of the Game Object in *degrees* from its original orientation.
  /// Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.
  /// Values outside this range are added to or subtracted from 360 to obtain a value within the range.
  /// For example, the statement player.angle = 450 is the same as player.angle = 90.
  /// If you wish to work in radians instead of degrees you can use the property `rotation` instead.
  /// Working in radians is slightly faster as it doesn't have to perform any calculations.
  external num get angle;
  external set angle(num v);

  /// Should the linePositionX and Y values be automatically rounded before rendering the Text?
  /// You may wish to enable this if you want to remove the effect of sub-pixel aliasing from text.
  external bool get autoRound;
  external set autoRound(bool v);

  /// Horizontal alignment of the text within the `textBounds`. Can be: 'left', 'center' or 'right'.
  external String get boundsAlignH;
  external set boundsAlignH(String v);

  /// Vertical alignment of the text within the `textBounds`. Can be: 'top', 'middle' or 'bottom'.
  external String get boundsAlignV;
  external set boundsAlignV(String v);

  /// The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.
  /// The values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.
  external PhaserPoint get cameraOffset;
  external set cameraOffset(Point v);

  /// The canvas element that the text is rendered.
  external CanvasElement get canvas;
  external set canvas(CanvasElement v);

  /// An array of the color values as specified by [Phaser.Text#addColor addColor].
  external List<String> get colors;
  external set colors(List<String> v);

  /// The context of the canvas element that the text is rendered to.
  external CanvasRenderingContext2D get context;
  external set context(CanvasRenderingContext2D v);

  /// Change the font used.
  /// This is equivalent of the `font` property specified to [Phaser.Text#setStyle setStyle], except
  /// that unlike using `setStyle` this will not change any current font fill/color settings.
  /// The CSS font string can also be individually altered with the `font`, `fontSize`, `fontWeight`, `fontStyle`, and `fontVariant` properties.
  external String get cssFont;
  external set cssFont(String v);

  /// As a Game Object runs through its destroy method this flag is set to true,
  /// and can be checked in any sub-systems or plugins it is being destroyed from.
  external bool get destroyPhase;
  external set destroyPhase(bool v);

  /// All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this
  /// Game Object, or any of its components.
  external Events get events;
  external set events(Events v);

  /// Controls if this Sprite is processed by the core Phaser game loops and Group loops (except [Phaser.Group#update]).
  /// Default: true
  external bool get exists;
  external set exists(bool v);

  /// A canvas fillstyle that will be used on the text eg 'red', '#00FF00'.
  external dynamic get fill;
  external set fill(dynamic v);

  /// A Game Object that is "fixed" to the camera is rendered at a given x/y offsets from the top left of the camera. The offsets
  /// are stored in the `cameraOffset` property, which is initialized with the current object coordinates.
  /// The values are adjusted at the rendering stage, overriding the Game Objects actual world position.
  /// The end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world
  /// the camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times
  /// regardless where in the world the camera is.
  /// Note that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.
  /// Be careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.
  external bool get fixedToCamera;
  external set fixedToCamera(bool v);

  /// Change the font family that the text will be rendered in, such as 'Arial'.
  /// Multiple CSS font families and generic fallbacks can be specified as long as
  /// [http://www.w3.org/TR/CSS2/fonts.html#propdef-font-family CSS font-family rules] are followed.
  /// To change the entire font string use [Phaser.Text#cssFont cssFont] instead: eg. `text.cssFont = 'bold 20pt Arial'`.
  external String get font;
  external set font(String v);

  /// The size of the font.
  /// If the font size is specified in pixels (eg. `32` or `'32px`') then a number (ie. `32`) representing
  /// the font size in pixels is returned; otherwise the value with CSS unit is returned as a string (eg. `'12pt'`).
  external dynamic /*num|String*/ get fontSize;
  external set fontSize(dynamic /*num|String*/ v);

  /// The style of the font: 'normal', 'italic', 'oblique'
  external String get fontStyle;
  external set fontStyle(String v);

  /// An array of the font styles values as specified by [Phaser.Text#addFontStyle addFontStyle].
  external List<String> get fontStyles;
  external set fontStyles(List<String> v);

  /// The variant the font: 'normal', 'small-caps'
  external String get fontVariant;
  external set fontVariant(String v);

  /// The weight of the font: 'normal', 'bold', or [http://www.w3.org/TR/CSS2/fonts.html#propdef-font-weight a valid CSS font weight].
  external dynamic /*String|num*/ get fontWeight;
  external set fontWeight(dynamic /*String|num*/ v);

  /// An array of the font weights values as specified by [Phaser.Text#addFontWeight addFontWeight].
  external List<dynamic /*String|num*/ > get fontWeights;
  external set fontWeights(List<dynamic /*String|num*/ > v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// The Input Handler for this Game Object.
  /// By default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.
  /// After you have done this, this property will be a reference to the Phaser InputHandler.
  external InputHandler get input;
  external set input(InputHandler v);

  /// By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created
  /// for this Game Object and it will then start to process click / touch events and more.
  /// You can then access the Input Handler via `this.input`.
  /// Note that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.
  /// If you set this property to false it will stop the Input Handler from processing any more input events.
  /// If you want to _temporarily_ disable input for a Game Object, then it's better to set
  /// `input.enabled = false`, as it won't reset any of the Input Handlers internal properties.
  /// You can then toggle this back on as needed.
  external bool get inputEnabled;
  external set inputEnabled(bool v);

  /// Additional spacing (in pixels) between each line of text if multi-line.
  external num get lineSpacing;
  external set lineSpacing(num v);

  /// A user defined name given to this Game Object.
  /// This value isn't ever used internally by Phaser, it is meant as a game level property.
  external String get name;
  external set name(String v);

  /// Specify a padding value which is added to the line width and height when calculating the Text size.
  /// ALlows you to add extra spacing if Phaser is unable to accurately determine the true font dimensions.
  external PhaserPoint get padding;
  external set padding(Point v);

  /// A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.
  /// You can set it directly to allow you to flag an object to be destroyed on its next update.
  /// This is extremely useful if you wish to destroy an object from within one of its own callbacks
  /// such as with Buttons or other Input events.
  external bool get pendingDestroy;
  external set pendingDestroy(bool v);

  /// The const physics body type of this object.
  external num get physicsType;
  external set physicsType(num v);

  /// The coordinates, in pixels, of this DisplayObject, relative to its parent container.
  /// The value of this property does not reflect any positioning happening further up the display list.
  /// To obtain that value please see the `worldPosition` property.
  external PhaserPoint get position;
  external set position(Point v);

  /// The position the Game Object was located in the previous frame.
  external PhaserPoint get previousPosition;
  external set previousPosition(Point v);

  /// The rotation the Game Object was in set to in the previous frame. Value is in radians.
  external num get previousRotation;
  external set previousRotation(num v);

  /// The render order ID is used internally by the renderer and Input Manager and should not be modified.
  /// This property is mostly used internally by the renderers, but is exposed for the use of plugins.
  external num get renderOrderID;
  external set renderOrderID(num v);

  /// The resolution of the canvas the text is rendered to.
  /// This defaults to match the resolution of the renderer, but can be changed on a per Text object basis.
  external num get resolution;
  external set resolution(num v);

  /// The shadowBlur value. Make the shadow softer by applying a Gaussian blur to it. A number from 0 (no blur) up to approx. 10 (depending on scene).
  external num get shadowBlur;
  external set shadowBlur(num v);

  /// The color of the shadow, as given in CSS rgba format. Set the alpha component to 0 to disable the shadow.
  external String get shadowColor;
  external set shadowColor(String v);

  /// Sets if the drop shadow is applied to the Text fill.
  external bool get shadowFill;
  external set shadowFill(bool v);

  /// The shadowOffsetX value in pixels. This is how far offset horizontally the shadow effect will be.
  external num get shadowOffsetX;
  external set shadowOffsetX(num v);

  /// The shadowOffsetY value in pixels. This is how far offset vertically the shadow effect will be.
  external num get shadowOffsetY;
  external set shadowOffsetY(num v);

  /// Sets if the drop shadow is applied to the Text stroke.
  external bool get shadowStroke;
  external set shadowStroke(bool v);

  /// The Regular Expression that is used to split the text up into lines, in
  /// multi-line text. By default this is `/(?:\r\n|\r|\n)/`.
  /// You can change this RegExp to be anything else that you may need.
  external dynamic get splitRegExp;
  external set splitRegExp(dynamic v);

  /// A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'.
  external String get stroke;
  external set stroke(String v);

  /// An array of the stroke color values as specified by [Phaser.Text#addStrokeColor addStrokeColor].
  external List<String> get strokeColors;
  external set strokeColors(List<String> v);

  /// A number that represents the thickness of the stroke. Default is 0 (no stroke)
  external num get strokeThickness;
  external set strokeThickness(num v);

  /// The scale of this DisplayObject. A scale of 1:1 represents the DisplayObject
  /// at its default size. A value of 0.5 would scale this DisplayObject by half, and so on.
  /// The value of this property does not reflect any scaling happening further up the display list.
  /// To obtain that value please see the `worldScale` property.
  external PhaserPoint get scale;
  external set scale(Point v);
  external num get tab;
  external set tab(num v);

  /// The size (in pixels) of the tabs, for when text includes tab characters. 0 disables.
  /// Can be an integer or an array of varying tab sizes, one tab per element.
  /// For example if you set tabs to 100 then when Text encounters a tab it will jump ahead 100 pixels.
  /// If you set tabs to be `[100,200]` then it will set the first tab at 100px and the second at 200px.
  external dynamic /*num|List<num>*/ get tabs;
  external set tabs(dynamic /*num|List<num>*/ v);

  /// The text to be displayed by this Text object.
  /// Use a \n to insert a carriage return and split the text.
  /// The text will be rendered with any style currently set.
  external String get text;
  external set text(String v);

  /// The textBounds property allows you to specify a rectangular region upon which text alignment is based.
  /// See `Text.setTextBounds` for more details.
  external Rectangle get textBounds;
  external set textBounds(Rectangle v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// Will this Text object use Basic or Advanced Word Wrapping?
  /// Advanced wrapping breaks long words if they are the first of a line, and repeats the process as necessary.
  /// White space is condensed (e.g., consecutive spaces are replaced with one).
  /// Lines are trimmed of white space before processing.
  /// It throws an error if wordWrapWidth is less than a single character.
  external bool get useAdvancedWrap;
  external set useAdvancedWrap(bool v);

  /// The world coordinates of this Game Object in pixels.
  /// Depending on where in the display list this Game Object is placed this value can differ from `position`,
  /// which contains the x/y coordinates relative to the Game Objects parent.
  external PhaserPoint get world;
  external set world(Point v);

  /// Indicates if word wrap should be used.
  external bool get wordWrap;
  external set wordWrap(bool v);

  /// The width at which text will wrap.
  external num get wordWrapWidth;
  external set wordWrapWidth(num v);

  /// The z depth of this Game Object within its parent Group.
  /// No two objects in a Group can have the same z value.
  /// This value is adjusted automatically whenever the Group hierarchy changes.
  /// If you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.
  external num get z;
  external set z(num v);

  /// Set specific colors for certain characters within the Text.
  /// It works by taking a color value, which is a typical HTML string such as `#ff0000` or `rgb(255,0,0)` and a position.
  /// The position value is the index of the character in the Text string to start applying this color to.
  /// Once set the color remains in use until either another color or the end of the string is encountered.
  /// For example if the Text was `Photon Storm` and you did `Text.addColor('#ffff00', 6)` it would color in the word `Storm` in yellow.
  /// If you wish to change the stroke color see addStrokeColor instead.
  external Text addColor(String color, num position);

  /// Set specific font styles for certain characters within the Text.
  /// It works by taking a font style value, which is a typical string such as `normal`, `italic` or `oblique`.
  /// The position value is the index of the character in the Text string to start applying this font style to.
  /// Once set the font style remains in use until either another font style or the end of the string is encountered.
  /// For example if the Text was `Photon Storm` and you did `Text.addFontStyle('italic', 6)` it would font style in the word `Storm` in italic.
  /// If you wish to change the text font weight see addFontWeight instead.
  external Text addFontStyle(String style, num position);

  /// Set specific font weights for certain characters within the Text.
  /// It works by taking a font weight value, which is a typical string such as `normal`, `bold`, `bolder`, etc.
  /// The position value is the index of the character in the Text string to start applying this font weight to.
  /// Once set the font weight remains in use until either another font weight or the end of the string is encountered.
  /// For example if the Text was `Photon Storm` and you did `Text.addFontWeight('bold', 6)` it would font weight in the word `Storm` in bold.
  /// If you wish to change the text font style see addFontStyle instead.
  external Text addFontWeight(String weight, num position);

  /// Set specific stroke colors for certain characters within the Text.
  /// It works by taking a color value, which is a typical HTML string such as `#ff0000` or `rgb(255,0,0)` and a position.
  /// The position value is the index of the character in the Text string to start applying this color to.
  /// Once set the color remains in use until either another color or the end of the string is encountered.
  /// For example if the Text was `Photon Storm` and you did `Text.addColor('#ffff00', 6)` it would color in the word `Storm` in yellow.
  /// This has no effect if stroke is disabled or has a thickness of 0.
  /// If you wish to change the text fill color see addColor instead.
  external Text addStrokeColor(String color, num position);

  /// Aligns this Game Object within another Game Object, or Rectangle, known as the
  /// 'container', to one of 9 possible positions.
  /// The container must be a Game Object, or Phaser.Rectangle object. This can include properties
  /// such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world
  /// and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,
  /// TileSprites or Buttons.
  /// Please note that aligning a Sprite to another Game Object does **not** make it a child of
  /// the container. It simply modifies its position coordinates so it aligns with it.
  /// The position constants you can use are:
  /// `Phaser.TOP_LEFT`, `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`,
  /// `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`,
  /// `Phaser.BOTTOM_CENTER` and `Phaser.BOTTOM_RIGHT`.
  /// The Game Objects are placed in such a way that their _bounds_ align with the
  /// container, taking into consideration rotation, scale and the anchor property.
  /// This allows you to neatly align Game Objects, irrespective of their position value.
  /// The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final
  /// aligned position of the Game Object. For example:
  /// `sprite.alignIn(background, Phaser.BOTTOM_RIGHT, -20, -20)`
  /// Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.
  /// Think of the offsets as applying an adjustment to the containers bounds before the alignment takes place.
  /// So providing a negative offset will 'shrink' the container bounds by that amount, and providing a positive
  /// one expands it.
  external dynamic alignIn(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// Aligns this Game Object to the side of another Game Object, or Rectangle, known as the
  /// 'parent', in one of 11 possible positions.
  /// The parent must be a Game Object, or Phaser.Rectangle object. This can include properties
  /// such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world
  /// and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,
  /// TileSprites or Buttons.
  /// Please note that aligning a Sprite to another Game Object does **not** make it a child of
  /// the parent. It simply modifies its position coordinates so it aligns with it.
  /// The position constants you can use are:
  /// `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_TOP`,
  /// `Phaser.LEFT_CENTER`, `Phaser.LEFT_BOTTOM`, `Phaser.RIGHT_TOP`, `Phaser.RIGHT_CENTER`,
  /// `Phaser.RIGHT_BOTTOM`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER`
  /// and `Phaser.BOTTOM_RIGHT`.
  /// The Game Objects are placed in such a way that their _bounds_ align with the
  /// parent, taking into consideration rotation, scale and the anchor property.
  /// This allows you to neatly align Game Objects, irrespective of their position value.
  /// The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final
  /// aligned position of the Game Object. For example:
  /// `sprite.alignTo(background, Phaser.BOTTOM_RIGHT, -20, -20)`
  /// Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.
  /// Think of the offsets as applying an adjustment to the parents bounds before the alignment takes place.
  /// So providing a negative offset will 'shrink' the parent bounds by that amount, and providing a positive
  /// one expands it.
  external dynamic alignTo(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// Clears any text fill or stroke colors that were set by `addColor` or `addStrokeColor`.
  external Text clearColors();

  /// Clears any text styles or weights font that were set by `addFontStyle` or `addFontWeight`.
  external Text clearFontValues();

  /// Converts individual font components (see `fontToComponents`) to a short CSS font string.
  external String componentsToFont(dynamic components);

  /// Destroy this Text object, removing it from the group it belongs to.
  external void destroy([bool destroyChildren]);

  /// Converting a short CSS-font string into the relevant components.
  external dynamic fontToComponents(String font);

  /// Internal method called by the World postUpdate cycle.
  external void postUpdate();

  /// Converts the given array into a tab delimited string and then updates this Text object.
  /// This is mostly used when you want to display external data using tab stops.
  /// The array can be either single or multi dimensional depending on the result you need:
  /// `[ 'a', 'b', 'c' ]` would convert in to `"a\tb\tc"`.
  /// Where as:
  /// `[
  /// [ 'a', 'b', 'c' ],
  /// [ 'd', 'e', 'f']
  /// ]`
  /// would convert in to: `"a\tb\tc\nd\te\tf"`
  external Text parseList(List<dynamic> list);

  /// Runs the given text through the Text.runWordWrap function and returns
  /// the results as an array, where each element of the array corresponds to a wrapped
  /// line of text.
  /// Useful if you wish to control pagination on long pieces of content.
  external List<String> precalculateWordWrap(String text);

  /// Automatically called by World.preUpdate.
  external void preUpdate();

  /// Renders a line of text that contains tab characters if Text.tab > 0.
  /// Called automatically by updateText.
  external void renderTabLine(String line, num x, num y, [bool fill]);

  /// Sets a drop shadow effect on the Text. You can specify the horizontal and vertical distance of the drop shadow with the `x` and `y` parameters.
  /// The color controls the shade of the shadow (default is black) and can be either an `rgba` or `hex` value.
  /// The blur is the strength of the shadow. A value of zero means a hard shadow, a value of 10 means a very soft shadow.
  /// To remove a shadow already in place you can call this method with no parameters set.
  external Text setShadow(
      [num x,
      num y,
      dynamic color,
      num blur,
      bool shadowStroke,
      bool shadowFill]);

  /// Set the style of the text by passing a single style object to it.
  external Text setStyle([PhaserTextStyle style, bool update]);

  /// The text to be displayed by this Text object.
  /// Use a \n to insert a carriage return and split the text.
  /// The text will be rendered with any style currently set.
  /// Use the optional `immediate` argument if you need the Text display to update immediately.
  /// If not it will re-create the texture of this Text object during the next time the render
  /// loop is called.
  external Text setText(String text, [bool immediate]);

  /// The Text Bounds is a rectangular region that you control the dimensions of into which the Text object itself is positioned,
  /// regardless of the number of lines in the text, the font size or any other attribute.
  /// Alignment is controlled via the properties `boundsAlignH` and `boundsAlignV` within the Text.style object, or can be directly
  /// set through the setters `Text.boundsAlignH` and `Text.boundsAlignV`. Bounds alignment is independent of text alignment.
  /// For example: If your game is 800x600 in size and you set the text bounds to be 0,0,800,600 then by setting boundsAlignH to
  /// 'center' and boundsAlignV to 'bottom' the text will render in the center and at the bottom of your game window, regardless of
  /// how many lines of text there may be. Even if you adjust the text content or change the style it will remain at the bottom center
  /// of the text bounds.
  /// This is especially powerful when you need to align text against specific coordinates in your game, but the actual text dimensions
  /// may vary based on font (say for multi-lingual games).
  /// If `Text.wordWrapWidth` is greater than the width of the text bounds it is clamped to match the bounds width.
  /// Call this method with no arguments given to reset an existing textBounds.
  /// It works by calculating the final position based on the Text.canvas size, which is modified as the text is updated. Some fonts
  /// have additional padding around them which you can mitigate by tweaking the Text.padding property. It then adjusts the `pivot`
  /// property based on the given bounds and canvas size. This means if you need to set the pivot property directly in your game then
  /// you either cannot use `setTextBounds` or you must place the Text object inside another DisplayObject on which you set the pivot.
  external Text setTextBounds([num x, num y, num width, num height]);

  /// Override this function to handle any special update requirements.
  external void update();

  /// Updates the internal `style.font` if it now differs according to generation from components.
  external void updateFont(dynamic components);

  /// Updates a line of text, applying fill and stroke per-character colors or style and weight per-character font if applicable.
  external void updateLine(String text, [num x, num y]);

  /// Sets the Shadow on the Text.context based on the Style settings, or disables it if not enabled.
  /// This is called automatically by Text.updateText.
  external void updateShadow([bool state]);

  /// Updates the texture based on the canvas dimensions.
  external void updateTexture();
}

/// A Tile is a representation of a single tile within the Tilemap.
@JS("Phaser.Tile")
class Tile {
  // @Ignore
  Tile.fakeConstructor$();

  /// A Tile is a representation of a single tile within the Tilemap.
  external factory Tile(
      dynamic layer, num index, num x, num y, num width, num height);

  /// The alpha value at which this tile is drawn to the canvas.
  external num get alpha;
  external set alpha(num v);

  /// The sum of the y and height properties.
  external num get bottom;
  external set bottom(num v);
  external Function get callback;
  external set callback(Function v);
  external dynamic get callbackContext;
  external set callbackContext(dynamic v);

  /// The width of the tile in pixels.
  external num get centerX;
  external set centerX(num v);

  /// The height of the tile in pixels.
  external num get centerY;
  external set centerY(num v);

  /// True if this tile can collide on any of its faces or has a collision callback set.
  external bool get canCollide;
  external set canCollide(bool v);

  /// Indicating collide with any object on the bottom.
  external bool get collideDown;
  external set collideDown(bool v);

  /// Indicating collide with any object on the left.
  external bool get collideLeft;
  external set collideLeft(bool v);
  external bool get collideNone;
  external set collideNone(bool v);

  /// Indicating collide with any object on the right.
  external bool get collideRight;
  external set collideRight(bool v);

  /// Tile collision callback.
  external Function get collisionCallback;
  external set collisionCallback(Function v);

  /// The context in which the collision callback will be called.
  external dynamic get collisionCallbackContext;
  external set collisionCallbackContext(dynamic v);

  /// True if this tile can collide on any of its faces.
  external bool get collides;
  external set collides(bool v);

  /// Indicating collide with any object on the top.
  external bool get collideUp;
  external set collideUp(bool v);

  /// Is the bottom of this tile an interesting edge?
  external bool get faceBottom;
  external set faceBottom(bool v);

  /// Is the left of this tile an interesting edge?
  external bool get faceLeft;
  external set faceLeft(bool v);

  /// Is the right of this tile an interesting edge?
  external bool get faceRight;
  external set faceRight(bool v);

  /// Is the top of this tile an interesting edge?
  external bool get faceTop;
  external set faceTop(bool v);
  external Game get game;
  external set game(Game v);

  /// The height of the tile in pixels.
  external num get height;
  external set height(num v);

  /// The index of this tile within the map data corresponding to the tileset, or -1 if this represents a blank/null tile.
  external num get index;
  external set index(num v);

  /// The layer in the Tilemap data that this tile belongs to.
  external dynamic get layer;
  external set layer(dynamic v);

  /// The x value in pixels.
  external num get left;
  external set left(num v);

  /// Tile specific properties.
  external dynamic get properties;
  external set properties(dynamic v);

  /// The sum of the x and width properties.
  external num get right;
  external set right(num v);

  /// Has this tile been walked / turned into a poly?
  external bool get scanned;
  external set scanned(bool v);

  /// The y value.
  external num get top;
  external set top(num v);

  /// The width of the tile in pixels.
  external num get width;
  external set width(num v);

  /// The x map coordinate of this tile.
  external num get worldX;
  external set worldX(num v);

  /// The y map coordinate of this tile.
  external num get worldY;
  external set worldY(num v);

  /// The x map coordinate of this tile.
  external num get x;
  external set x(num v);

  /// The y map coordinate of this tile.
  external num get y;
  external set y(num v);

  /// Copies the tile data and properties from the given tile to this tile.
  external Tile copy(Tile tile);

  /// Check if the given x and y world coordinates are within this Tile.
  external bool containsPoint(num x, num y);

  /// Clean up memory.
  external void destroy();

  /// Check for intersection with this tile.
  external bool intersects(num x, num y, num right, num bottom);
  external bool isInterested(bool collides, bool faces);

  /// Reset collision status flags.
  external void resetCollision();

  /// Sets the collision flags for each side of this tile and updates the interesting faces list.
  external void setCollision(bool left, bool right, bool up, bool down);

  /// Set a callback to be called when this tile is hit by an object.
  /// The callback must true true for collision processing to take place.
  external void setCollisionCallback(Function callback, dynamic context);
}

/// Creates a new Phaser.Tilemap object. The map can either be populated with data from a Tiled JSON file or from a CSV file.
/// Tiled is a free software package specifically for creating tile maps, and is available from http://www.mapeditor.org
/// To do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.
/// When using CSV data you must provide the key and the tileWidth and tileHeight parameters.
/// If creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.
/// Note that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.
/// A Tile map is rendered to the display using a TilemapLayer. It is not added to the display list directly itself.
/// A map may have multiple layers. You can perform operations on the map data such as copying, pasting, filling and shuffling the tiles around.
@JS("Phaser.Tilemap")
class Tilemap {
  // @Ignore
  Tilemap.fakeConstructor$();

  /// Creates a new Phaser.Tilemap object. The map can either be populated with data from a Tiled JSON file or from a CSV file.
  /// Tiled is a free software package specifically for creating tile maps, and is available from http://www.mapeditor.org
  /// To do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.
  /// When using CSV data you must provide the key and the tileWidth and tileHeight parameters.
  /// If creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.
  /// Note that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.
  /// A Tile map is rendered to the display using a TilemapLayer. It is not added to the display list directly itself.
  /// A map may have multiple layers. You can perform operations on the map data such as copying, pasting, filling and shuffling the tiles around.
  external factory Tilemap(Game game,
      [String key, num tileWidth, num tileHeight, num width, num height]);
  external static num get CSV;
  external static set CSV(num v);
  external static num get TILED_JSON;
  external static set TILED_JSON(num v);
  external static num get NORTH;
  external static set NORTH(num v);
  external static num get EAST;
  external static set EAST(num v);
  external static num get SOUTH;
  external static set SOUTH(num v);
  external static num get WEST;
  external static set WEST(num v);

  /// An array of collision data (polylines, etc).
  external List<dynamic> get collision;
  external set collision(List<dynamic> v);

  /// An array of tile indexes that collide.
  external List<dynamic> get collideIndexes;
  external set collideIndexes(List<dynamic> v);

  /// The current layer.
  external num get currentLayer;
  external set currentLayer(num v);

  /// Map data used for debug values only.
  external List<dynamic> get debugMap;
  external set debugMap(List<dynamic> v);

  /// If set then console.log is used to dump out useful layer creation debug data.
  external bool get enableDebug;
  external set enableDebug(bool v);

  /// The format of the map data, either Phaser.Tilemap.CSV or Phaser.Tilemap.TILED_JSON.
  external num get format;
  external set format(num v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// The height of the map (in tiles).
  external num get height;
  external set height(num v);

  /// The height of the map in pixels based on height * tileHeight.
  external num get heightInPixels;
  external set heightInPixels(num v);

  /// An array of Tiled Image Layers.
  external List<dynamic> get images;
  external set images(List<dynamic> v);

  /// An array of Image Collections.
  external List<ImageCollection> get imagecollections;
  external set imagecollections(List<ImageCollection> v);

  /// The key of this map data in the Phaser.Cache.
  external String get key;
  external set key(String v);

  /// The current layer object.
  external List<TilemapLayer> get layer;
  external set layer(List<TilemapLayer> v);

  /// An array of Tilemap layer data.
  external List<dynamic> get layers;
  external set layers(List<dynamic> v);

  /// An array of Tiled Object Layers.
  external List<dynamic> get objects;
  external set objects(List<dynamic> v);

  /// The orientation of the map data (as specified in Tiled), usually 'orthogonal'.
  external String get orientation;
  external set orientation(String v);

  /// Map specific properties as specified in Tiled.
  external dynamic get properties;
  external set properties(dynamic v);
  external num get rayStepRate;
  external set rayStepRate(num v);

  /// The base height of the tiles in the map (in pixels).
  external num get tileHeight;
  external set tileHeight(num v);

  /// The super array of Tiles.
  external List<Tile> get tiles;
  external set tiles(List<Tile> v);

  /// An array of Tilesets.
  external List<Tileset> get tilesets;
  external set tilesets(List<Tileset> v);

  /// The base width of the tiles in the map (in pixels).
  external num get tileWidth;
  external set tileWidth(num v);

  /// The version of the map data (as specified in Tiled, usually 1).
  external num get version;
  external set version(num v);

  /// The width of the map (in tiles).
  external num get width;
  external set width(num v);

  /// The width of the map in pixels based on width * tileWidth.
  external num get widthInPixels;
  external set widthInPixels(num v);

  /// Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.
  /// Note that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled editor.
  /// If `undefined` or `null` it will look for an image with a key matching the tileset parameter.
  /// You can also pass in a BitmapData which can be used instead of an Image.
  external Tileset addTilesetImage(String tileset,
      [dynamic /*String|BitmapData*/ key,
      num tileWidth,
      num tileHeight,
      num tileMargin,
      num tileSpacing,
      num gid]);

  /// Internal function.
  external void calculateFaces(num layer);

  /// Copies all of the tiles in the given rectangular block into the tilemap data buffer.
  external List<Tile> copy(num x, num y, num width, num height,
      [dynamic layer]);

  /// Creates an empty map of the given dimensions and one blank layer. If layers already exist they are erased.
  external TilemapLayer create(
      String name, num width, num height, num tileWidth, num tileHeight,
      [Group group]);

  /// Creates a new and empty layer on this Tilemap. By default TilemapLayers are fixed to the camera.
  external TilemapLayer createBlankLayer(
      String name, num width, num height, num tileWidth, num tileHeight,
      [Group group]);

  /// Creates a Sprite for every [http://doc.mapeditor.org/reference/tmx-map-format/#object object] matching the `gid` argument. You can optionally specify the group that the Sprite will be created in. If none is
  /// given it will be created in the World. All properties from the map data objectgroup are copied across to the Sprite, so you can use this as an easy way to
  /// configure Sprite properties from within the map editor. For example giving an object a property of `alpha: 0.5` in the map editor will duplicate that when the
  /// Sprite is created. You could also give it a value like: `body.velocity.x: 100` to set it moving automatically.
  /// The `gid` argument is matched against:
  /// 1. For a tile object, the tile identifier (`gid`); or
  /// 2. The object's unique ID (`id`); or
  /// 3. The object's `name` (a string)
  external void createFromObjects(String name, num gid, String key,
      [dynamic frame,
      bool exists,
      bool autoCull,
      Group group,
      dynamic CustomClass,
      bool adjustY,
      bool adjustSize]);

  /// Creates a Sprite for every object matching the given tile indexes in the map data.
  /// You can specify the group that the Sprite will be created in. If none is given it will be created in the World.
  /// You can optional specify if the tile will be replaced with another after the Sprite is created. This is useful if you want to lay down special
  /// tiles in a level that are converted to Sprites, but want to replace the tile itself with a floor tile or similar once converted.
  external num createFromTiles(dynamic tiles, dynamic replacements, String key,
      [dynamic layer, Group group, dynamic properties]);

  /// Creates a new TilemapLayer object. By default TilemapLayers are fixed to the camera.
  /// The `layer` parameter is important. If you've created your map in Tiled then you can get this by looking in Tiled and looking at the Layer name.
  /// Or you can open the JSON file it exports and look at the layers[].name value. Either way it must match.
  /// If you wish to create a blank layer to put your own tiles on then see Tilemap.createBlankLayer.
  external TilemapLayer createLayer(dynamic layer,
      [num width, num height, Group group]);

  /// Removes all layer data from this tile map and nulls the game reference.
  /// Note: You are responsible for destroying any TilemapLayer objects you generated yourself, as Tilemap doesn't keep a reference to them.
  external void destroy();

  /// Dumps the tilemap data out to the console.
  external void dump();

  /// Fills the given area with the specified tile.
  external void fill(num index, num x, num y, num width, num height,
      [dynamic layer]);

  /// For each tile in the given area defined by x/y and width/height run the given callback.
  external void forEach(
      Function callback, dynamic context, num x, num y, num width, num height,
      [dynamic layer]);

  /// Gets the image index based on its name.
  external num getImageIndex(String name);

  /// Gets the layer index based on the layers name.
  external num getIndex(List<dynamic> location, String name);

  /// Gets the TilemapLayer index as used in the setCollision calls.
  external num getLayer(dynamic layer);

  /// Gets the layer index based on its name.
  external num getLayerIndex(String name);
  external num getObjectIndex(String name);

  /// Gets a tile from the Tilemap Layer. The coordinates are given in tile values.
  external Tile getTile(num x, num y, [dynamic layer, bool nonNull]);

  /// Gets the tile above the tile coordinates given.
  /// Mostly used as an internal function by calculateFaces.
  external Tile getTileAbove(num layer, num x, num y);

  /// Gets the tile below the tile coordinates given.
  /// Mostly used as an internal function by calculateFaces.
  external Tile getTileBelow(num layer, num x, num y);

  /// Gets the tile to the left of the tile coordinates given.
  /// Mostly used as an internal function by calculateFaces.
  external Tile getTileLeft(num layer, num x, num y);

  /// Gets the tile to the right of the tile coordinates given.
  /// Mostly used as an internal function by calculateFaces.
  external Tile getTileRight(num layer, num x, num y);

  /// Gets the tileset index based on its name.
  external num getTilesetIndex(String name);

  /// Gets a tile from the Tilemap layer. The coordinates are given in pixel values.
  external Tile getTileWorldXY(num x, num y,
      [num tileWidth,
      num tileHeight,
      dynamic /*num|String|TilemapLayer*/ layer,
      bool nonNull]);

  /// Checks if there is a tile at the given location.
  external bool hasTile(num x, num y, TilemapLayer layer);

  /// Pastes a previously copied block of tile data into the given x/y coordinates. Data should have been prepared with Tilemap.copy.
  external void paste(num x, num y, List<Tile> tileblock, [dynamic layer]);

  /// Puts a tile of the given index value at the coordinate specified.
  /// If you pass `null` as the tile it will pass your call over to Tilemap.removeTile instead.
  external Tile putTile(dynamic tile, num x, num y, [dynamic layer]);

  /// Puts a tile into the Tilemap layer. The coordinates are given in pixel values.
  external void putTileWorldXY(
      dynamic tile, num x, num y, num tileWidth, num tileHeight,
      [dynamic layer]);

  /// Randomises a set of tiles in a given area.
  external void random(num x, num y, num width, num height, [dynamic layer]);

  /// Removes all layers from this tile map.
  external void removeAllLayers();

  /// Removes the tile located at the given coordinates and updates the collision data.
  external Tile removeTile(num x, num y, [dynamic layer]);

  /// Removes the tile located at the given coordinates and updates the collision data. The coordinates are given in pixel values.
  external Tile removeTileWorldXY(num x, num y, num tileWidth, num tileHeight,
      [dynamic layer]);

  /// Scans the given area for tiles with an index matching `source` and updates their index to match `dest`.
  external void replace(
      num source, num dest, num x, num y, num width, num height,
      [dynamic layer]);

  /// Searches the entire map layer for the first tile matching the given index, then returns that Phaser.Tile object.
  /// If no match is found it returns null.
  /// The search starts from the top-left tile and continues horizontally until it hits the end of the row, then it drops down to the next column.
  /// If the reverse boolean is true, it scans starting from the bottom-right corner traveling up to the top-left.
  external Tile searchTileIndex(num index,
      [num skip, bool reverse, dynamic layer]);

  /// Sets collision on the given tile or tiles. You can pass in either a single numeric index or an array of indexes: [2, 3, 15, 20].
  /// The `collides` parameter controls if collision will be enabled (true) or disabled (false).
  /// Collision-enabled tiles can be collided against Sprites using [Phaser.Physics.Arcade#collide].
  /// You can verify the collision faces by enabling [Phaser.TilemapLayer#debug].
  external void setCollision(dynamic indexes,
      [bool collides, dynamic layer, bool recalculate]);

  /// Sets collision on a range of tiles where the tile IDs increment sequentially.
  /// Calling this with a start value of 10 and a stop value of 14 would set collision for tiles 10, 11, 12, 13 and 14.
  /// The `collides` parameter controls if collision will be enabled (true) or disabled (false).
  external void setCollisionBetween(num start, num stop,
      [bool collides, dynamic layer, bool recalculate]);

  /// Sets collision on all tiles in the given layer, except for the IDs of those in the given array.
  /// The `collides` parameter controls if collision will be enabled (true) or disabled (false).
  external void setCollisionByExclusion(List<dynamic> indexes,
      [bool collides, dynamic layer, bool recalculate]);

  /// Sets collision values on a tile in the set.
  /// You shouldn't usually call this method directly, instead use setCollision, setCollisionBetween or setCollisionByExclusion.
  external void setCollisionByIndex(num index,
      [bool collides, num layer, bool recalculate]);

  /// Sets the current layer to the given index.
  external void setLayer(dynamic layer);

  /// Turn off/on the recalculation of faces for tile or collision updates.
  /// `setPreventRecalculate(true)` puts recalculation on hold while `setPreventRecalculate(false)` recalculates all the changed layers.
  external void setPreventRecalculate(bool value);

  /// Sets a global collision callback for the given tile index within the layer. This will affect all tiles on this layer that have the same index.
  /// If a callback is already set for the tile index it will be replaced. Set the callback to null to remove it.
  /// If you want to set a callback for a tile at a specific location on the map then see setTileLocationCallback.
  /// Return `true` from the callback to continue separating the tile and colliding object, or `false` to cancel the collision for the current tile (see [Phaser.Physics.Arcade#separateTile]).
  external void setTileIndexCallback(
      dynamic indexes, Function callback, dynamic callbackContext,
      [dynamic layer]);

  /// Sets a global collision callback for the given map location within the layer. This will affect all tiles on this layer found in the given area.
  /// If a callback is already set for the tile index it will be replaced. Set the callback to null to remove it.
  /// If you want to set a callback for a tile at a specific location on the map then see setTileLocationCallback.
  /// Return `true` from the callback to continue separating the tile and colliding object, or `false` to cancel the collision for the current tile (see [Phaser.Physics.Arcade#separateTile]).
  external void setTileLocationCallback(num x, num y, num width, num height,
      Function callback, dynamic callbackContext,
      [dynamic layer]);

  /// Sets the base tile size for the map.
  external void setTileSize(num tileWidth, num tileHeight);

  /// Shuffles a set of tiles in a given area. It will only randomise the tiles in that area, so if they're all the same nothing will appear to have changed!
  external void shuffle(num x, num y, num width, num height, dynamic layer);

  /// Scans the given area for tiles with an index matching tileA and swaps them with tileB.
  external void swap(num tileA, num tileB, num x, num y, num width, num height,
      [dynamic layer]);
}

/// A TilemapLayer is a Phaser.Image/Sprite that renders a specific TileLayer of a Tilemap.
/// Since a TilemapLayer is a Sprite it can be moved around the display, added to other groups or display objects, etc.
/// By default TilemapLayers have fixedToCamera set to `true`. Changing this will break Camera follow and scrolling behavior.
@JS("Phaser.TilemapLayer")
class TilemapLayer extends Sprite {
  // @Ignore
  TilemapLayer.fakeConstructor$() : super.fakeConstructor$();

  /// A TilemapLayer is a Phaser.Image/Sprite that renders a specific TileLayer of a Tilemap.
  /// Since a TilemapLayer is a Sprite it can be moved around the display, added to other groups or display objects, etc.
  /// By default TilemapLayers have fixedToCamera set to `true`. Changing this will break Camera follow and scrolling behavior.
  external factory TilemapLayer(Game game, Tilemap tilemap, num index,
      [num width, num height]);

  /// The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.
  /// The values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.
  external PhaserPoint get cameraOffset;
  external set cameraOffset(Point v);

  /// The canvas to which this TilemapLayer draws.
  external CanvasElement get canvas;
  external set canvas(CanvasElement v);
  external num get collisionHeight;
  external set collisionHeight(num v);
  external num get collisionWidth;
  external set collisionWidth(num v);

  /// The 2d context of the canvas.
  external CanvasRenderingContext2D get context;
  external set context(CanvasRenderingContext2D v);

  /// An empty Object that belongs to this Game Object.
  /// This value isn't ever used internally by Phaser, but may be used by your own code, or
  /// by Phaser Plugins, to store data that needs to be associated with the Game Object,
  /// without polluting the Game Object directly.
  /// Default: {}
  external dynamic get data;
  external set data(dynamic v);

  /// Enable an additional "debug rendering" pass to display collision information.
  external bool get debug;
  external set debug(bool v);
  external num get debugAlpha;
  external set debugAlpha(num v);
  external String get debugCallbackColor;
  external set debugCallbackColor(String v);
  external String get debugColor;
  external set debugColor(String v);

  /// Settings used for debugging and diagnostics.
  external dynamic /*{ missingImageFill: string; debuggedTileOverfill: string; forceFullRedraw: boolean; debugAlpha: number; facingEdgeStroke: string; collidingTileOverfill: string; }*/ get debugSettings;
  external set debugSettings(
      dynamic /*{ missingImageFill: string; debuggedTileOverfill: string; forceFullRedraw: boolean; debugAlpha: number; facingEdgeStroke: string; collidingTileOverfill: string; }*/ v);

  /// If true tiles will be force rendered, even if such is not believed to be required.
  external bool get dirty;
  external set dirty(bool v);

  /// Controls if the core game loop and physics update this game object or not.
  external bool get exists;
  external set exists(bool v);

  /// A Game Object that is "fixed" to the camera is rendered at a given x/y offsets from the top left of the camera. The offsets
  /// are stored in the `cameraOffset` property, which is initialized with the current object coordinates.
  /// The values are adjusted at the rendering stage, overriding the Game Objects actual world position.
  /// The end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world
  /// the camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times
  /// regardless where in the world the camera is.
  /// Note that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.
  /// Be careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.
  external bool get fixedToCamera;
  external set fixedToCamera(bool v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// The index of this layer within the Tilemap.
  external num get index;
  external set index(num v);

  /// The layer object within the Tilemap that this layer represents.
  external TilemapLayer get layer;
  external set layer(TilemapLayer v);

  /// The Tilemap to which this layer is bound.
  external Tilemap get map;
  external set map(Tilemap v);

  /// A user defined name given to this Game Object.
  /// This value isn't ever used internally by Phaser, it is meant as a game level property.
  external String get name;
  external set name(String v);

  /// The const physics body type of this object.
  external num get physicsType;
  external set physicsType(num v);

  /// Settings that control standard (non-diagnostic) rendering.
  /// Default: {"enableScrollDelta":true,"overdrawRatio":0.2,"copyCanvas":null}
  external dynamic /*{ enableScrollDelta: boolean; overdrawRatio: number; copyCanvas: any; }*/ get renderSettings;
  external set renderSettings(
      dynamic /*{ enableScrollDelta: boolean; overdrawRatio: number; copyCanvas: any; }*/ v);

  /// Speed at which this layer scrolls horizontally, relative to the camera (e.g. scrollFactorX of 0.5 scrolls half as quickly as the 'normal' camera-locked layers do).
  /// Default: 1
  external num get scrollFactorX;
  external set scrollFactorX(num v);

  /// Speed at which this layer scrolls vertically, relative to the camera (e.g. scrollFactorY of 0.5 scrolls half as quickly as the 'normal' camera-locked layers do)
  /// Default: 1
  external num get scrollFactorY;
  external set scrollFactorY(num v);
  external num get scrollX;
  external set scrollX(num v);
  external num get scrollY;
  external set scrollY(num v);

  /// The const type of this object.
  /// Default: Phaser.TILEMAPLAYER
  external num get type;
  external set type(num v);
  external bool get wrap;
  external set wrap(bool v);

  /// Destroys this TilemapLayer.
  external void destroy();

  /// Gets all tiles that intersect with the given line.
  external List<Tile> getRayCastTiles(Line line,
      [num stepRate, bool collides, bool interestingFace]);

  /// Get all tiles that exist within the given area, defined by the top-left corner, width and height. Values given are in pixels, not tiles.
  external List<Tile> getTiles(num x, num y, num width, num height,
      [bool collides, bool interestingFace]);

  /// Convert a pixel value to a tile coordinate.
  external num getTileX(num x);

  /// Convert a pixel coordinate to a tile coordinate.
  external PhaserPoint getTileXY(num x, num y, Point point);

  /// Convert a pixel value to a tile coordinate.
  external num getTileY(num y);

  /// Automatically called by World.postUpdate. Handles cache updates.
  external void postUpdate();

  /// Renders the tiles to the layer canvas and pushes to the display.
  external void render();

  /// Resizes the internal canvas and texture frame used by this TilemapLayer.
  /// This is an expensive call, so don't bind it to a window resize event! But instead call it at carefully
  /// selected times.
  /// Be aware that no validation of the new sizes takes place and the current map scroll coordinates are not
  /// modified either. You will have to handle both of these things from your game code if required.
  external void resize(num width, num height);

  /// Sets the world size to match the size of this layer.
  external void resizeWorld();

  /// The TilemapLayer caches tileset look-ups.
  /// Call this method of clear the cache if tilesets have been added or updated after the layer has been rendered.
  external void resetTilesetCache();

  /// This method will set the scale of the tilemap as well as update the underlying block data of this layer.
  external void setScale([num xScale, num yScale]);
  external void updateMax();
  external num getTileOffsetX();

  /// Get the Y axis position offset of this layer's tiles.
  external num getTileOffsetY();
}

@JS("Phaser.TilemapLayerGL")
class TilemapLayerGL {
  // @Ignore
  TilemapLayerGL.fakeConstructor$();
  external factory TilemapLayerGL(Game game, Tilemap tilemap, num index,
      [num width, num height, Tileset tileset]);
  external num get collisionHeight;
  external set collisionHeight(num v);
  external num get collisionWidth;
  external set collisionWidth(num v);
  external dynamic get data;
  external set data(dynamic v);
  external bool get dirty;
  external set dirty(bool v);
  external bool get exists;
  external set exists(bool v);
  external bool get fixedToCamera;
  external set fixedToCamera(bool v);
  external Game get game;
  external set game(Game v);
  external num get index;
  external set index(num v);
  external TilemapLayer get layer;
  external set layer(TilemapLayer v);
  external Tilemap get map;
  external set map(Tilemap v);
  external String get name;
  external set name(String v);
  external num get physicsType;
  external set physicsType(num v);
  external num get scrollFactorX;
  external set scrollFactorX(num v);
  external num get scrollFactorY;
  external set scrollFactorY(num v);
  external num get scrollX;
  external set scrollX(num v);
  external num get scrollY;
  external set scrollY(num v);
  external num get type;
  external set type(num v);
  external bool get wrap;
  external set wrap(bool v);
  external num get x;
  external set x(num v);
  external num get y;
  external set y(num v);
  external num get width;
  external set width(num v);
  external num get height;
  external set height(num v);
  external void destroy();
  external void postUpdate();
  external void render();
  external void resize(num width, num height);
  external void resizeWorld();
  external void resetTilesetCache();
  external void setScale([num xScale, num yScale]);
  external void updateMax();
}

/// Phaser.TilemapParser parses data objects from Phaser.Loader that need more preparation before they can be inserted into a Tilemap.
@JS("Phaser.TilemapParser")
class TilemapParser {
  // @Ignore
  TilemapParser.fakeConstructor$();

  /// When scanning the Tiled map data the TilemapParser can either insert a null value (true) or
  /// a Phaser.Tile instance with an index of -1 (false, the default). Depending on your game type
  /// depends how this should be configured. If you've a large sparsely populated map and the tile
  /// data doesn't need to change then setting this value to `true` will help with memory consumption.
  /// However if your map is small, or you need to update the tiles (perhaps the map dynamically changes
  /// during the game) then leave the default value set.
  external static bool get INSERT_NULL;
  external static set INSERT_NULL(bool v);

  /// Returns an empty map data object.
  external static dynamic getEmptyData(
      [num tileWidth, num tileHeight, num width, num height]);

  /// Parse tilemap data from the cache and creates data for a Tilemap object.
  external static dynamic parse(Game game, String key,
      [num tileWidth, num tileHeight, num width, num height]);

  /// Parses a CSV file into valid map data.
  external static dynamic parseCSV(String key, String data,
      [num tileWidth, num tileHeight]);
  external static dynamic parseJSON(dynamic json);
}

/// A Tile set is a combination of an image containing the tiles and collision data per tile.
/// Tilesets are normally created automatically when Tiled data is loaded.
@JS("Phaser.Tileset")
class Tileset {
  // @Ignore
  Tileset.fakeConstructor$();

  /// A Tile set is a combination of an image containing the tiles and collision data per tile.
  /// Tilesets are normally created automatically when Tiled data is loaded.
  external factory Tileset(String name, num firstgid,
      [num width, num height, num margin, num spacing, dynamic properties]);

  /// The number of tile columns in the tileset.
  external num get columns;
  external set columns(num v);

  /// The Tiled firstgid value.
  /// This is the starting index of the first tile index this Tileset contains.
  external num get firstgid;
  external set firstgid(num v);

  /// The cached image that contains the individual tiles. Use [Phaser.Tileset.setImage setImage] to set.
  external dynamic get image;
  external set image(dynamic v);
  external num get lastgid;
  external set lastgid(num v);

  /// The name of the Tileset.
  external String get name;
  external set name(String v);

  /// Tileset-specific properties that are typically defined in the Tiled editor.
  external dynamic get properties;
  external set properties(dynamic v);

  /// The number of tile rows in the the tileset.
  external num get rows;
  external set rows(num v);

  /// The height of each tile (in pixels).
  external num get tileHeight;
  external set tileHeight(num v);

  /// The margin around the tiles in the sheet (in pixels).
  /// Use `setSpacing` to change.
  external num get tileMargin;
  external set tileMargin(num v);

  /// The spacing between each tile in the sheet (in pixels).
  /// Use `setSpacing` to change.
  external num get tileSpacing;
  external set tileSpacing(num v);

  /// The width of each tile (in pixels).
  external num get tileWidth;
  external set tileWidth(num v);

  /// The total number of tiles in the tileset.
  external num get total;
  external set total(num v);

  /// Returns true if and only if this tileset contains the given tile index.
  external bool containsTileIndex(num tileIndex);

  /// Draws a tile from this Tileset at the given coordinates on the context.
  external void draw(CanvasRenderingContext2D context, num x, num y, num index);
  external void drawGl(List<dynamic> glBatch, num x, num y, num index,
      num alpha, num flippedVal);

  /// Set the image associated with this Tileset and update the tile data.
  external void setImage(dynamic image);

  /// Sets tile spacing and margins.
  external void setSpacing([num margin, num spacing]);
}

/// A TileSprite is a Sprite that has a repeating texture. The texture can be scrolled and scaled independently of the TileSprite itself.
/// Textures will automatically wrap and are designed so that you can create game backdrops using seamless textures as a source.
/// TileSprites have no input handler or physics bodies by default, both need enabling in the same way as for normal Sprites.
/// You shouldn't ever create a TileSprite any larger than your actual screen size. If you want to create a large repeating background
/// that scrolls across the whole map of your game, then you create a TileSprite that fits the screen size and then use the `tilePosition`
/// property to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will
/// consume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to
/// adjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.
/// An important note about texture dimensions:
/// When running under Canvas a TileSprite can use any texture size without issue. When running under WebGL the texture should ideally be
/// a power of two in size (i.e. 4, 8, 16, 32, 64, 128, 256, 512, etc pixels width by height). If the texture isn't a power of two
/// it will be rendered to a blank canvas that is the correct size, which means you may have 'blank' areas appearing to the right and
/// bottom of your frame. To avoid this ensure your textures are perfect powers of two.
/// TileSprites support animations in the same way that Sprites do. You add and play animations using the AnimationManager. However
/// if your game is running under WebGL please note that each frame of the animation must be a power of two in size, or it will receive
/// additional padding to enforce it to be so.
@JS("Phaser.TileSprite")
class TileSprite extends TilingSprite {
  // @Ignore
  TileSprite.fakeConstructor$() : super.fakeConstructor$();

  /// A TileSprite is a Sprite that has a repeating texture. The texture can be scrolled and scaled independently of the TileSprite itself.
  /// Textures will automatically wrap and are designed so that you can create game backdrops using seamless textures as a source.
  /// TileSprites have no input handler or physics bodies by default, both need enabling in the same way as for normal Sprites.
  /// You shouldn't ever create a TileSprite any larger than your actual screen size. If you want to create a large repeating background
  /// that scrolls across the whole map of your game, then you create a TileSprite that fits the screen size and then use the `tilePosition`
  /// property to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will
  /// consume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to
  /// adjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.
  /// An important note about texture dimensions:
  /// When running under Canvas a TileSprite can use any texture size without issue. When running under WebGL the texture should ideally be
  /// a power of two in size (i.e. 4, 8, 16, 32, 64, 128, 256, 512, etc pixels width by height). If the texture isn't a power of two
  /// it will be rendered to a blank canvas that is the correct size, which means you may have 'blank' areas appearing to the right and
  /// bottom of your frame. To avoid this ensure your textures are perfect powers of two.
  /// TileSprites support animations in the same way that Sprites do. You add and play animations using the AnimationManager. However
  /// if your game is running under WebGL please note that each frame of the animation must be a power of two in size, or it will receive
  /// additional padding to enforce it to be so.
  external factory TileSprite(Game game, num x, num y, num width, num height,
      [dynamic /*String|RenderTexture|BitmapData|Texture*/ key,
      dynamic /*String|num*/ frame]);

  /// A useful flag to control if the Game Object is alive or dead.
  /// This is set automatically by the Health components `damage` method should the object run out of health.
  /// Or you can toggle it via your game code.
  /// This property is mostly just provided to be used by your game - it doesn't effect rendering or logic updates.
  /// However you can use `Group.getFirstAlive` in conjunction with this property for fast object pooling and recycling.
  /// Default: true
  external bool get alive;
  external set alive(bool v);

  /// The angle property is the rotation of the Game Object in *degrees* from its original orientation.
  /// Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.
  /// Values outside this range are added to or subtracted from 360 to obtain a value within the range.
  /// For example, the statement player.angle = 450 is the same as player.angle = 90.
  /// If you wish to work in radians instead of degrees you can use the property `rotation` instead.
  /// Working in radians is slightly faster as it doesn't have to perform any calculations.
  external num get angle;
  external set angle(num v);

  /// If the Game Object is enabled for animation (such as a Phaser.Sprite) this is a reference to its AnimationManager instance.
  /// Through it you can create, play, pause and stop animations.
  external AnimationManager get animations;
  external set animations(AnimationManager v);

  /// A Game Object with `autoCull` set to true will check its bounds against the World Camera every frame.
  /// If it is not intersecting the Camera bounds at any point then it has its `renderable` property set to `false`.
  /// This keeps the Game Object alive and still processing updates, but forces it to skip the render step entirely.
  /// This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,
  /// or you have tested performance and find it acceptable.
  external bool get autoCull;
  external set autoCull(bool v);

  /// `body` is the Game Objects physics body. Once a Game Object is enabled for physics you access all associated
  /// properties and methods via it.
  /// By default Game Objects won't add themselves to any physics system and their `body` property will be `null`.
  /// To enable this Game Object for physics you need to call `game.physics.enable(object, system)` where `object` is this object
  /// and `system` is the Physics system you are using. If none is given it defaults to `Phaser.Physics.Arcade`.
  /// You can alternatively call `game.physics.arcade.enable(object)`, or add this Game Object to a physics enabled Group.
  /// Important: Enabling a Game Object for P2 or Ninja physics will automatically set its `anchor` property to 0.5,
  /// so the physics body is centered on the Game Object.
  /// If you need a different result then adjust or re-create the Body shape offsets manually or reset the anchor after enabling physics.
  external dynamic /*Body|P2_Body|Ninja_Body|dynamic*/ get body;
  external set body(dynamic /*Body|P2_Body|Ninja_Body|dynamic*/ v);

  /// The sum of the y and height properties.
  /// This is the same as `y + height - offsetY`.
  external num get bottom;
  external set bottom(num v);

  /// The x/y coordinate offset applied to the top-left of the camera that this Game Object will be drawn at if `fixedToCamera` is true.
  /// The values are relative to the top-left of the camera view and in addition to any parent of the Game Object on the display list.
  external PhaserPoint get cameraOffset;
  external set cameraOffset(Point v);

  /// If this is set to `true` the Game Object checks if it is within the World bounds each frame.
  /// When it is no longer intersecting the world bounds it dispatches the `onOutOfBounds` event.
  /// If it was *previously* out of bounds but is now intersecting the world bounds again it dispatches the `onEnterBounds` event.
  /// It also optionally kills the Game Object if `outOfBoundsKill` is `true`.
  /// When `checkWorldBounds` is enabled it forces the Game Object to calculate its full bounds every frame.
  /// This is a relatively expensive operation, especially if enabled on hundreds of Game Objects. So enable it only if you know it's required,
  /// or you have tested performance and find it acceptable.
  external bool get checkWorldBounds;
  external set checkWorldBounds(bool v);

  /// The components this Game Object has installed.
  external dynamic get components;
  external set components(dynamic v);

  /// Does this texture require a custom render call? (as set by BitmapData, Video, etc)
  external bool get customRender;
  external set customRender(bool v);

  /// An empty Object that belongs to this Game Object.
  /// This value isn't ever used internally by Phaser, but may be used by your own code, or
  /// by Phaser Plugins, to store data that needs to be associated with the Game Object,
  /// without polluting the Game Object directly.
  /// Default: {}
  external dynamic get data;
  external set data(dynamic v);

  /// A debug flag designed for use with `Game.enableStep`.
  external bool get debug;
  external set debug(bool v);

  /// As a Game Object runs through its destroy method this flag is set to true,
  /// and can be checked in any sub-systems or plugins it is being destroyed from.
  external bool get destroyPhase;
  external set destroyPhase(bool v);

  /// All Phaser Game Objects have an Events class which contains all of the events that are dispatched when certain things happen to this
  /// Game Object, or any of its components.
  external Events get events;
  external set events(Events v);

  /// Controls if this Sprite is processed by the core Phaser game loops and Group loops (except [Phaser.Group#update]).
  /// Default: true
  external bool get exists;
  external set exists(bool v);

  /// A Game Object that is "fixed" to the camera is rendered at a given x/y offsets from the top left of the camera. The offsets
  /// are stored in the `cameraOffset` property, which is initialized with the current object coordinates.
  /// The values are adjusted at the rendering stage, overriding the Game Objects actual world position.
  /// The end result is that the Game Object will appear to be 'fixed' to the camera, regardless of where in the game world
  /// the camera is viewing. This is useful if for example this Game Object is a UI item that you wish to be visible at all times
  /// regardless where in the world the camera is.
  /// Note that the `cameraOffset` values are in addition to any parent of this Game Object on the display list.
  /// Be careful not to set `fixedToCamera` on Game Objects which are in Groups that already have `fixedToCamera` enabled on them.
  external bool get fixedToCamera;
  external set fixedToCamera(bool v);

  /// Gets or sets the current frame index of the texture being used to render this Game Object.
  /// To change the frame set `frame` to the index of the new frame in the sprite sheet you wish this Game Object to use,
  /// for example: `player.frame = 4`.
  /// If the frame index given doesn't exist it will revert to the first frame found in the texture.
  /// If you are using a texture atlas then you should use the `frameName` property instead.
  /// If you wish to fully replace the texture being used see `loadTexture`.
  external dynamic /*String|num*/ get frame;
  external set frame(dynamic /*String|num*/ v);

  /// Gets or sets the current frame name of the texture being used to render this Game Object.
  /// To change the frame set `frameName` to the name of the new frame in the texture atlas you wish this Game Object to use,
  /// for example: `player.frameName = "idle"`.
  /// If the frame name given doesn't exist it will revert to the first frame found in the texture and throw a console warning.
  /// If you are using a sprite sheet then you should use the `frame` property instead.
  /// If you wish to fully replace the texture being used see `loadTexture`.
  external String get frameName;
  external set frameName(String v);

  /// A Game Object is considered `fresh` if it has just been created or reset and is yet to receive a renderer transform update.
  /// This property is mostly used internally by the physics systems, but is exposed for the use of plugins.
  external bool get fresh;
  external set fresh(bool v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// Checks if the Game Objects bounds intersect with the Game Camera bounds.
  /// Returns `true` if they do, otherwise `false` if fully outside of the Cameras bounds.
  external bool get inCamera;
  external set inCamera(bool v);

  /// The Input Handler for this Game Object.
  /// By default it is disabled. If you wish this Game Object to process input events you should enable it with: `inputEnabled = true`.
  /// After you have done this, this property will be a reference to the Phaser InputHandler.
  external InputHandler get input;
  external set input(InputHandler v);

  /// By default a Game Object won't process any input events. By setting `inputEnabled` to true a Phaser.InputHandler is created
  /// for this Game Object and it will then start to process click / touch events and more.
  /// You can then access the Input Handler via `this.input`.
  /// Note that Input related events are dispatched from `this.events`, i.e.: `events.onInputDown`.
  /// If you set this property to false it will stop the Input Handler from processing any more input events.
  /// If you want to _temporarily_ disable input for a Game Object, then it's better to set
  /// `input.enabled = false`, as it won't reset any of the Input Handlers internal properties.
  /// You can then toggle this back on as needed.
  external bool get inputEnabled;
  external set inputEnabled(bool v);

  /// Checks if the Game Objects bounds are within, or intersect at any point with the Game World bounds.
  external bool get inWorld;
  external set inWorld(bool v);

  /// The key of the image or texture used by this Game Object during rendering.
  /// If it is a string it's the string used to retrieve the texture from the Phaser Image Cache.
  /// It can also be an instance of a RenderTexture, BitmapData, Video or PIXI.Texture.
  /// If a Game Object is created without a key it is automatically assigned the key `__default` which is a 32x32 transparent PNG stored within the Cache.
  /// If a Game Object is given a key which doesn't exist in the Image Cache it is re-assigned the key `__missing` which is a 32x32 PNG of a green box with a line through it.
  external dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ get key;
  external set key(dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ v);

  /// The left coordinate of the Game Object.
  /// This is the same as `x - offsetX`.
  external num get left;
  external set left(num v);

  /// A user defined name given to this Game Object.
  /// This value isn't ever used internally by Phaser, it is meant as a game level property.
  external String get name;
  external set name(String v);

  /// The amount the Game Object is visually offset from its x coordinate.
  /// This is the same as `width * anchor.x`.
  /// It will only be > 0 if anchor.x is not equal to zero.
  external num get offsetX;
  external set offsetX(num v);

  /// The amount the Game Object is visually offset from its y coordinate.
  /// This is the same as `height * anchor.y`.
  /// It will only be > 0 if anchor.y is not equal to zero.
  external num get offsetY;
  external set offsetY(num v);

  /// If this and the `checkWorldBounds` property are both set to `true` then the `kill` method is called as soon as `inWorld` returns false.
  external bool get outOfBoundsKill;
  external set outOfBoundsKill(bool v);

  /// A Game Object is that is pendingDestroy is flagged to have its destroy method called on the next logic update.
  /// You can set it directly to allow you to flag an object to be destroyed on its next update.
  /// This is extremely useful if you wish to destroy an object from within one of its own callbacks
  /// such as with Buttons or other Input events.
  external bool get pendingDestroy;
  external set pendingDestroy(bool v);

  /// The const physics body type of this object.
  external num get physicsType;
  external set physicsType(num v);

  /// The coordinates, in pixels, of this DisplayObject, relative to its parent container.
  /// The value of this property does not reflect any positioning happening further up the display list.
  /// To obtain that value please see the `worldPosition` property.
  external PhaserPoint get position;
  external set position(Point v);

  /// Enable or disable texture smoothing for this Game Object.
  /// It only takes effect if the Game Object is using an image based texture.
  /// Smoothing is enabled by default.
  external bool get smoothed;
  external set smoothed(bool v);

  /// The position the Game Object was located in the previous frame.
  external PhaserPoint get previousPosition;
  external set previousPosition(Point v);
  external num get previousRoation;
  external set previousRoation(num v);

  /// The right coordinate of the Game Object.
  /// This is the same as `x + width - offsetX`.
  external num get right;
  external set right(num v);

  /// The y coordinate of the Game Object.
  /// This is the same as `y - offsetY`.
  external num get top;
  external set top(num v);

  /// The render order ID is used internally by the renderer and Input Manager and should not be modified.
  /// This property is mostly used internally by the renderers, but is exposed for the use of plugins.
  external num get renderOrderID;
  external set renderOrderID(num v);

  /// The const type of this object.
  external num get type;
  external set type(num v);

  /// The world coordinates of this Game Object in pixels.
  /// Depending on where in the display list this Game Object is placed this value can differ from `position`,
  /// which contains the x/y coordinates relative to the Game Objects parent.
  external PhaserPoint get world;
  external set world(Point v);

  /// The z depth of this Game Object within its parent Group.
  /// No two objects in a Group can have the same z value.
  /// This value is adjusted automatically whenever the Group hierarchy changes.
  /// If you wish to re-order the layering of a Game Object then see methods like Group.moveUp or Group.bringToTop.
  external num get z;
  external set z(num v);

  /// Aligns this Game Object within another Game Object, or Rectangle, known as the
  /// 'container', to one of 9 possible positions.
  /// The container must be a Game Object, or Phaser.Rectangle object. This can include properties
  /// such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world
  /// and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,
  /// TileSprites or Buttons.
  /// Please note that aligning a Sprite to another Game Object does **not** make it a child of
  /// the container. It simply modifies its position coordinates so it aligns with it.
  /// The position constants you can use are:
  /// `Phaser.TOP_LEFT`, `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_CENTER`,
  /// `Phaser.CENTER`, `Phaser.RIGHT_CENTER`, `Phaser.BOTTOM_LEFT`,
  /// `Phaser.BOTTOM_CENTER` and `Phaser.BOTTOM_RIGHT`.
  /// The Game Objects are placed in such a way that their _bounds_ align with the
  /// container, taking into consideration rotation, scale and the anchor property.
  /// This allows you to neatly align Game Objects, irrespective of their position value.
  /// The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final
  /// aligned position of the Game Object. For example:
  /// `sprite.alignIn(background, Phaser.BOTTOM_RIGHT, -20, -20)`
  /// Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.
  /// Think of the offsets as applying an adjustment to the containers bounds before the alignment takes place.
  /// So providing a negative offset will 'shrink' the container bounds by that amount, and providing a positive
  /// one expands it.
  external dynamic alignIn(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// Aligns this Game Object to the side of another Game Object, or Rectangle, known as the
  /// 'parent', in one of 11 possible positions.
  /// The parent must be a Game Object, or Phaser.Rectangle object. This can include properties
  /// such as `World.bounds` or `Camera.view`, for aligning Game Objects within the world
  /// and camera bounds. Or it can include other Sprites, Images, Text objects, BitmapText,
  /// TileSprites or Buttons.
  /// Please note that aligning a Sprite to another Game Object does **not** make it a child of
  /// the parent. It simply modifies its position coordinates so it aligns with it.
  /// The position constants you can use are:
  /// `Phaser.TOP_LEFT` (default), `Phaser.TOP_CENTER`, `Phaser.TOP_RIGHT`, `Phaser.LEFT_TOP`,
  /// `Phaser.LEFT_CENTER`, `Phaser.LEFT_BOTTOM`, `Phaser.RIGHT_TOP`, `Phaser.RIGHT_CENTER`,
  /// `Phaser.RIGHT_BOTTOM`, `Phaser.BOTTOM_LEFT`, `Phaser.BOTTOM_CENTER`
  /// and `Phaser.BOTTOM_RIGHT`.
  /// The Game Objects are placed in such a way that their _bounds_ align with the
  /// parent, taking into consideration rotation, scale and the anchor property.
  /// This allows you to neatly align Game Objects, irrespective of their position value.
  /// The optional `offsetX` and `offsetY` arguments allow you to apply extra spacing to the final
  /// aligned position of the Game Object. For example:
  /// `sprite.alignTo(background, Phaser.BOTTOM_RIGHT, -20, -20)`
  /// Would align the `sprite` to the bottom-right, but moved 20 pixels in from the corner.
  /// Think of the offsets as applying an adjustment to the parents bounds before the alignment takes place.
  /// So providing a negative offset will 'shrink' the parent bounds by that amount, and providing a positive
  /// one expands it.
  external dynamic alignTo(
      dynamic /*Rectangle|Sprite|Image|Text|BitmapText|Button|Graphics|TileSprite*/ container,
      [num position,
      num offsetX,
      num offsetY]);

  /// Sets this TileSprite to automatically scroll in the given direction until stopped via TileSprite.stopScroll().
  /// The scroll speed is specified in pixels per second.
  /// A negative x value will scroll to the left. A positive x value will scroll to the right.
  /// A negative y value will scroll up. A positive y value will scroll down.
  external void autoScroll(num x, num y);

  /// Destroys the TileSprite. This removes it from its parent group, destroys the event and animation handlers if present
  /// and nulls its reference to game, freeing it up for garbage collection.
  external void destroy([bool destroyChildren]);

  /// Changes the base texture the Game Object is using. The old texture is removed and the new one is referenced or fetched from the Cache.
  /// If your Game Object is using a frame from a texture atlas and you just wish to change to another frame, then see the `frame` or `frameName` properties instead.
  /// You should only use `loadTexture` if you want to replace the base texture entirely.
  /// Calling this method causes a WebGL texture update, so use sparingly or in low-intensity portions of your game, or if you know the new texture is already on the GPU.
  /// You can use the new const `Phaser.PENDING_ATLAS` as the texture key for any sprite.
  /// Doing this then sets the key to be the `frame` argument (the frame is set to zero).
  /// This allows you to create sprites using `load.image` during development, and then change them
  /// to use a Texture Atlas later in development by simply searching your code for 'PENDING_ATLAS'
  /// and swapping it to be the key of the atlas data.
  /// Note: You cannot use a RenderTexture as a texture for a TileSprite.
  external void loadTexture(
      dynamic /*String|RenderTexture|BitmapData|Video|Texture*/ key,
      [dynamic /*String|num*/ frame,
      bool stopAnimation]);

  /// Plays an Animation.
  /// The animation should have previously been created via `animations.add`.
  /// If the animation is already playing calling this again won't do anything.
  /// If you need to reset an already running animation do so directly on the Animation object itself or via `AnimationManager.stop`.
  external Animation play(String name,
      [num frameRate, bool loop, bool killOnComplete]);

  /// Internal method called by the World postUpdate cycle.
  external void postUpdate();

  /// Automatically called by World.preUpdate.
  external void preUpdate();

  /// Checks to see if the bounds of this Game Object overlaps with the bounds of the given Display Object,
  /// which can be a Sprite, Image, TileSprite or anything that extends those such as Button or provides a `getBounds` method and result.
  /// This check ignores the `hitArea` property if set and runs a `getBounds` comparison on both objects to determine the result.
  /// Therefore it's relatively expensive to use in large quantities, i.e. with lots of Sprites at a high frequency.
  /// It should be fine for low-volume testing where physics isn't required.
  external bool overlap(
      dynamic /*Sprite|Image|TileSprite|Button|DisplayObject*/ displayObject);

  /// Resets the TileSprite. This places the TileSprite at the given x/y world coordinates, resets the tilePosition and then
  /// sets alive, exists, visible and renderable all to true. Also resets the outOfBounds state.
  /// If the TileSprite has a physics body that too is reset.
  external TileSprite reset(num x, num y, [num health]);

  /// Resizes the Frame dimensions that the Game Object uses for rendering.
  /// You shouldn't normally need to ever call this, but in the case of special texture types such as Video or BitmapData
  /// it can be useful to adjust the dimensions directly in this way.
  external void resizeFrame(dynamic parent, num width, num height);

  /// Resets the texture frame dimensions that the Game Object uses for rendering.
  external void resetFrame();

  /// Sets the texture frame the Game Object uses for rendering.
  /// This is primarily an internal method used by `loadTexture`, but is exposed for the use of plugins and custom classes.
  external void setFrame(Frame frame);

  /// Stops an automatically scrolling TileSprite.
  external void stopScroll();

  /// Override this method in your own custom objects to handle any update requirements.
  /// It is called immediately after `preUpdate` and before `postUpdate`.
  /// Remember if this Game Object has any children you should call update on those too.
  external void update();
}

/// This is the core internal game clock.
/// It manages the elapsed time and calculation of elapsed values, used for game object motion and tweens,
/// and also handles the standard Timer pool.
/// To create a general timed event, use the master [Phaser.Timer] accessible through [Phaser.Time.events events].
/// There are different *types* of time in Phaser:
/// - ***Game time*** always runs at the speed of time in real life.
/// Unlike wall-clock time, *game time stops when Phaser is paused*.
/// Game time is used for [Phaser.Timer timer events].
/// - ***Physics time*** represents the amount of time given to physics calculations.
/// *When [Phaser.Time#slowMotion slowMotion] is in effect physics time runs slower than game time.*
/// Like game time, physics time stops when Phaser is paused.
/// Physics time is used for physics calculations and [Phaser.Tween tweens].
/// - [https://en.wikipedia.org/wiki/Wall-clock_time ***Wall-clock time***] represents the duration between two events in real life time.
/// This time is independent of Phaser and always progresses, regardless of if Phaser is paused.
@JS("Phaser.Time")
class Time {
  // @Ignore
  Time.fakeConstructor$();

  /// This is the core internal game clock.
  /// It manages the elapsed time and calculation of elapsed values, used for game object motion and tweens,
  /// and also handles the standard Timer pool.
  /// To create a general timed event, use the master [Phaser.Timer] accessible through [Phaser.Time.events events].
  /// There are different *types* of time in Phaser:
  /// - ***Game time*** always runs at the speed of time in real life.
  /// Unlike wall-clock time, *game time stops when Phaser is paused*.
  /// Game time is used for [Phaser.Timer timer events].
  /// - ***Physics time*** represents the amount of time given to physics calculations.
  /// *When [Phaser.Time#slowMotion slowMotion] is in effect physics time runs slower than game time.*
  /// Like game time, physics time stops when Phaser is paused.
  /// Physics time is used for physics calculations and [Phaser.Tween tweens].
  /// - [https://en.wikipedia.org/wiki/Wall-clock_time ***Wall-clock time***] represents the duration between two events in real life time.
  /// This time is independent of Phaser and always progresses, regardless of if Phaser is paused.
  external factory Time(Game game);

  /// If true then advanced profiling, including the fps rate, fps min/max, suggestedFps and msMin/msMax are updated. This isn't expensive, but displaying it with [Phaser.Utils.Debug#text] can be, especially in WebGL mode.
  external bool get advancedTiming;
  external set advancedTiming(bool v);

  /// The desired frame rate of the game.
  /// This is used is used to calculate the physic / logic multiplier and how to apply catch-up logic updates. The desired frame rate of the game. Defaults to 60.
  external num get desiredFps;
  external set desiredFps(num v);

  /// The desiredFps multiplier as used by Game.update.
  external num get desiredFpsMult;
  external set desiredFpsMult(num v);

  /// Elapsed time since the last time update, in milliseconds, based on `now`.
  /// This value _may_ include time that the game is paused/inactive.
  /// _Note:_ This is updated only once per game loop - even if multiple logic update steps are done.
  /// Use [Phaser.Timer#physicsTime physicsTime] as a basis of game/logic calculations instead.
  external num get elapsed;
  external set elapsed(num v);

  /// A [Phaser.Timer] object bound to the master clock (this Time object) which events can be added to.
  external Timer get events;
  external set events(Timer v);

  /// The time in ms since the last time update, in milliseconds, based on `time`.
  /// This value is corrected for game pauses and will be "about zero" after a game is resumed.
  /// _Note:_ This is updated once per game loop - even if multiple logic update steps are done.
  /// Use [Phaser.Timer#physicsTime physicsTime] as a basis of game/logic calculations instead.
  external num get elapsedMS;
  external set elapsedMS(num v);

  /// Advanced timing result: Frames per second.
  /// Only calculated if [Phaser.Time#advancedTiming advancedTiming] is enabled.
  external num get fps;
  external set fps(num v);

  /// Advanced timing result: The highest rate the fps has reached (usually no higher than 60fps).
  /// Only calculated if [Phaser.Time#advancedTiming advancedTiming] is enabled.
  /// This value can be manually reset.
  external num get fpsMax;
  external set fpsMax(num v);

  /// Advanced timing result: The lowest rate the fps has dropped to.
  /// Only calculated if [Phaser.Time#advancedTiming advancedTiming] is enabled.
  /// This value can be manually reset.
  external num get fpsMin;
  external set fpsMin(num v);

  /// Advanced timing result: The number of render frames record in the last second.
  /// Only calculated if [Phaser.Time#advancedTiming advancedTiming] is enabled.
  external num get frames;
  external set frames(num v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);
  external num get lastTime;
  external set lastTime(num v);

  /// Advanced timing result: The maximum amount of time the game has taken between consecutive frames.
  /// Only calculated if [Phaser.Time#advancedTiming advancedTiming] is enabled.
  /// This value can be manually reset.
  external num get msMax;
  external set msMax(num v);

  /// Advanced timing result: The minimum amount of time the game has taken between consecutive frames.
  /// Only calculated if [Phaser.Time#advancedTiming advancedTiming] is enabled.
  /// This value can be manually reset.
  /// Default: 1000
  external num get msMin;
  external set msMin(num v);

  /// An increasing value representing cumulative milliseconds since an undisclosed epoch.
  /// While this value is in milliseconds and can be used to compute time deltas,
  /// it must must _not_ be used with `Date.now()` as it may not use the same epoch / starting reference.
  /// The source may either be from a high-res source (eg. if RAF is available) or the standard Date.now;
  /// the value can only be relied upon within a particular game instance.
  external num get now;
  external set now(num v);
  external num get pausedTime;
  external set pausedTime(num v);

  /// Records how long the game was last paused, in milliseconds.
  /// (This is not updated until the game is resumed.)
  external num get pauseDuration;
  external set pauseDuration(num v);

  /// The physics update delta, in fractional seconds.
  /// This should be used as an applicable multiplier by all logic update steps (eg. `preUpdate/postUpdate/update`)
  /// to ensure consistent game timing. Game/logic timing can drift from real-world time if the system
  /// is unable to consistently maintain the desired FPS.
  /// With fixed-step updates this is normally equivalent to `1.0 / desiredFps`.
  external num get physicsElapsed;
  external set physicsElapsed(num v);

  /// The physics update delta, in milliseconds - equivalent to `physicsElapsed * 1000`.
  external num get physicsElapsedMS;
  external set physicsElapsedMS(num v);

  /// The `now` when the previous update occurred.
  external num get prevTime;
  external set prevTime(num v);

  /// Scaling factor to make the game move smoothly in slow motion (or fast motion)
  /// - 1.0 = normal speed
  /// - 2.0 = half speed
  /// - 0.5 = double speed
  /// You likely need to adjust [Phaser.Time#desiredFps desiredFps] as well such that `desiredFps / slowMotion === 60`.
  /// Default: 1
  external num get slowMotion;
  external set slowMotion(num v);

  /// The suggested frame rate for your game, based on an averaged real frame rate.
  /// This value is only populated if `Time.advancedTiming` is enabled.
  /// _Note:_ This is not available until after a few frames have passed; until then
  /// it's set to the same value as desiredFps.
  external num get suggestedFps;
  external set suggestedFps(num v);

  /// The `Date.now()` value when the time was last updated.
  external num get time;
  external set time(num v);

  /// The time when the next call is expected when using setTimer to control the update loop
  external num get timeExpected;
  external set timeExpected(num v);

  /// The value that setTimeout needs to work out when to next update
  external num get timeToCall;
  external set timeToCall(num v);

  /// Adds an existing Phaser.Timer object to the Timer pool.
  external Timer add(Timer timer);

  /// Called automatically by Phaser.Game after boot. Should not be called directly.
  external void boot();

  /// Creates a new stand-alone Phaser.Timer object.
  external Timer create([bool autoDestroy]);

  /// How long has passed since the given time (in seconds).
  external num elapsedSecondsSince(num since);

  /// How long has passed since the given time.
  external num elapsedSince(num since);

  /// Remove all Timer objects, regardless of their state and clears all Timers from the [Phaser.Time#events events] timer.
  external void removeAll();

  /// Resets the private _started value to now and removes all currently running Timers.
  external void reset();

  /// The number of seconds that have elapsed since the game was started.
  external num totalElapsedSeconds();

  /// Updates the game clock and if enabled the advanced timing data. This is called automatically by Phaser.Game.
  external void update(num time);
}

/// A Timer is a way to create and manage [Phaser.TimerEvent timer events] that wait for a specific duration and then run a callback.
/// Many different timer events, with individual delays, can be added to the same Timer.
/// All Timer delays are in milliseconds (there are 1000 ms in 1 second); so a delay value of 250 represents a quarter of a second.
/// Timers are based on real life time, adjusted for game pause durations.
/// That is, *timer events are based on elapsed [Phaser.Time game time]* and do *not* take physics time or slow motion into account.
@JS("Phaser.Timer")
class Timer {
  // @Ignore
  Timer.fakeConstructor$();

  /// A Timer is a way to create and manage [Phaser.TimerEvent timer events] that wait for a specific duration and then run a callback.
  /// Many different timer events, with individual delays, can be added to the same Timer.
  /// All Timer delays are in milliseconds (there are 1000 ms in 1 second); so a delay value of 250 represents a quarter of a second.
  /// Timers are based on real life time, adjusted for game pause durations.
  /// That is, *timer events are based on elapsed [Phaser.Time game time]* and do *not* take physics time or slow motion into account.
  external factory Timer(Game game, [bool autoDestroy]);

  /// Number of milliseconds in half a second.
  external static num get HALF;
  external static set HALF(num v);

  /// Number of milliseconds in a minute.
  external static num get MINUTE;
  external static set MINUTE(num v);

  /// Number of milliseconds in a quarter of a second.
  external static num get QUARTER;
  external static set QUARTER(num v);

  /// Number of milliseconds in a second.
  external static num get SECOND;
  external static set SECOND(num v);

  /// If true, the timer will automatically destroy itself after all the events have been dispatched (assuming no looping events).
  external bool get autoDestroy;
  external set autoDestroy(bool v);

  /// The duration in ms remaining until the next event will occur.
  external num get duration;
  external set duration(num v);

  /// An array holding all of this timers Phaser.TimerEvent objects. Use the methods add, repeat and loop to populate it.
  external List<TimerEvent> get events;
  external set events(List<TimerEvent> v);

  /// An expired Timer is one in which all of its events have been dispatched and none are pending.
  external bool get expired;
  external set expired(bool v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// The number of pending events in the queue.
  external num get length;
  external set length(num v);

  /// The duration in milliseconds that this Timer has been running for.
  external num get ms;
  external set ms(num v);

  /// The time at which the next event will occur.
  external num get next;
  external set next(num v);

  /// The time the next tick will occur.
  external num get nextTick;
  external set nextTick(num v);

  /// This signal will be dispatched when this Timer has completed which means that there are no more events in the queue.
  /// The signal is supplied with one argument, `timer`, which is this Timer object.
  external Signal get onComplete;
  external set onComplete(Signal v);

  /// True if the Timer is actively running.
  /// Do not modify this boolean - use [Phaser.Timer#pause pause] (and [Phaser.Timer#resume resume]) to pause the timer.
  external bool get running;
  external set running(bool v);

  /// The paused state of the Timer. You can pause the timer by calling Timer.pause() and Timer.resume() or by the game pausing.
  external bool get paused;
  external set paused(bool v);

  /// The duration in seconds that this Timer has been running for.
  external num get seconds;
  external set seconds(num v);

  /// Adds a new Event to this Timer.
  /// The event will fire after the given amount of `delay` in milliseconds has passed, once the Timer has started running.
  /// The delay is in relation to when the Timer starts, not the time it was added. If the Timer is already running the delay will be calculated based on the timers current time.
  /// Make sure to call [Phaser.Timer#start start] after adding all of the Events you require for this Timer.
  external TimerEvent add(num delay, Function callback,
      [dynamic callbackContext,
      dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Clears any events from the Timer which have pendingDelete set to true and then resets the private _len and _i values.
  external void clearPendingEvents();

  /// Destroys this Timer. Any pending Events are not dispatched.
  /// The onComplete callbacks won't be called.
  external void destroy();

  /// Adds a new looped Event to this Timer that will repeat forever or until the Timer is stopped.
  /// The event will fire after the given amount of `delay` in milliseconds has passed, once the Timer has started running.
  /// The delay is in relation to when the Timer starts, not the time it was added. If the Timer is already running the delay will be calculated based on the timers current time.
  /// Make sure to call [Phaser.Timer#start start] after adding all of the Events you require for this Timer.
  external TimerEvent loop(num delay, Function callback,
      [dynamic callbackContext,
      dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Orders the events on this Timer so they are in tick order.
  /// This is called automatically when new events are created.
  external void order();

  /// Pauses the Timer and all events in the queue.
  external void pause();

  /// Removes a pending TimerEvent from the queue.
  external bool remove(TimerEvent event);

  /// Removes all Events from this Timer and all callbacks linked to onComplete, but leaves the Timer running.
  /// The onComplete callbacks won't be called.
  external void removeAll();

  /// Adds a new TimerEvent that will always play through once and then repeat for the given number of iterations.
  /// The event will fire after the given amount of `delay` in milliseconds has passed, once the Timer has started running.
  /// The delay is in relation to when the Timer starts, not the time it was added.
  /// If the Timer is already running the delay will be calculated based on the timers current time.
  /// Make sure to call [Phaser.Timer#start start] after adding all of the Events you require for this Timer.
  external TimerEvent repeat(num delay, num repeatCount, Function callback,
      [dynamic callbackContext,
      dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Resumes the Timer and updates all pending events.
  external void resume();

  /// Sort handler used by Phaser.Timer.order.
  external num sortHandler(dynamic a, dynamic b);

  /// Starts this Timer running.
  external void start([num startDelay]);

  /// Stops this Timer from running. Does not cause it to be destroyed if autoDestroy is set to true.
  external void stop([bool clearEvents]);

  /// The main Timer update event, called automatically by Phaser.Time.update.
  external bool update(num time);
}

/// A TimerEvent is a single event that is processed by a Phaser.Timer.
/// It consists of a delay, which is a value in milliseconds after which the event will fire.
/// When the event fires it calls a specific callback with the specified arguments.
/// TimerEvents are removed by their parent timer once finished firing or repeating.
/// Use [Phaser.Timer#add], [Phaser.Timer#repeat], or [Phaser.Timer#loop] methods to create a new event.
@JS("Phaser.TimerEvent")
class TimerEvent {
  // @Ignore
  TimerEvent.fakeConstructor$();

  /// A TimerEvent is a single event that is processed by a Phaser.Timer.
  /// It consists of a delay, which is a value in milliseconds after which the event will fire.
  /// When the event fires it calls a specific callback with the specified arguments.
  /// TimerEvents are removed by their parent timer once finished firing or repeating.
  /// Use [Phaser.Timer#add], [Phaser.Timer#repeat], or [Phaser.Timer#loop] methods to create a new event.
  external factory TimerEvent(Timer timer, num delay, num tick, num repeatCount,
      bool loop, Function callback, dynamic callbackContext,
      [dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Additional arguments to be passed to the callback.
  external List<dynamic> get args;
  external set args(List<dynamic> v);

  /// The callback that will be called when the TimerEvent occurs.
  external Function get callback;
  external set callback(Function v);

  /// The context in which the callback will be called.
  external dynamic get callbackContext;
  external set callbackContext(dynamic v);

  /// The delay in ms at which this TimerEvent fires.
  external num get delay;
  external set delay(num v);

  /// True if this TimerEvent loops, otherwise false.
  external bool get loop;
  external set loop(bool v);

  /// A flag that controls if the TimerEvent is pending deletion.
  external bool get pendingDelete;
  external set pendingDelete(bool v);

  /// If this TimerEvent repeats it will do so this many times.
  external num get repeatCount;
  external set repeatCount(num v);

  /// The tick is the next game clock time that this event will fire at.
  external num get tick;
  external set tick(num v);

  /// The Timer object that this TimerEvent belongs to.
  external Timer get timer;
  external set timer(Timer v);
}

/// Phaser.Touch handles touch events with your game. Note: Android 2.x only supports 1 touch event at once, no multi-touch.
/// You should not normally access this class directly, but instead use a Phaser.Pointer object which normalises all game input for you.
@JS("Phaser.Touch")
class Touch {
  // @Ignore
  Touch.fakeConstructor$();

  /// Phaser.Touch handles touch events with your game. Note: Android 2.x only supports 1 touch event at once, no multi-touch.
  /// You should not normally access this class directly, but instead use a Phaser.Pointer object which normalises all game input for you.
  external factory Touch(Game game);

  /// The context under which callbacks are called.
  external dynamic get callbackContext;
  external set callbackContext(dynamic v);

  /// Touch events will only be processed if enabled.
  /// Default: true
  external bool get enabled;
  external set enabled(bool v);

  /// The browser touch DOM event. Will be set to null if no touch event has ever been received.
  external dynamic get event;
  external set event(dynamic v);

  /// A reference to the currently running game.
  external Game get game;
  external set game(Game v);

  /// If true the TouchEvent will have prevent.default called on it.
  /// Default: true
  external bool get preventDefault;
  external set preventDefault(bool v);

  /// A callback that can be fired on a touchCancel event.
  external Function get touchCancelCallback;
  external set touchCancelCallback(Function v);

  /// A callback that can be fired on a touchEnd event.
  external Function get touchEndCallback;
  external set touchEndCallback(Function v);

  /// A callback that can be fired on a touchEnter event.
  external Function get touchEnterCallback;
  external set touchEnterCallback(Function v);

  /// A callback that can be fired on a touchLeave event.
  external Function get touchLeaveCallback;
  external set touchLeaveCallback(Function v);

  /// A callback that can be fired on a touchMove event.
  external Function get touchMoveCallback;
  external set touchMoveCallback(Function v);

  /// A callback that can be fired on a touchStart event.
  external Function get touchStartCallback;
  external set touchStartCallback(Function v);
  external List<Function> get touchLockCallbacks;
  external set touchLockCallbacks(List<Function> v);

  /// Adds a callback that is fired when a browser touchstart or touchend event is received.
  external void addTouchLockCallback(Function callback,
      [dynamic context, bool onEnd]);

  /// Removes the callback at the defined index from the touchLockCallbacks array.
  external bool removeTouchLockCallback(Function callback, [dynamic context]);

  /// Consumes all touchmove events on the document (only enable this if you know you need it!).
  external void consumeTouchMove();

  /// Touch cancel - touches that were disrupted (perhaps by moving into a plugin or browser chrome).
  /// Occurs for example on iOS when you put down 4 fingers and the app selector UI appears.
  external void onTouchCancel(dynamic event);

  /// The handler for the touchend events.
  external void onTouchEnd(dynamic event);

  /// For touch enter and leave its a list of the touch points that have entered or left the target.
  /// Doesn't appear to be supported by most browsers on a canvas element yet.
  external void onTouchEnter(dynamic event);

  /// For touch enter and leave its a list of the touch points that have entered or left the target.
  /// Doesn't appear to be supported by most browsers on a canvas element yet.
  external void onTouchLeave(dynamic event);

  /// The handler for the touchmove events.
  external void onTouchMove(dynamic event);

  /// The internal method that handles the touchstart event from the browser.
  external void onTouchStart(dynamic event);

  /// Starts the event listeners running.
  external void start();

  /// Stop the event listeners.
  external void stop();
}

/// A Tween allows you to alter one or more properties of a target object over a defined period of time.
/// This can be used for things such as alpha fading Sprites, scaling them or motion.
/// Use `Tween.to` or `Tween.from` to set-up the tween values. You can create multiple tweens on the same object
/// by calling Tween.to multiple times on the same Tween. Additional tweens specified in this way become "child" tweens and
/// are played through in sequence. You can use Tween.timeScale and Tween.reverse to control the playback of this Tween and all of its children.
@JS("Phaser.Tween")
class Tween {
  // @Ignore
  Tween.fakeConstructor$();

  /// A helper for tweening [Phaser.Color.createColor color objects].
  /// It can be passed to [Phaser.Tween#onUpdateCallback onUpdateCallback].
  /// ```javascript
  /// var color = Phaser.Color.createColor(255, 0, 0); // red
  /// var tween = game.add.tween(color).to({
  /// r: 0, g: 0, b: 255 // blue
  /// });
  /// tween.onUpdateCallback(Phaser.Tween.updateColor);
  /// tween.start();
  /// ```
  external static void updateColor(Tween tween);

  /// A Tween allows you to alter one or more properties of a target object over a defined period of time.
  /// This can be used for things such as alpha fading Sprites, scaling them or motion.
  /// Use `Tween.to` or `Tween.from` to set-up the tween values. You can create multiple tweens on the same object
  /// by calling Tween.to multiple times on the same Tween. Additional tweens specified in this way become "child" tweens and
  /// are played through in sequence. You can use Tween.timeScale and Tween.reverse to control the playback of this Tween and all of its children.
  external factory Tween(dynamic target, Game game, TweenManager manager);

  /// If this Tween is chained to another this holds a reference to it.
  external Tween get chainedTween;
  external set chainedTween(Tween v);

  /// The current Tween child being run.
  external num get current;
  external set current(num v);

  /// Is this Tween frame or time based? A frame based tween will use the physics elapsed timer when updating. This means
  /// it will retain the same consistent frame rate, regardless of the speed of the device. The duration value given should
  /// be given in frames.
  /// If the Tween uses a time based update (which is the default) then the duration is given in milliseconds.
  /// In this situation a 2000ms tween will last exactly 2 seconds, regardless of the device and how many visual updates the tween
  /// has actually been through. For very short tweens you may wish to experiment with a frame based update instead.
  /// The default value is whatever you've set in TweenManager.frameBased.
  external bool get frameBased;
  external set frameBased(bool v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// If the tween is running this is set to true, otherwise false. Tweens that are in a delayed state or waiting to start are considered as being running.
  external bool get isRunning;
  external set isRunning(bool v);

  /// Is this Tween paused or not?
  external bool get isPaused;
  external set isPaused(bool v);

  /// Reference to the TweenManager responsible for updating this Tween.
  external TweenManager get manager;
  external set manager(TweenManager v);

  /// The onChildComplete event is fired when the Tween or any of its children completes.
  /// Fires every time a child completes unless a child is set to repeat forever.
  /// It will be sent 2 parameters: the target object and this tween.
  external Signal get onChildComplete;
  external set onChildComplete(Signal v);

  /// The onComplete event is fired when the Tween and all of its children completes. Does not fire if the Tween is set to loop or repeatAll(-1).
  /// It will be sent 2 parameters: the target object and this tween.
  external Signal get onComplete;
  external set onComplete(Signal v);

  /// The onLoop event is fired if the Tween, or any child tweens loop.
  /// It will be sent 2 parameters: the target object and this tween.
  external Signal get onLoop;
  external set onLoop(Signal v);

  /// The onRepeat event is fired if the Tween and all of its children repeats. If this tween has no children this will never be fired.
  /// It will be sent 2 parameters: the target object and this tween.
  external Signal get onRepeat;
  external set onRepeat(Signal v);

  /// The onStart event is fired when the Tween begins. If there is a delay before the tween starts then onStart fires after the delay is finished.
  /// It will be sent 2 parameters: the target object and this tween.
  external Signal get onStart;
  external set onStart(Signal v);

  /// True if this Tween is ready to be deleted by the TweenManager.
  external bool get pendingDelete;
  external set pendingDelete(bool v);

  /// Target property cache used when building the child data values.
  external dynamic get properties;
  external set properties(dynamic v);

  /// If the Tween and any child tweens are set to repeat this contains the current repeat count.
  external num get repeatCounter;
  external set repeatCounter(num v);

  /// If set to `true` the current tween will play in reverse.
  /// If the tween hasn't yet started this has no effect.
  /// If there are child tweens then all child tweens will play in reverse from the current point.
  external bool get reverse;
  external set reverse(bool v);

  /// The target object, such as a Phaser.Sprite or property like Phaser.Sprite.scale.
  external dynamic get target;
  external set target(dynamic v);

  /// An Array of TweenData objects that comprise the different parts of this Tween.
  external List<TweenData> get timeline;
  external set timeline(List<TweenData> v);

  /// The speed at which the tweens will run. A value of 1 means it will match the game frame rate. 0.5 will run at half the frame rate. 2 at double the frame rate, etc.
  /// If a tweens duration is 1 second but timeScale is 0.5 then it will take 2 seconds to complete.
  /// Default: 1
  external num get timeScale;
  external set timeScale(num v);

  /// Gets the total duration of this Tween, including all child tweens, in milliseconds.
  external num get totalDuration;
  external set totalDuration(num v);

  /// This method allows you to chain tweens together. Any tween chained to this tween will have its `Tween.start` method called
  /// as soon as this tween completes. If this tween never completes (i.e. repeatAll or loop is set) then the chain will never progress.
  /// Note that `Tween.onComplete` will fire when *this* tween completes, not when the whole chain completes.
  /// For that you should listen to `onComplete` on the final tween in your chain.
  /// If you pass multiple tweens to this method they will be joined into a single long chain.
  /// For example if this is Tween A and you pass in B, C and D then B will be chained to A, C will be chained to B and D will be chained to C.
  /// Any previously chained tweens that may have been set will be overwritten.
  external Tween chain(
      [dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Sets the delay in milliseconds before this tween will start. If there are child tweens it sets the delay before the first child starts.
  /// The delay is invoked as soon as you call `Tween.start`. If the tween is already running this method doesn't do anything for the current active tween.
  /// If you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to delay.
  /// If you have child tweens and pass -1 as the index value it sets the delay across all of them.
  external Tween delay(num duration, [num index]);

  /// Set easing function this tween will use, i.e. Phaser.Easing.Linear.None.
  /// The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as "Circ".
  /// ".easeIn", ".easeOut" and "easeInOut" variants are all supported for all ease types.
  /// If you have child tweens and pass -1 as the index value it sets the easing function defined here across all of them.
  /*external Tween easing(Function ease, [num index]);*/
  /// Set easing function this tween will use, i.e. Phaser.Easing.Linear.None.
  /// The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as "Circ".
  /// ".easeIn", ".easeOut" and "easeInOut" variants are all supported for all ease types.
  /// If you have child tweens and pass -1 as the index value it sets the easing function defined here across all of them.
  /*external Tween easing(String ease, [num index]);*/
  external Tween easing(dynamic /*Function|String*/ ease, [num index]);

  /// Sets this tween to be a `from` tween on the properties given. A `from` tween sets the target to the destination value and tweens to its current value.
  /// For example a Sprite with an `x` coordinate of 100 tweened from `x` 500 would be set to `x` 500 and then tweened to `x` 100 by giving a properties object of `{ x: 500 }`.
  /// The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as "Circ".
  /// ".easeIn", ".easeOut" and "easeInOut" variants are all supported for all ease types.
  /*external Tween from(dynamic properties,
    [num duration,
    Function ease,
    bool autoStart,
    num delay,
    num repeat,
    bool yoyo]);*/
  /// Sets this tween to be a `from` tween on the properties given. A `from` tween sets the target to the destination value and tweens to its current value.
  /// For example a Sprite with an `x` coordinate of 100 tweened from `x` 500 would be set to `x` 500 and then tweened to `x` 100 by giving a properties object of `{ x: 500 }`.
  /// The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as "Circ".
  /// ".easeIn", ".easeOut" and "easeInOut" variants are all supported for all ease types.
  /*external Tween from(dynamic properties,
    [num duration,
    String ease,
    bool autoStart,
    num delay,
    num repeat,
    bool yoyo]);*/
  external Tween from(dynamic properties,
      [num duration,
      dynamic /*Function|String*/ ease,
      bool autoStart,
      num delay,
      num repeat,
      bool yoyo]);

  /// This will generate an array populated with the tweened object values from start to end.
  /// It works by running the tween simulation at the given frame rate based on the values set-up in Tween.to and Tween.from.
  /// It ignores delay and repeat counts and any chained tweens, but does include child tweens.
  /// Just one play through of the tween data is returned, including yoyo if set.
  external List<dynamic> generateData([num frameRate, dynamic data]);

  /// Sets the interpolation function the tween will use. By default it uses Phaser.Math.linearInterpolation.
  /// Also available: Phaser.Math.bezierInterpolation and Phaser.Math.catmullRomInterpolation.
  /// The interpolation function is only used if the target properties is an array.
  /// If you have child tweens and pass -1 as the index value and it will set the interpolation function across all of them.
  external Tween interpolation(Function interpolation,
      [dynamic context, num index]);

  /// Enables the looping of this tween. The tween will loop forever, and onComplete will never fire.
  /// If `value` is `true` then this is the same as setting `Tween.repeatAll(-1)`.
  /// If `value` is `false` it is the same as setting `Tween.repeatAll(0)` and will reset the `repeatCounter` to zero.
  /// Usage:
  /// game.add.tween(p).to({ x: 700 }, 1000, Phaser.Easing.Linear.None, true)
  /// .to({ y: 300 }, 1000, Phaser.Easing.Linear.None)
  /// .to({ x: 0 }, 1000, Phaser.Easing.Linear.None)
  /// .to({ y: 0 }, 1000, Phaser.Easing.Linear.None)
  /// .loop();
  external Tween loop([bool value]);

  /// Sets a callback to be fired each time this tween updates.
  /// The callback receives the current Tween, the [Phaser.TweenData#value 'value' of the current TweenData], and the current [Phaser.TweenData TweenData]. The second parameter is most useful.
  /// ```javascript
  /// tween.onUpdateCallback(function (tween, value, tweenData) {
  /// console.log('Tween running -- percent: %.2f value: %.2f', tweenData.percent, value);
  /// });
  /// ```
  external Tween onUpdateCallback(Function callback, [dynamic callbackContext]);

  /// Pauses the tween. Resume playback with Tween.resume.
  external void pause();

  /// Sets the number of times this tween will repeat.
  /// If you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to repeat.
  /// If you have child tweens and pass -1 as the index value it sets the number of times they'll repeat across all of them.
  /// If you wish to define how many times this Tween and all children will repeat see Tween.repeatAll.
  external Tween repeat(num total, [num repeatDelay, num index]);

  /// Sets the delay in milliseconds before this tween will repeat itself.
  /// The repeatDelay is invoked as soon as you call `Tween.start`. If the tween is already running this method doesn't do anything for the current active tween.
  /// If you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to set repeatDelay on.
  /// If you have child tweens and pass -1 as the index value it sets the repeatDelay across all of them.
  external Tween repeatDelay(num duration, [num index]);

  /// Set how many times this tween and all of its children will repeat.
  /// A tween (A) with 3 children (B,C,D) with a `repeatAll` value of 2 would play as: ABCDABCD before completing.
  external Tween repeatAll([num total]);

  /// Resumes a paused tween.
  external void resume();

  /// Starts the tween running. Can also be called by the `autoStart` parameter of [Phaser.Tween#to to] or [Phaser.Tween#from from].
  /// This sets the [Phaser.Tween#isRunning isRunning] property to `true` and dispatches the [Phaser.Tween#onStart onStart] signal.
  /// If the tween has a delay set then nothing will start tweening until the delay has expired.
  /// If the tween is already running, is flagged for deletion (such as after [Phaser.Tween#stop stop]),
  /// or has an empty timeline, calling start has no effect and the `onStart` signal is not dispatched.
  external Tween start([num index]);

  /// Stops the tween if running and flags it for deletion from the TweenManager. The tween can't be [#start restarted] after this.
  /// The [Phaser.Tween#onComplete onComplete] signal is not dispatched and no chained tweens are started unless the `complete` parameter is set to `true`.
  /// If you just wish to pause a tween then use [Phaser.Tween#pause pause] instead.
  /// If the tween is not running, it is **not** flagged for deletion and can be started again.
  external Tween stop([bool complete]);

  /// Sets this tween to be a `to` tween on the properties given. A `to` tween starts at the current value and tweens to the destination value given.
  /// For example a Sprite with an `x` coordinate of 100 could be tweened to `x` 200 by giving a properties object of `{ x: 200 }`.
  /// The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as "Circ".
  /// ".easeIn", ".easeOut" and "easeInOut" variants are all supported for all ease types.
  /*external Tween to(dynamic properties,
    [num duration,
    Function ease,
    bool autoStart,
    num delay,
    num repeat,
    bool yoyo]);*/
  /// Sets this tween to be a `to` tween on the properties given. A `to` tween starts at the current value and tweens to the destination value given.
  /// For example a Sprite with an `x` coordinate of 100 could be tweened to `x` 200 by giving a properties object of `{ x: 200 }`.
  /// The ease function allows you define the rate of change. You can pass either a function such as Phaser.Easing.Circular.Out or a string such as "Circ".
  /// ".easeIn", ".easeOut" and "easeInOut" variants are all supported for all ease types.
  /*external Tween to(dynamic properties,
    [num duration,
    String ease,
    bool autoStart,
    num delay,
    num repeat,
    bool yoyo]);*/
  external Tween to(dynamic properties,
      [num duration,
      dynamic /*Function|String*/ ease,
      bool autoStart,
      num delay,
      num repeat,
      bool yoyo]);

  /// Core tween update function called by the TweenManager. Does not need to be invoked directly.
  external bool update(num time);

  /// Updates either a single TweenData or all TweenData objects properties to the given value.
  /// Used internally by methods like Tween.delay, Tween.yoyo, etc. but can also be called directly if you know which property you want to tweak.
  /// The property is not checked, so if you pass an invalid one you'll generate a run-time error.
  external Tween updateTweenData(
      String property, dynamic /*num|Function*/ value,
      [num index]);

  /// A Tween that has yoyo set to true will run through from its starting values to its end values and then play back in reverse from end to start.
  /// Used in combination with repeat you can create endless loops.
  /// If you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to yoyo.
  /// If you have child tweens and pass -1 as the index value it sets the yoyo property across all of them.
  /// If you wish to yoyo this Tween and all of its children then see Tween.yoyoAll.
  external Tween yoyo(bool enable, [num yoyoDelay, num index]);

  /// Sets the delay in milliseconds before this tween will run a yoyo (only applies if yoyo is enabled).
  /// The repeatDelay is invoked as soon as you call `Tween.start`. If the tween is already running this method doesn't do anything for the current active tween.
  /// If you have not yet called `Tween.to` or `Tween.from` at least once then this method will do nothing, as there are no tweens to set repeatDelay on.
  /// If you have child tweens and pass -1 as the index value it sets the repeatDelay across all of them.
  external Tween yoyoDelay(num duration, [num index]);
}

/// A Phaser.Tween contains at least one TweenData object. It contains all of the tween data values, such as the
/// starting and ending values, the ease function, interpolation and duration. The Tween acts as a timeline manager for
/// TweenData objects and can contain multiple TweenData objects.
@JS("Phaser.TweenData")
class TweenData {
  // @Ignore
  TweenData.fakeConstructor$();

  /// A Phaser.Tween contains at least one TweenData object. It contains all of the tween data values, such as the
  /// starting and ending values, the ease function, interpolation and duration. The Tween acts as a timeline manager for
  /// TweenData objects and can contain multiple TweenData objects.
  external factory TweenData(Tween parent);
  external static num get COMPLETE;
  external static set COMPLETE(num v);
  external static num get LOOPED;
  external static set LOOPED(num v);
  external static num get PENDING;
  external static set PENDING(num v);
  external static num get RUNNING;
  external static set RUNNING(num v);

  /// The amount to delay by until the Tween starts (in ms). Only applies to the start, use repeatDelay to handle repeats.
  external num get delay;
  external set delay(num v);

  /// Current time value.
  external num get dt;
  external set dt(num v);

  /// The duration of the tween in ms.
  /// Default: 1000
  external num get duration;
  external set duration(num v);

  /// The easing function used for the Tween.
  /// Default: Phaser.Easing.Default
  external Function get easingFunction;
  external set easingFunction(Function v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// When a Tween is yoyoing this value holds if it's currently playing forwards (false) or in reverse (true).
  external bool get inReverse;
  external set inReverse(bool v);

  /// True if the Tween will use interpolation (i.e. is an Array to Array tween)
  external bool get interpolate;
  external set interpolate(bool v);
  external Math get interpolateFunctionContext;
  external set interpolateFunctionContext(Math v);

  /// The interpolation function context used for the Tween.
  /// Default: Phaser.Math
  external Math get interpolationContext;
  external set interpolationContext(Math v);

  /// The interpolation function used for Array-based Tween.
  /// Default: Phaser.Math.linearInterpolation
  external Function get interpolationFunction;
  external set interpolationFunction(Function v);

  /// If the tween is running this is set to `true`. Unless Phaser.Tween a TweenData that is waiting for a delay to expire is *not* considered as running.
  external bool get isRunning;
  external set isRunning(bool v);

  /// Is this a from tween or a to tween?
  external bool get isFrom;
  external set isFrom(bool v);

  /// The Tween which owns this TweenData.
  external Tween get parent;
  external set parent(Tween v);

  /// A value between 0 and 1 that represents how far through the duration this tween is.
  external num get percent;
  external set percent(num v);

  /// If the Tween is set to repeat this is the number of repeats remaining (and `repeatTotal - repeatCounter` is the number of repeats completed).
  external num get repeatCounter;
  external set repeatCounter(num v);

  /// The time the Tween started or null if it hasn't yet started.
  external num get startTime;
  external set startTime(num v);

  /// The output of the easing function for the current [Phaser.TweenData#percent percent]. Depending on the easing function, this will be within [0, 1] or a slightly larger range (e.g., Bounce). When easing is Linear, this will be identical to [Phaser.TweenData#percent percent].
  external num get value;
  external set value(num v);

  /// True if the Tween is set to yoyo, otherwise false.
  external bool get yoyo;
  external set yoyo(bool v);

  /// The amount of time in ms between yoyos of this tween.
  external num get yoyoDelay;
  external set yoyoDelay(num v);

  /// Sets this tween to be a `from` tween on the properties given. A `from` tween sets the target to the destination value and tweens to its current value.
  /// For example a Sprite with an `x` coordinate of 100 tweened from `x` 500 would be set to `x` 500 and then tweened to `x` 100 by giving a properties object of `{ x: 500 }`.
  external TweenData from(dynamic properties,
      [num duration, Function ease, num delay, num repeat, bool yoyo]);

  /// This will generate an array populated with the tweened object values from start to end.
  /// It works by running the tween simulation at the given frame rate based on the values set-up in Tween.to and Tween.from.
  /// Just one play through of the tween data is returned, including yoyo if set.
  external List<dynamic> generateData([num frameRate]);

  /// Checks if this Tween is meant to repeat or yoyo and handles doing so.
  external num repeat();

  /// Starts the Tween running.
  external TweenData start();

  /// Sets this tween to be a `to` tween on the properties given. A `to` tween starts at the current value and tweens to the destination value given.
  /// For example a Sprite with an `x` coordinate of 100 could be tweened to `x` 200 by giving a properties object of `{ x: 200 }`.
  external TweenData to(dynamic properties,
      [num duration, Function ease, num delay, num repeat, bool yoyo]);

  /// Updates this Tween. This is called automatically by Phaser.Tween.
  external num update(num time);
}

/// Phaser.Game has a single instance of the TweenManager through which all Tween objects are created and updated.
/// Tweens are hooked into the game clock and pause system, adjusting based on the game state.
/// TweenManager is based heavily on tween.js by http://soledadpenades.com.
/// The difference being that tweens belong to a games instance of TweenManager, rather than to a global TWEEN object.
/// It also has callbacks swapped for Signals and a few issues patched with regard to properties and completion errors.
/// Please see https://github.com/sole/tween.js for a full list of contributors.
@JS("Phaser.TweenManager")
class TweenManager {
  // @Ignore
  TweenManager.fakeConstructor$();

  /// Phaser.Game has a single instance of the TweenManager through which all Tween objects are created and updated.
  /// Tweens are hooked into the game clock and pause system, adjusting based on the game state.
  /// TweenManager is based heavily on tween.js by http://soledadpenades.com.
  /// The difference being that tweens belong to a games instance of TweenManager, rather than to a global TWEEN object.
  /// It also has callbacks swapped for Signals and a few issues patched with regard to properties and completion errors.
  /// Please see https://github.com/sole/tween.js for a full list of contributors.
  external factory TweenManager(Game game);

  /// Are all newly created Tweens frame or time based? A frame based tween will use the physics elapsed timer when updating. This means
  /// it will retain the same consistent frame rate, regardless of the speed of the device. The duration value given should
  /// be given in frames.
  /// If the Tween uses a time based update (which is the default) then the duration is given in milliseconds.
  /// In this situation a 2000ms tween will last exactly 2 seconds, regardless of the device and how many visual updates the tween
  /// has actually been through. For very short tweens you may wish to experiment with a frame based update instead.
  external bool get frameBased;
  external set frameBased(bool v);

  /// Local reference to game.
  external Game get game;
  external set game(Game v);

  /// Add a new tween into the TweenManager.
  external Tween add(Tween tween);

  /// Create a tween object for a specific object. The object can be any JavaScript object or Phaser object such as Sprite.
  external Tween create(dynamic object);

  /// Get all the tween objects in an array.
  external List<Tween> getAll();

  /// Checks to see if a particular Sprite is currently being tweened.
  /// The `checkIsRunning` parameter will exclude tweens that have **just** completed or been stopped but haven't yet been removed from the manager.
  external bool isTweening(dynamic object, [bool checkIsRunning]);

  /// Remove a tween from this manager.
  external Tween remove(Tween tween);

  /// Remove all tweens running and in the queue. Doesn't call any of the tween onComplete events.
  external void removeAll();

  /// Remove all tweens from a specific object, array of objects or Group.
  external void removeFrom(dynamic obj, [bool children]);

  /// Resumes all currently paused tweens.
  external void resumeAll();

  /// Update all the tween objects you added to this manager.
  external bool update();

  /// Pauses all currently running tweens.
  external void pauseAll();
}

@JS("Phaser.Utils")
class Utils {
  // @Ignore
  Utils.fakeConstructor$();

  /// Gets an object's property by string.
  external static dynamic getProperty(dynamic obj, String prop);

  /// Sets an object's property by name and value.
  /// ```javascript
  /// Phaser.Utils.setProperty(sprite, 'body.velocity.x', 60);
  /// ```
  external static dynamic setProperty(dynamic obj, String prop, dynamic value);

  /// Sets an object's properties from a map of property names and values.
  /// ```javascript
  /// Phaser.Utils.setProperties(sprite, {
  /// 'animations.paused': true,
  /// 'body.enable': false,
  /// 'input.draggable': true,
  /// });
  /// ```
  external static dynamic setProperties(dynamic obj, dynamic props);

  /// Generate a random bool result based on the chance value.
  /// Returns true or false based on the chance value (default 50%). For example if you wanted a player to have a 30% chance
  /// of getting a bonus, call chanceRoll(30) - true means the chance passed, false means it failed.
  external static bool chanceRoll(num chance);

  /// Choose between one of two values randomly.
  external static dynamic randomChoice(
      dynamic /*String|num*/ choice1, dynamic choice2);

  /// Takes the given string and reverses it, returning the reversed string.
  /// For example if given the string `Atari 520ST` it would return `TS025 iratA`.
  external static String reverseString(String string);

  /// Get a unit dimension from a string.
  external static num parseDimension(dynamic size, num dimension);

  /// Takes the given string and pads it out, to the length required, using the character
  /// specified. For example if you need a string to be 6 characters long, you can call:
  /// `pad('bob', 6, '-', 2)`
  /// This would return: `bob---` as it has padded it out to 6 characters, using the `-` on the right.
  /// You can also use it to pad numbers (they are always returned as strings):
  /// `pad(512, 6, '0', 1)`
  /// Would return: `000512` with the string padded to the left.
  /// If you don't specify a direction it'll pad to both sides:
  /// `pad('c64', 7, '*')`
  /// Would return: `**c64**`
  external static String pad(String str, [num len, String pad, num dir]);

  /// This is a slightly modified version of jQuery.isPlainObject.
  /// A plain object is an object whose internal class property is [object Object].
  external static bool isPlainObject(dynamic object);

  /// This is a slightly modified version of http://api.jquery.com/jQuery.extend/
  external static dynamic extend(bool deep, dynamic target,
      [dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Mixes in an existing mixin object with the target.
  /// Values in the mixin that have either `get` or `set` functions are created as properties via `defineProperty`
  /// _except_ if they also define a `clone` method - if a clone method is defined that is called instead and
  /// the result is assigned directly.
  external static void mixinPrototype(dynamic target, dynamic mixin,
      [bool replace]);

  /// Mixes the source object into the destination object, returning the newly modified destination object.
  /// Based on original code by @mudcube
  external static dynamic/*=T*/ mixin/*<T>*/(dynamic/*=T*/ from, dynamic to);
}

// Module Utils
/// A collection of methods for displaying debug information about game objects.
/// If your game is running in Canvas mode, then you should invoke all of the Debug methods from
/// your games `render` function. This is because they are drawn directly onto the game canvas
/// itself, so if you call any debug methods outside of `render` they are likely to be overwritten
/// by the game itself.
/// If your game is running in WebGL then Debug will create a Sprite that is placed at the top of the Stage display list and bind a canvas texture
/// to it, which must be uploaded every frame. Be advised: this is very expensive, especially in browsers like Firefox. So please only enable Debug
/// in WebGL mode if you really need it (or your desktop can cope with it well) and disable it for production!
@JS("Phaser.Utils.Debug")
class Debug {
  // @Ignore
  Debug.fakeConstructor$();

  /// A collection of methods for displaying debug information about game objects.
  /// If your game is running in Canvas mode, then you should invoke all of the Debug methods from
  /// your games `render` function. This is because they are drawn directly onto the game canvas
  /// itself, so if you call any debug methods outside of `render` they are likely to be overwritten
  /// by the game itself.
  /// If your game is running in WebGL then Debug will create a Sprite that is placed at the top of the Stage display list and bind a canvas texture
  /// to it, which must be uploaded every frame. Be advised: this is very expensive, especially in browsers like Firefox. So please only enable Debug
  /// in WebGL mode if you really need it (or your desktop can cope with it well) and disable it for production!
  external factory Debug(Game game);

  /// In WebGL mode this BitmapData contains a copy of the debug canvas.
  external BitmapData get bmd;
  external set bmd(BitmapData v);

  /// The canvas to which Debug calls draws.
  external CanvasElement get canvas;
  external set canvas(CanvasElement v);

  /// The spacing between columns.
  /// Default: 100
  external num get columnWidth;
  external set columnWidth(num v);

  /// The 2d context of the canvas.
  external CanvasRenderingContext2D get context;
  external set context(CanvasRenderingContext2D v);

  /// The alpha of the Debug context, set before all debug information is rendered to it.
  /// Default: 1
  external num get currentAlpha;
  external set currentAlpha(num v);

  /// The current X position the debug information will be rendered at.
  external num get currentX;
  external set currentX(num v);

  /// The current Y position the debug information will be rendered at.
  external num get currentY;
  external set currentY(num v);

  /// Does the canvas need re-rendering?
  external bool get dirty;
  external set dirty(bool v);

  /// The font that the debug information is rendered in.
  /// Default: 14px Courier
  external String get font;
  external set font(String v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// The line height between the debug text.
  /// Default: 16
  external num get lineHeight;
  external set lineHeight(num v);

  /// The width of the stroke on lines and shapes. A positive number.
  /// Default: 1
  external num get lineWidth;
  external set lineWidth(num v);

  /// Should the text be rendered with a slight shadow? Makes it easier to read on different types of background.
  /// Default: true
  external bool get renderShadow;
  external set renderShadow(bool v);

  /// If debugging in WebGL mode, this is the Image displaying the debug [#bmd BitmapData].
  external Image get sprite;
  external set sprite(Image v);
  /// Renamed from `AStar`
  external void doAStar(AStar astar, num x, num y, bool showVisited);

  /// Internal method that boots the debug displayer.
  external void boot();

  /// Render a Sprites Physics body if it has one set. The body is rendered as a filled or stroked rectangle.
  /// This only works for Arcade Physics, Ninja Physics (AABB and Circle only) and Box2D Physics bodies.
  /// To display a P2 Physics body you should enable debug mode on the body when creating it.
  external void body(
      dynamic /*BitmapText|Button|Graphics|Sprite|Text|TileSprite*/ sprite,
      [String color,
      bool filled]);

  /// Render a Sprites Physic Body information.
  external void bodyInfo(
      dynamic /*BitmapText|Button|Graphics|Sprite|Text|TileSprite*/ sprite,
      num x,
      num y,
      [String color]);

  /// Renders 'debug draw' data for the given Box2D body.
  /// This uses the standard debug drawing feature of Box2D, so colors will be decided by the Box2D engine.
  external void box2dBody(dynamic body, [String color]);

  /// Renders 'debug draw' data for the Box2D world if it exists.
  /// This uses the standard debug drawing feature of Box2D, so colors will be decided by
  /// the Box2D engine.
  external void box2dWorld();

  /// Marks the follow [Phaser.Utils.Debug#target target] and [Phaser.Utils.Debug#deadzone deadzone].
  external void camera(Camera camera, [String color, bool filled]);

  /// Render camera information including dimensions and location.
  external void cameraInfo(Camera camera, num x, num y, [String color]);

  /// Destroy this object.
  external void destroy();

  /// Renders a Phaser geometry object including Rectangle, Circle, Ellipse, Point or Line.
  external void geom(dynamic object,
      [String color, bool fiiled, num forceType]);

  /// Render debug information about the Input object.
  external void inputInfo(num x, num y, [String color]);

  /// Renders Line information in the given color.
  external void lineInfo(Line line, num x, num y, [String color]);

  /// Renders Phaser.Key object information.
  external void key(Key key, [num x, num y, String color]);

  /// Internal method that outputs a single line of text split over as many columns as needed, one per parameter.
  external void line(
      [String args1, String args2, String args3, String args4, String args5]);

  /// Prints Phaser [Phaser.VERSION version], [Phaser.Game.#renderType rendering mode], and [Phaser.Device#webAudio device audio support].
  external void phaser(num x, num y, [String color]);

  /// Internal method that clears the canvas (if a Sprite) ready for a new debug session.
  external void preUpdate();

  /// Render each physics [Phaser.Utils.Debug#body body] in a group.
  external void physicsGroup(Group group,
      [String color, bool filled, bool checkExists]);

  /// Renders a single pixel at the given size.
  external void pixel(num x, num y, [String color, num size]);

  /// Renders the Pointer.circle object onto the stage in green if down or red if up along with debug text.
  external void pointer(Pointer pointer,
      [bool hideIfUp, String downColor, String upColor, String color]);

  /// Visually renders a QuadTree to the display.
  external void quadTree(QuadTree quadtree, [String color]);

  /// Renders a Rectangle.
  external void rectangle(Rectangle object, [String color, bool filled]);

  /// Prints a description of the [Phaser.Game#renderer renderer] and render session.
  external void renderer([num x, num y, String color]);

  /// Clears the Debug canvas.
  external void reset();

  /// Renders the Rope's segments. Note: This is really expensive as it has to calculate new segments every time you call it
  external void ropeSegments(Rope rope, [num color, bool filled]);

  /// Render Sound information, including decoded state, duration, volume and more.
  external void soundInfo(Sound sound, num x, num y, [String color]);

  /// Renders the Sprites bounds. Note: This is really expensive as it has to calculate the bounds every time you call it!
  external void spriteBounds(dynamic sprite, [String color, bool filled]);

  /// Renders the sprite coordinates in local, positional and world space.
  external void spriteCoords(dynamic sprite, num x, num y, [String color]);

  /// Render debug infos (including name, bounds info, position and some other properties) about the Sprite.
  external void spriteInfo(Sprite sprite, num x, num y, [String color]);

  /// Render Sprite Input Debug information.
  external void spriteInputInfo(Sprite sprite, num x, num y, [String color]);

  /// Internal method that resets and starts the debug output values.
  external void start([num x, num y, String color, num columnWidth]);

  /// Internal method that stops the debug output.
  external void stop();

  /// Render a string of text.
  external void text(String text, num x, num y, [String color, String font]);

  /// Render Timer information.
  external void timer(Timer timer, num x, num y, [String color]);
}

// End module Utils
/// The Weapon Plugin provides the ability to easily create a bullet pool and manager.
/// Weapons fire [Phaser.Bullet] objects, which are essentially Sprites with a few extra properties.
/// The Bullets are enabled for [Phaser.Physics.Arcade Arcade Physics]. They do not currently work with P2 Physics.
/// The Bullets are created inside of [#bullets weapon.bullets], which is a [Phaser.Group] instance. Anything you
/// can usually do with a Group, such as move it around the display list, iterate it, etc can be done
/// to the bullets Group too.
/// Bullets can have textures and even animations. You can control the speed at which they are fired,
/// the firing rate, the firing angle, and even set things like gravity for them.
/// A small example, using [Phaser.GameObjectFactory#weapon add.weapon], assumed to be running from within a [Phaser.State#create] method:
/// ```javascript
/// var weapon = this.add.weapon(10, 'bullet');
/// weapon.fireFrom.set(300, 300);
/// this.input.onDown.add(weapon.fire, this);
/// ```
/// If you want to (re)create the bullet pool separately, you can use:
/// ```javascript
/// var weapon = this.game.plugins.add(Phaser.Weapon);
/// // 
/// weapon.createBullets(10, 'bullet');
/// ```
@JS("Phaser.Weapon")
class Weapon extends Plugin {
  // @Ignore
  Weapon.fakeConstructor$() : super.fakeConstructor$();

  /// The Weapon Plugin provides the ability to easily create a bullet pool and manager.
  /// Weapons fire [Phaser.Bullet] objects, which are essentially Sprites with a few extra properties.
  /// The Bullets are enabled for [Phaser.Physics.Arcade Arcade Physics]. They do not currently work with P2 Physics.
  /// The Bullets are created inside of [#bullets weapon.bullets], which is a [Phaser.Group] instance. Anything you
  /// can usually do with a Group, such as move it around the display list, iterate it, etc can be done
  /// to the bullets Group too.
  /// Bullets can have textures and even animations. You can control the speed at which they are fired,
  /// the firing rate, the firing angle, and even set things like gravity for them.
  /// A small example, using [Phaser.GameObjectFactory#weapon add.weapon], assumed to be running from within a [Phaser.State#create] method:
  /// ```javascript
  /// var weapon = this.add.weapon(10, 'bullet');
  /// weapon.fireFrom.set(300, 300);
  /// this.input.onDown.add(weapon.fire, this);
  /// ```
  /// If you want to (re)create the bullet pool separately, you can use:
  /// ```javascript
  /// var weapon = this.game.plugins.add(Phaser.Weapon);
  /// // 
  /// weapon.createBullets(10, 'bullet');
  /// ```
  external factory Weapon(Game game, PluginManager parent);

  /// A [Phaser.Weapon#bulletKillType bulletKillType] constant that stops the bullets from ever being destroyed automatically.
  external static num get KILL_NEVER;
  external static set KILL_NEVER(num v);

  /// A [Phaser.Weapon#bulletKillType bulletKillType] constant that automatically kills the bullets when their [Phaser.Weapon#bulletLifespan bulletLifespan] expires.
  external static num get KILL_LIFESPAN;
  external static set KILL_LIFESPAN(num v);

  /// A [Phaser.Weapon#bulletKillType bulletKillType] constant that automatically kills the bullets after they
  /// exceed the [Phaser.Weapon#bulletDistance bulletDistance] from their original firing position.
  external static num get KILL_DISTANCE;
  external static set KILL_DISTANCE(num v);

  /// A [Phaser.Weapon#bulletKillType bulletKillType] constant that automatically kills the bullets when they leave the [Phaser.Weapon#bounds bounds] rectangle.
  external static num get KILL_WEAPON_BOUNDS;
  external static set KILL_WEAPON_BOUNDS(num v);

  /// A [Phaser.Weapon#bulletKillType bulletKillType] constant that automatically kills the bullets when they leave the [Phaser.Camera#bounds] rectangle.
  external static num get KILL_CAMERA_BOUNDS;
  external static set KILL_CAMERA_BOUNDS(num v);

  /// A [Phaser.Weapon#bulletKillType bulletKillType] constant that automatically kills the bullets when they leave the [Phaser.World#bounds] rectangle.
  external static num get KILL_WORLD_BOUNDS;
  external static set KILL_WORLD_BOUNDS(num v);

  /// A [Phaser.Weapon#bulletKillType bulletKillType] constant that automatically kills the bullets when they leave the [Phaser.Weapon#bounds bounds] rectangle.
  external static num get KILL_STATIC_BOUNDS;
  external static set KILL_STATIC_BOUNDS(num v);

  /// Should the bullet pool run out of bullets (i.e. they are all in flight) then this
  /// boolean controls if the Group will create a brand new bullet object or not.
  external bool get autoExpandBulletsGroup;
  external set autoExpandBulletsGroup(bool v);

  /// Will this weapon auto fire? If set to true then a new bullet will be fired
  /// based on the [Phaser.Weapon#fireRate fireRate] value.
  external bool get autofire;
  external set autofire(bool v);

  /// This Rectangle defines the bounds that are used when determining if a Bullet should be killed or not.
  /// It's used in combination with [Phaser.Weapon#bulletKillType bulletKillType] when that is set to either `Phaser.Weapon.KILL_WEAPON_BOUNDS`
  /// or `Phaser.Weapon.KILL_STATIC_BOUNDS`. If you are not using either of these kill types then the bounds are ignored.
  /// If you are tracking a Sprite or Point then the bounds are centered on that object every frame.
  external Rectangle get bounds;
  external set bounds(Rectangle v);

  /// An optional angle offset applied to the Bullets when they are launched.
  /// This is useful if for example your bullet sprites have been drawn facing up, instead of
  /// to the right, and you want to fire them at an angle. In which case you can set the
  /// angle offset to be 90 and they'll be properly rotated when fired.
  external num get bulletAngleOffset;
  external set bulletAngleOffset(num v);

  /// This is a variance added to the angle of Bullets when they are fired.
  /// If you fire from an angle of 90 and have a `bulletAngleVariance` of 20 then the actual
  /// angle of the Bullets will be between 70 and 110 degrees. This is a quick way to add a
  /// great 'spread' effect to a Weapon.
  external num get bulletAngleVariance;
  external set bulletAngleVariance(num v);

  /// The string based name of the animation that the Bullet will be given on launch.
  /// This is set via [Phaser.Weapon#addBulletAnimation addBulletAnimation].
  external String get bulletAnimation;
  external set bulletAnimation(String v);

  /// The Class of the bullets that are launched by this Weapon. Defaults to [Phaser.Bullet], but can be
  /// overridden before calling `createBullets` and set to your own class type.
  /// It should be a constructor function accepting `(game, x, y, key, frame)`.
  external dynamic get bulletClass;
  external set bulletClass(dynamic v);

  /// Should bullets collide with the World bounds or not?
  external bool get bulletCollideWorldBounds;
  external set bulletCollideWorldBounds(bool v);

  /// The Texture Frame that the Bullets use when rendering.
  /// Changing this has no effect on bullets in-flight, only on newly spawned bullets.
  external String get bulletFrame;
  external set bulletFrame(String v);

  /// If you've added a set of frames via [Phaser.Weapon#setBulletFrames setBulletFrames] then you can optionally
  /// chose for each Bullet fired to use the next frame in the set. The frame index is then
  /// advanced one frame until it reaches the end of the set, then it starts from the start
  /// again. Cycling frames like this allows you to create varied bullet effects via
  /// sprite sheets.
  external bool get bulletFrameCycle;
  external set bulletFrameCycle(bool v);

  /// If you've added a set of frames via [Phaser.Weapon#setBulletFrames setBulletFrames] then you can optionally
  /// chose for each Bullet fired to pick a random frame from the set.
  external bool get bulletFrameRandom;
  external set bulletFrameRandom(bool v);

  /// This array stores the frames added via @link #setBulletFrames.
  external List<dynamic> get bulletFrames;
  external set bulletFrames(List<dynamic> v);

  /// This is the amount of [Phaser.Physics.Arcade.Body#gravity] added to the Bullets physics body when fired.
  /// Gravity is expressed in pixels / second / second.
  external PhaserPoint get bulletGravity;
  external set bulletGravity(Point v);

  /// When a Bullet is fired it can optionally inherit the velocity of the `trackedSprite` if set.
  external bool get bulletInheritSpriteSpeed;
  external set bulletInheritSpriteSpeed(bool v);

  /// The Texture Key that the Bullets use when rendering.
  /// Changing this has no effect on bullets in-flight, only on newly spawned bullets.
  external String get bulletKey;
  external set bulletKey(String v);

  /// If you've set [Phaser.Weapon#bulletKillType bulletKillType] to `Phaser.Weapon.KILL_DISTANCE` this controls the distance
  /// the Bullet can travel before it is automatically killed. The distance is given in pixels.
  external num get bulletKillDistance;
  external set bulletKillDistance(num v);

  /// This controls how the bullets will be killed. The default is `Phaser.Weapon.KILL_WORLD_BOUNDS`.
  /// There are 7 different "kill types" available:
  /// * `Phaser.Weapon.KILL_NEVER`
  /// The bullets are never destroyed by the Weapon. It's up to you to destroy them via your own code.
  /// * `Phaser.Weapon.KILL_LIFESPAN`
  /// The bullets are automatically killed when their `bulletLifespan` amount expires.
  /// * `Phaser.Weapon.KILL_DISTANCE`
  /// The bullets are automatically killed when they exceed `bulletDistance` pixels away from their original launch position.
  /// * `Phaser.Weapon.KILL_WEAPON_BOUNDS`
  /// The bullets are automatically killed when they no longer intersect with the [Phaser.Weapon#bounds bounds] rectangle.
  /// * `Phaser.Weapon.KILL_CAMERA_BOUNDS`
  /// The bullets are automatically killed when they no longer intersect with the [Phaser.Camera#bounds] rectangle.
  /// * `Phaser.Weapon.KILL_WORLD_BOUNDS`
  /// The bullets are automatically killed when they no longer intersect with the [Phaser.World#bounds] rectangle.
  /// * `Phaser.Weapon.KILL_STATIC_BOUNDS`
  /// The bullets are automatically killed when they no longer intersect with the [Phaser.Weapon#bounds bounds] rectangle.
  /// The difference between static bounds and weapon bounds, is that a static bounds will never be adjusted to
  /// match the position of a tracked sprite or pointer.
  external num get bulletKillType;
  external set bulletKillType(num v);

  /// If you've set [Phaser.Weapon#bulletKillType bulletKillType] to `Phaser.Weapon.KILL_LIFESPAN` this controls the amount
  /// of lifespan the Bullets have set on launch. The value is given in milliseconds.
  /// When a Bullet hits its lifespan limit it will be automatically killed.
  external num get bulletLifespan;
  external set bulletLifespan(num v);

  /// Bullets can optionally adjust their rotation in-flight to match their velocity.
  /// This can create the effect of a bullet 'pointing' to the path it is following, for example
  /// an arrow being fired from a bow, and works especially well when added to [Phaser.Weapon#bulletGravity bulletGravity].
  external bool get bulletRotateToVelocity;
  external set bulletRotateToVelocity(bool v);

  /// This is the Phaser.Group that contains all of the bullets managed by this plugin.
  external Group get bullets;
  external set bullets(Group v);

  /// The initial velocity of fired bullets, in pixels per second.
  /// Default: 200
  external num get bulletSpeed;
  external set bulletSpeed(num v);

  /// This is a variance added to the speed of Bullets when they are fired.
  /// If bullets have a [Phaser.Weapon#bulletSpeed bulletSpeed] value of 200, and a `bulletSpeedVariance` of 50
  /// then the actual speed of the Bullets will be between 150 and 250 pixels per second.
  external num get bulletSpeedVariance;
  external set bulletSpeedVariance(num v);

  /// Should the Bullets wrap around the world bounds? This automatically calls
  /// `World.wrap` on the Bullet each frame. See the docs for that method for details.
  external bool get bulletWorldWrap;
  external set bulletWorldWrap(bool v);

  /// If `bulletWorldWrap` is true then you can provide an optional padding value with this
  /// property. It's added to the calculations determining when the Bullet should wrap around
  /// the world or not. The value is given in pixels.
  external num get bulletWorldWrapPadding;
  external set bulletWorldWrapPadding(num v);

  /// The angle at which the bullets are fired. This can be a const such as Phaser.ANGLE_UP
  /// or it can be any number from 0 to 360 inclusive, where 0 degrees is to the right.
  external num get fireAngle;
  external set fireAngle(num v);

  /// This is a Rectangle from within which the bullets are fired. By default it's a 1x1
  /// rectangle, the equivalent of a Point. But you can change the width and height, and if
  /// larger than 1x1 it'll pick a random point within the rectangle to launch the bullet from.
  external Rectangle get fireFrom;
  external set fireFrom(Rectangle v);

  /// The maximum number of shots that this Weapon is allowed to fire before it stops.
  /// When the limit is his the [Phaser.Weapon#onFireLimit onFireLimit] Signal is dispatched.
  /// You can reset the shot counter via [Phaser.Weapon#resetShots resetShots].
  external num get fireLimit;
  external set fireLimit(num v);

  /// The minimum interval between shots, in milliseconds.
  /// Default: 100
  external num get fireRate;
  external set fireRate(num v);

  /// This is a modifier that is added to the [Phaser.Weapon#fireRate fireRate] each update to add variety
  /// to the firing rate of the Weapon. The value is given in milliseconds.
  /// If you've a `fireRate` of 200 and a `fireRateVariance` of 50 then the actual
  /// firing rate of the Weapon will be between 150 and 250.
  external num get fireRateVariance;
  external set fireRateVariance(num v);

  /// If you want this Weapon to be able to fire more than 1 bullet in a single
  /// update, then set this property to `true`. When `true` the Weapon plugin won't
  /// set the shot / firing timers until the `postRender` phase of the game loop.
  /// This means you can call `fire` (and similar methods) as often as you like in one
  /// single game update.
  external bool get multiFire;
  external set multiFire(bool v);

  /// The onFire Signal is dispatched each time [Phaser.Weapon#fire fire] is called, and a Bullet is
  /// _successfully_ launched. The callback is set two arguments: a reference to the bullet sprite itself,
  /// and a reference to the Weapon that fired the bullet.
  external Signal get onFire;
  external set onFire(Signal v);

  /// The onFireLimit Signal is dispatched if [Phaser.Weapon#fireLimit fireLimit] is > 0, and a bullet launch takes the number
  /// of shots fired to equal the fire limit.
  /// The callback is sent two arguments: A reference to this Weapon, and the value of
  /// [Phaser.Weapon#fireLimit fireLimit].
  external Signal get onFireLimit;
  external set onFireLimit(Signal v);

  /// The onKill Signal is dispatched each time a Bullet that is in-flight is killed. This can be the result
  /// of leaving the Weapon bounds, an expiring lifespan, or exceeding a specified distance.
  /// The callback is sent one argument: A reference to the bullet sprite itself.
  external Signal get onKill;
  external set onKill(Signal v);

  /// The total number of bullets this Weapon has fired so far.
  /// You can limit the number of shots allowed (via [Phaser.Weapon#fireLimit fireLimit]), and reset
  /// this total via [Phaser.Weapon#resetShots resetShots].
  external num get shots;
  external set shots(num v);

  /// The Pointer currently being tracked by the Weapon, if any.
  /// This is set via the [Phaser.Weapon#trackPointer trackPointer] method.
  external Pointer get trackedPointer;
  external set trackedPointer(Pointer v);

  /// The Sprite currently being tracked by the Weapon, if any.
  /// This is set via the [Phaser.Weapon#trackSprite trackSprite] method.
  external dynamic get trackedSprite;
  external set trackedSprite(dynamic v);

  /// The Track Offset is a Point object that allows you to specify a pixel offset that bullets use
  /// when launching from a tracked Sprite or Pointer. For example if you've got a bullet that is 2x2 pixels
  /// in size, but you're tracking a Sprite that is 32x32, then you can set `trackOffset.x = 16` to have
  /// the bullet launched from the center of the Sprite.
  external PhaserPoint get trackOffset;
  external set trackOffset(Point v);

  /// If the Weapon is tracking a Sprite, should it also track the Sprites rotation?
  /// This is useful for a game such as Asteroids, where you want the weapon to fire based
  /// on the sprites rotation.
  external bool get trackRotation;
  external set trackRotation(bool v);

  /// The x coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.x`, and
  /// can be overridden by the [Phaser.Weapon#fire fire] arguments.
  external num get x;
  external set x(num v);

  /// The y coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.y`, and
  /// can be overridden by the [Phaser.Weapon#fire fire] arguments.
  external num get y;
  external set y(num v);

  /// Adds a new animation under the given key. Optionally set the frames, frame rate and loop.
  /// The arguments are all the same as for `Animation.add`, and work in the same way.
  /// [Phaser.Weapon#bulletAnimation bulletAnimation] will be set to this animation after it's created. From that point on, all
  /// bullets fired will play using this animation. You can swap between animations by calling this method
  /// several times, and then just changing the [Phaser.Weapon#bulletAnimation bulletAnimation] property to the name of the animation
  /// you wish to play for the next launched bullet.
  /// If you wish to stop using animations at all, set [Phaser.Weapon#bulletAnimation bulletAnimation] to '' (an empty string).
  external Weapon addBulletAnimation(String name,
      [List<dynamic> /*List<num>|List<String>*/ frames,
      num frameRate,
      bool loop,
      bool useNumericIndex]);

  /// This method performs two actions: First it will check to see if the [Phaser.Weapon#bullets bullets] Group exists or not,
  /// and if not it creates it, adding it the `group` given as the 4th argument.
  /// Then it will seed the bullet pool with the `quantity` number of Bullets, using the texture key and frame
  /// provided (if any).
  /// If for example you set the quantity to be 10, then this Weapon will only ever be able to have 10 bullets
  /// in-flight simultaneously. If you try to fire an 11th bullet then nothing will happen until one, or more, of
  /// the in-flight bullets have been killed, freeing them up for use by the Weapon again.
  /// If you do not wish to have a limit set, then pass in -1 as the quantity. In this instance the Weapon will
  /// keep increasing the size of the bullet pool as needed. It will never reduce the size of the pool however,
  /// so be careful it doesn't grow too large.
  /// You can either set the texture key and frame here, or via the [Phaser.Weapon#bulletKey bulletKey] and [Phaser.Weapon#bulletFrame bulletFrame]
  /// properties. You can also animate bullets, or set them to use random frames. All Bullets belonging to a
  /// single Weapon instance must share the same texture key however.
  external Weapon createBullets(
      [num quantity, dynamic key, dynamic frame, Group group]);

  /// Uses `Game.Debug` to draw some useful information about this Weapon, including the number of bullets
  /// both in-flight, and available. And optionally the physics debug bodies of the bullets.
  external void debug([num x, num y, bool debugBodies]);

  /// Destroys this Weapon. It removes itself from the PluginManager, destroys
  /// the [Phaser.Weapon#bullets bullets] Group, and nulls internal references.
  external void destroy();

  /// Attempts to fire a single Bullet. If there are no more bullets available in the pool, and the pool cannot be extended,
  /// then this method returns `null`. It will also return `null` if not enough time has expired since the last time
  /// the Weapon was fired, as defined in the [Phaser.Weapon#fireRate fireRate] property.
  /// Otherwise the first available bullet is selected, launched, and returned.
  /// The arguments are all optional, but allow you to control both where the bullet is launched from, and aimed at.
  /// If you don't provide any of the arguments then it uses those set via properties such as [Phaser.Weapon#trackedSprite trackedSprite],
  /// [Phaser.Weapon#bulletAngle bulletAngle] and so on.
  /// When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is
  /// calculated based on Weapon properties like `bulletSpeed`.
  /// If you wish to fire multiple bullets in a single game update, then set `Weapon.multiFire = true`
  /// and you can call `fire` as many times as you like, per loop. Multiple fires in a single update
  /// only counts once towards the `shots` total, but you will still receive a Signal for each bullet.
  external Bullet fire([dynamic from, num x, num y, num offsetX, num offsetY]);

  /// Fires a bullet **at** the given Pointer. The bullet will be launched from the [Phaser.Weapon#fireFrom fireFrom] position,
  /// or from a Tracked Sprite or Pointer, if you have one set.
  external Bullet fireAtPointer(Pointer pointer);

  /// Fires a bullet **at** the given Sprite. The bullet will be launched from the [Phaser.Weapon#fireFrom fireFrom] position,
  /// or from a Tracked Sprite or Pointer, if you have one set.
  external Bullet fireAtSprite(Sprite sprite);

  /// Fires a bullet **at** the given coordinates. The bullet will be launched from the [Phaser.Weapon#fireFrom fireFrom] position,
  /// or from a Tracked Sprite or Pointer, if you have one set.
  external Bullet fireAtXY(num x, num y);

  /// Attempts to fire multiple bullets from the positions defined in the given array.
  /// If you provide a `from` argument, or if there is a tracked Sprite or Pointer, then
  /// the positions are treated as __offsets__ from the given objects position.
  /// If `from` is undefined, and there is no tracked object, then the bullets are fired
  /// from the given positions, as they exist in the world.
  /// Calling this method sets [Phaser.Weapon#multiFire multiFire] to `true`.
  /// If there are not enough bullets available in the pool, and the pool cannot be extended,
  /// then this method may not fire from all of the given positions.
  /// When the bullets are launched they have their texture and frame updated, as required.
  /// The velocity of the bullets are calculated based on Weapon properties like [Phaser.Weapon#bulletSpeed bulletSpeed].
  external List<Bullet> fireMany(List<dynamic> positions, [dynamic from]);

  /// Attempts to fire a single Bullet from a tracked Sprite or Pointer, but applies an offset
  /// to the position first. This is the same as calling [Phaser.Weapon#fire fire] and passing in the offset arguments.
  /// If there are no more bullets available in the pool, and the pool cannot be extended,
  /// then this method returns `null`. It will also return `null` if not enough time has expired since the last time
  /// the Weapon was fired, as defined in the [Phaser.Weapon#fireRate fireRate] property.
  /// Otherwise the first available bullet is selected, launched, and returned.
  /// When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is
  /// calculated based on Weapon properties like [Phaser.Weapon#bulletSpeed bulletSpeed].
  /// If you wish to fire multiple bullets in a single game update, then set [Phaser.Weapon#multiFire multiFire] to `true`
  /// and you can call this method as many times as you like, per loop. See also [Phaser.Weapon#fireMany fireMany].
  external Bullet fireOffset([num offsetX, num offsetY]);

  /// Call a function on each in-flight bullet in this Weapon.
  /// See [Phaser.Group#forEachExists forEachExists] for more details.
  external Weapon forEach(dynamic callback, dynamic callbackContext);

  /// Calls [Phaser.Bullet#kill] on every in-flight bullet in this Weapon.
  /// Also re-enables their physics bodies, should they have been disabled via [Phaser.Weapon#pauseAll pauseAll].
  external Weapon killAll();

  /// Sets [Phaser.Physics.Arcade.Body#enable] to `false` on each bullet in this Weapon.
  /// This has the effect of stopping them in-flight should they be moving.
  /// It also stops them being able to be checked for collision.
  external Weapon pauseAll();

  /// Resets the [Phaser.Weapon#shots shots] counter back to zero. This is used when you've set
  /// [Phaser.Weapon#fireLimit fireLimit] and have hit (or just wish to reset) your limit.
  external Weapon resetShots([num newLimit]);

  /// Sets [Phaser.Physics.Arcade.Body#enable] to `true` on each bullet in this Weapon.
  /// This has the effect of resuming their motion should they be in-flight.
  /// It also enables them for collision checks again.
  external Weapon resumeAll();

  /// You can modify the size of the physics Body the Bullets use to be any dimension you need.
  /// This allows you to make it smaller, or larger, than the parent Sprite.
  /// You can also control the x and y offset of the Body. This is the position of the
  /// Body relative to the top-left of the Sprite _texture_.
  /// For example: If you have a Sprite with a texture that is 80x100 in size,
  /// and you want the physics body to be 32x32 pixels in the middle of the texture, you would do:
  /// `setSize(32 / Math.abs(this.scale.x), 32 / Math.abs(this.scale.y), 24, 34)`
  /// Where the first two parameters are the new Body size (32x32 pixels) relative to the Sprite's scale.
  /// 24 is the horizontal offset of the Body from the top-left of the Sprites texture, and 34
  /// is the vertical offset.
  external Weapon setBulletBodyOffset(num width, num height,
      [num offsetX, num offsetY]);

  /// Sets the texture frames that the bullets can use when being launched.
  /// This is intended for use when you've got numeric based frames, such as those loaded via a Sprite Sheet.
  /// It works by calling `Phaser.ArrayUtils.numberArray` internally, using the min and max values
  /// provided. Then it sets the frame index to be zero.
  /// You can optionally set the cycle and random booleans, to allow bullets to cycle through the frames
  /// when they're fired, or pick one at random.
  external Weapon setBulletFrames(num min, num max, [bool cycle, bool random]);

  /// Sets this Weapon to track the given Pointer.
  /// When a Weapon tracks a Pointer it will automatically update its [Phaser.Weapon#fireFrom fireFrom] value to match the Pointer's
  /// position within the Game World, adjusting the coordinates based on the offset arguments.
  /// This allows you to lock a Weapon to a Pointer, so that bullets are always launched from its location.
  /// Calling `trackPointer` will reset [Phaser.Weapon#trackedSprite trackedSprite] to null, should it have been set, as you can
  /// only track _either_ a Pointer, or a Sprite, at once, but not both.
  external Weapon trackPointer(Pointer pointer, [num offsetX, num offsetY]);

  /// Sets this Weapon to track the given Sprite, or any Object with a public [Phaser.Component.Core#world world] Point object.
  /// When a Weapon tracks a Sprite it will automatically update its [Phaser.Weapon#fireFrom fireFrom] value to match the Sprite's
  /// position within the Game World, adjusting the coordinates based on the offset arguments.
  /// This allows you to lock a Weapon to a Sprite, so that bullets are always launched from its location.
  /// Calling `trackSprite` will reset [Phaser.Weapon#trackedPointer trackedPointer] to null, should it have been set, as you can
  /// only track _either_ a Sprite, or a Pointer, at once, but not both.
  external Weapon trackSprite(Sprite sprite,
      [num offsetX, num offsetY, bool trackRotation]);
}

/// "This world is but a canvas to our imagination." - Henry David Thoreau
/// A game has only one world. The world is an abstract place in which all game objects live. It is not bound
/// by stage limits and can be any size. You look into the world via cameras. All game objects live within
/// the world at world-based coordinates. By default a world is created the same size as your Stage.
@JS("Phaser.World")
class World extends Group {
  // @Ignore
  World.fakeConstructor$() : super.fakeConstructor$();

  /// "This world is but a canvas to our imagination." - Henry David Thoreau
  /// A game has only one world. The world is an abstract place in which all game objects live. It is not bound
  /// by stage limits and can be any size. You look into the world via cameras. All game objects live within
  /// the world at world-based coordinates. By default a world is created the same size as your Stage.
  external factory World(Game game);

  /// The World has no fixed size, but it does have a bounds outside of which objects are no longer considered as being "in world" and you should use this to clean-up the display list and purge dead objects.
  /// By default we set the Bounds to be from 0,0 to Game.width,Game.height. I.e. it will match the size given to the game constructor with 0,0 representing the top-left of the display.
  /// However 0,0 is actually the center of the world, and if you rotate or scale the world all of that will happen from 0,0.
  /// So if you want to make a game in which the world itself will rotate you should adjust the bounds so that 0,0 is the center point, i.e. set them to -1000,-1000,2000,2000 for a 2000x2000 sized world centered around 0,0. Bound of this world that objects can not escape from.
  external Rectangle get bounds;
  external set bounds(Rectangle v);

  /// Camera instance.
  external Camera get camera;
  external set camera(Camera v);

  /// Gets the X position corresponding to the center point of the world.
  external num get centerX;
  external set centerX(num v);

  /// Gets the Y position corresponding to the center point of the world.
  external num get centerY;
  external set centerY(num v);

  /// A reference to the currently running Game.
  external Game get game;
  external set game(Game v);

  /// Gets or sets the current height of the game world. The world can never be smaller than the game (canvas) dimensions.
  external num get height;
  external set height(num v);
  external bool get isPaused;
  external set isPaused(bool v);

  /// Gets a random integer which is lesser than or equal to the current width of the game world.
  external num get randomX;
  external set randomX(num v);

  /// Gets a random integer which is lesser than or equal to the current height of the game world.
  external num get randomY;
  external set randomY(num v);
  external dynamic
      /*{
            skipped: number;
            ignored: number;
            checked: number;
        }*/
      get stats;
  external set stats(
      dynamic /*{
            skipped: number;
            ignored: number;
            checked: number;
        }*/
      v);

  /// Gets or sets the current width of the game world. The world can never be smaller than the game (canvas) dimensions.
  external num get width;
  external set width(num v);

  /// Initialises the game world.
  external void boot();
  external Sprite getObjectsUnderPointer(Pointer pointer, Group group,
      [Function callback, dynamic callbackContext]);

  /// Updates this world's width and height (but not smaller than any previous [#setBounds defined size]).
  /// Phaser uses this to adapt to [Phaser.ScaleManager#updateDimensions layout changes].
  /// You probably want to use [Phaser.World#setBounds setBounds] instead.
  external void resize(num width, num height);

  /// Updates the size of this world and sets World.x/y to the given values
  /// The Camera bounds and Physics bounds (if set) are also updated to match the new World bounds.
  external void setBounds(num x, num y, num width, num height);
  external num sortLeftRight(Sprite a, Sprite b);
  external num sortRightLeft(Sprite a, Sprite b);
  external num sortTopBottom(Sprite a, Sprite b);
  external num sortBottomTop(Sprite a, Sprite b);

  /// Sort the children in the group according to a particular key and ordering.
  /// Call this function to sort the group according to a particular key value and order.
  /// For example to depth sort Sprites for Zelda-style game you might call `group.sort('y', Phaser.Group.SORT_ASCENDING)` at the bottom of your `State.update()`.
  /// Internally this uses a standard JavaScript Array sort, so everything that applies there also applies here, including
  /// alphabetical sorting, mixing strings and numbers, and Unicode sorting. See MDN for more details.
  /*external void sort(Group group, [num sortDirection]);*/
  /// Sort the children in the group according to a particular key and ordering.
  /// Call this function to sort the group according to a particular key value and order.
  /// For example to depth sort Sprites for Zelda-style game you might call `group.sort('y', Phaser.Group.SORT_ASCENDING)` at the bottom of your `State.update()`.
  /// Internally this uses a standard JavaScript Array sort, so everything that applies there also applies here, including
  /// alphabetical sorting, mixing strings and numbers, and Unicode sorting. See MDN for more details.
  /*external void sort([String key, num order]);*/
  external void sort(
      [dynamic /*Group|String*/ group_key, num sortDirection_order]);

  /// Destroyer of worlds.
  external void shutdown();

  /// This will take the given game object and check if its x/y coordinates fall outside of the world bounds.
  /// If they do it will reposition the object to the opposite side of the world, creating a wrap-around effect.
  /// If sprite has a P2 body then the body (sprite.body) should be passed as first parameter to the function.
  /// Please understand there are limitations to this method. For example if you have scaled the World
  /// then objects won't always be re-positioned correctly, and you'll need to employ your own wrapping function.
  external void wrap(dynamic sprite,
      [num padding, bool useBounds, bool horizontal, bool vertical]);
  external void wrapAll(Group group,
      [bool checkExists,
      num padding,
      bool useBounds,
      bool horizontal,
      bool vertical]);
}

// End module Phaser

